(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@onflow/util-logger'), require('@onflow/util-invariant'), require('crypto'), require('@onflow/config'), require('@onflow/rlp'), require('cross-fetch'), require('@onflow/util-address'), require('abort-controller'), require('sha3'), require('@onflow/util-template')) :
  typeof define === 'function' && define.amd ? define(['exports', '@onflow/util-logger', '@onflow/util-invariant', 'crypto', '@onflow/config', '@onflow/rlp', 'cross-fetch', '@onflow/util-address', 'abort-controller', 'sha3', '@onflow/util-template'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.onflowSdk = {}, global.logger$1, global.require$$0$1, global.require$$0, global.config, global.rlp, global.require$$3, global.require$$4, global.require$$5, global.sha3, global.utilTemplate));
})(this, (function (exports, logger$1, require$$0$1, require$$0, config, rlp, require$$3, require$$4, require$$5, sha3, utilTemplate) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }

  var logger__default = /*#__PURE__*/_interopDefaultLegacy(logger$1);
  var logger__namespace$1 = /*#__PURE__*/_interopNamespace(logger$1);
  var require$$0__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$0$1);
  var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);
  var require$$3__default = /*#__PURE__*/_interopDefaultLegacy(require$$3);
  var require$$4__default = /*#__PURE__*/_interopDefaultLegacy(require$$4);
  var require$$5__default = /*#__PURE__*/_interopDefaultLegacy(require$$5);

  var dist = {};

  var v1$1 = {};

  var rng$1 = {};

  Object.defineProperty(rng$1, "__esModule", {
    value: true
  });
  rng$1.default = rng;
  var _crypto$3 = _interopRequireDefault$c(require$$0__default["default"]);
  function _interopRequireDefault$c(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

  let poolPtr = rnds8Pool.length;
  function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
      _crypto$3.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  }

  var stringify$1 = {};

  var validate$1 = {};

  var regex = {};

  Object.defineProperty(regex, "__esModule", {
    value: true
  });
  regex.default = void 0;
  var _default$c = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  regex.default = _default$c;

  Object.defineProperty(validate$1, "__esModule", {
    value: true
  });
  validate$1.default = void 0;
  var _regex = _interopRequireDefault$b(regex);
  function _interopRequireDefault$b(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function validate(uuid) {
    return typeof uuid === 'string' && _regex.default.test(uuid);
  }
  var _default$b = validate;
  validate$1.default = _default$b;

  Object.defineProperty(stringify$1, "__esModule", {
    value: true
  });
  stringify$1.default = void 0;
  stringify$1.unsafeStringify = unsafeStringify;
  var _validate$2 = _interopRequireDefault$a(validate$1);
  function _interopRequireDefault$a(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  /**
   * Convert array of 16 byte values to UUID string format of the form:
   * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
   */
  const byteToHex = [];
  for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 0x100).toString(16).slice(1));
  }
  function unsafeStringify(arr) {
    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
  }
  function stringify(arr) {
    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields

    if (!(0, _validate$2.default)(uuid)) {
      throw TypeError('Stringified UUID is invalid');
    }
    return uuid;
  }
  var _default$a = stringify;
  stringify$1.default = _default$a;

  Object.defineProperty(v1$1, "__esModule", {
    value: true
  });
  v1$1.default = void 0;
  var _rng$1 = _interopRequireDefault$9(rng$1);
  var _stringify$2 = stringify$1;
  function _interopRequireDefault$9(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html
  let _nodeId;
  let _clockseq; // Previous uuid creation time

  let _lastMSecs = 0;
  let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

  function v1(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node = options.node || _nodeId;
    let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
    // specified.  We do this lazily to minimize issues related to insufficient
    // system entropy.  See #189

    if (node == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng$1.default)();
      if (node == null) {
        // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
        node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        // Per 4.2.2, randomize (14 bit) clockseq
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
      }
    } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.

    let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock

    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 0x3fff;
    } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval

    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    } // Per 4.2.1.2 Throw error if too many uuids are requested

    if (nsecs >= 10000) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

    msecs += 12219292800000; // `time_low`

    const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff; // `time_mid`

    const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff; // `time_high_and_version`

    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

    b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

    b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

    b[i++] = clockseq & 0xff; // `node`

    for (let n = 0; n < 6; ++n) {
      b[i + n] = node[n];
    }
    return buf || (0, _stringify$2.unsafeStringify)(b);
  }
  var _default$9 = v1;
  v1$1.default = _default$9;

  var v3$1 = {};

  var v35$1 = {};

  var parse$1 = {};

  Object.defineProperty(parse$1, "__esModule", {
    value: true
  });
  parse$1.default = void 0;
  var _validate$1 = _interopRequireDefault$8(validate$1);
  function _interopRequireDefault$8(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function parse(uuid) {
    if (!(0, _validate$1.default)(uuid)) {
      throw TypeError('Invalid UUID');
    }
    let v;
    const arr = new Uint8Array(16); // Parse ########-....-....-....-............

    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 0xff;
    arr[2] = v >>> 8 & 0xff;
    arr[3] = v & 0xff; // Parse ........-####-....-....-............

    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 0xff; // Parse ........-....-####-....-............

    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 0xff; // Parse ........-....-....-####-............

    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 0xff; // Parse ........-....-....-....-############
    // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
    arr[11] = v / 0x100000000 & 0xff;
    arr[12] = v >>> 24 & 0xff;
    arr[13] = v >>> 16 & 0xff;
    arr[14] = v >>> 8 & 0xff;
    arr[15] = v & 0xff;
    return arr;
  }
  var _default$8 = parse;
  parse$1.default = _default$8;

  Object.defineProperty(v35$1, "__esModule", {
    value: true
  });
  v35$1.URL = v35$1.DNS = void 0;
  v35$1.default = v35;
  var _stringify$1 = stringify$1;
  var _parse = _interopRequireDefault$7(parse$1);
  function _interopRequireDefault$7(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function stringToBytes(str) {
    str = unescape(encodeURIComponent(str)); // UTF8 escape

    const bytes = [];
    for (let i = 0; i < str.length; ++i) {
      bytes.push(str.charCodeAt(i));
    }
    return bytes;
  }
  const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
  v35$1.DNS = DNS;
  const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
  v35$1.URL = URL;
  function v35(name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
      var _namespace;
      if (typeof value === 'string') {
        value = stringToBytes(value);
      }
      if (typeof namespace === 'string') {
        namespace = (0, _parse.default)(namespace);
      }
      if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
        throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
      } // Compute hash of namespace and value, Per 4.3
      // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
      // hashfunc([...namespace, ... value])`

      let bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 0x0f | version;
      bytes[8] = bytes[8] & 0x3f | 0x80;
      if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = bytes[i];
        }
        return buf;
      }
      return (0, _stringify$1.unsafeStringify)(bytes);
    } // Function#name is not settable on some platforms (#270)

    try {
      generateUUID.name = name; // eslint-disable-next-line no-empty
    } catch (err) {} // For CommonJS default export support

    generateUUID.DNS = DNS;
    generateUUID.URL = URL;
    return generateUUID;
  }

  var md5$1 = {};

  Object.defineProperty(md5$1, "__esModule", {
    value: true
  });
  md5$1.default = void 0;
  var _crypto$2 = _interopRequireDefault$6(require$$0__default["default"]);
  function _interopRequireDefault$6(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function md5(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === 'string') {
      bytes = Buffer.from(bytes, 'utf8');
    }
    return _crypto$2.default.createHash('md5').update(bytes).digest();
  }
  var _default$7 = md5;
  md5$1.default = _default$7;

  Object.defineProperty(v3$1, "__esModule", {
    value: true
  });
  v3$1.default = void 0;
  var _v$1 = _interopRequireDefault$5(v35$1);
  var _md = _interopRequireDefault$5(md5$1);
  function _interopRequireDefault$5(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  const v3 = (0, _v$1.default)('v3', 0x30, _md.default);
  var _default$6 = v3;
  v3$1.default = _default$6;

  var v4$1 = {};

  var native = {};

  Object.defineProperty(native, "__esModule", {
    value: true
  });
  native.default = void 0;
  var _crypto$1 = _interopRequireDefault$4(require$$0__default["default"]);
  function _interopRequireDefault$4(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  var _default$5 = {
    randomUUID: _crypto$1.default.randomUUID
  };
  native.default = _default$5;

  Object.defineProperty(v4$1, "__esModule", {
    value: true
  });
  v4$1.default = void 0;
  var _native = _interopRequireDefault$3(native);
  var _rng = _interopRequireDefault$3(rng$1);
  var _stringify = stringify$1;
  function _interopRequireDefault$3(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function v4(options, buf, offset) {
    if (_native.default.randomUUID && !buf && !options) {
      return _native.default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(rnds);
  }
  var _default$4 = v4;
  v4$1.default = _default$4;

  var v5$1 = {};

  var sha1$1 = {};

  Object.defineProperty(sha1$1, "__esModule", {
    value: true
  });
  sha1$1.default = void 0;
  var _crypto = _interopRequireDefault$2(require$$0__default["default"]);
  function _interopRequireDefault$2(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function sha1(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === 'string') {
      bytes = Buffer.from(bytes, 'utf8');
    }
    return _crypto.default.createHash('sha1').update(bytes).digest();
  }
  var _default$3 = sha1;
  sha1$1.default = _default$3;

  Object.defineProperty(v5$1, "__esModule", {
    value: true
  });
  v5$1.default = void 0;
  var _v = _interopRequireDefault$1(v35$1);
  var _sha = _interopRequireDefault$1(sha1$1);
  function _interopRequireDefault$1(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  const v5 = (0, _v.default)('v5', 0x50, _sha.default);
  var _default$2 = v5;
  v5$1.default = _default$2;

  var nil = {};

  Object.defineProperty(nil, "__esModule", {
    value: true
  });
  nil.default = void 0;
  var _default$1 = '00000000-0000-0000-0000-000000000000';
  nil.default = _default$1;

  var version$1 = {};

  Object.defineProperty(version$1, "__esModule", {
    value: true
  });
  version$1.default = void 0;
  var _validate = _interopRequireDefault(validate$1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function version(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError('Invalid UUID');
    }
    return parseInt(uuid.slice(14, 15), 16);
  }
  var _default = version;
  version$1.default = _default;

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "NIL", {
      enumerable: true,
      get: function () {
        return _nil.default;
      }
    });
    Object.defineProperty(exports, "parse", {
      enumerable: true,
      get: function () {
        return _parse.default;
      }
    });
    Object.defineProperty(exports, "stringify", {
      enumerable: true,
      get: function () {
        return _stringify.default;
      }
    });
    Object.defineProperty(exports, "v1", {
      enumerable: true,
      get: function () {
        return _v.default;
      }
    });
    Object.defineProperty(exports, "v3", {
      enumerable: true,
      get: function () {
        return _v2.default;
      }
    });
    Object.defineProperty(exports, "v4", {
      enumerable: true,
      get: function () {
        return _v3.default;
      }
    });
    Object.defineProperty(exports, "v5", {
      enumerable: true,
      get: function () {
        return _v4.default;
      }
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function () {
        return _validate.default;
      }
    });
    Object.defineProperty(exports, "version", {
      enumerable: true,
      get: function () {
        return _version.default;
      }
    });
    var _v = _interopRequireDefault(v1$1);
    var _v2 = _interopRequireDefault(v3$1);
    var _v3 = _interopRequireDefault(v4$1);
    var _v4 = _interopRequireDefault(v5$1);
    var _nil = _interopRequireDefault(nil);
    var _version = _interopRequireDefault(version$1);
    var _validate = _interopRequireDefault(validate$1);
    var _stringify = _interopRequireDefault(stringify$1);
    var _parse = _interopRequireDefault(parse$1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
  })(dist);

  const UNKNOWN /*                       */ = "UNKNOWN";
  const SCRIPT /*                        */ = "SCRIPT";
  const TRANSACTION /*                   */ = "TRANSACTION";
  const GET_TRANSACTION_STATUS /*        */ = "GET_TRANSACTION_STATUS";
  const GET_ACCOUNT /*                   */ = "GET_ACCOUNT";
  const GET_EVENTS /*                    */ = "GET_EVENTS";
  const PING /*                          */ = "PING";
  const GET_TRANSACTION /*               */ = "GET_TRANSACTION";
  const GET_BLOCK /*                     */ = "GET_BLOCK";
  const GET_BLOCK_HEADER /*              */ = "GET_BLOCK_HEADER";
  const GET_COLLECTION /*                */ = "GET_COLLECTION";
  const GET_NETWORK_PARAMETERS /*        */ = "GET_NETWORK_PARAMETERS";
  const BAD /* */ = "BAD";
  const OK /*  */ = "OK";
  const ACCOUNT /*  */ = "ACCOUNT";
  const PARAM /*    */ = "PARAM";
  const ARGUMENT /* */ = "ARGUMENT";
  const AUTHORIZER /* */ = "authorizer";
  const PAYER /*      */ = "payer";
  const PROPOSER /*   */ = "proposer";
  const ACCT = `{
  "kind":"${ACCOUNT}",
  "tempId":null,
  "addr":null,
  "keyId":null,
  "sequenceNum":null,
  "signature":null,
  "signingFunction":null,
  "resolve":null,
  "role": {
    "proposer":false,
    "authorizer":false,
    "payer":false,
    "param":false
  }
}`;
  const ARG = `{
  "kind":"${ARGUMENT}",
  "tempId":null,
  "value":null,
  "asArgument":null,
  "xform":null,
  "resolve": null,
  "resolveArgument": null
}`;
  const IX = `{
  "tag":"${UNKNOWN}",
  "assigns":{},
  "status":"${OK}",
  "reason":null,
  "accounts":{},
  "params":{},
  "arguments":{},
  "message": {
    "cadence":null,
    "refBlock":null,
    "computeLimit":null,
    "proposer":null,
    "payer":null,
    "authorizations":[],
    "params":[],
    "arguments":[]
  },
  "proposer":null,
  "authorizations":[],
  "payer":[],
  "events": {
    "eventType":null,
    "start":null,
    "end":null,
    "blockIds":[]
  },
  "transaction": {
    "id":null
  },
  "block": {
    "id":null,
    "height":null,
    "isSealed":null
  },
  "account": {
    "addr":null
  },
  "collection": {
    "id":null
  }
}`;
  const KEYS = new Set(Object.keys(JSON.parse(IX)));
  const interaction = () => JSON.parse(IX);
  const isNumber$1 = d => typeof d === "number";
  const isArray$1 = d => Array.isArray(d);
  const isObj = d => d !== null && typeof d === "object";
  const isNull = d => d == null;
  const isFn$3 = d => typeof d === "function";
  const isInteraction = ix => {
    if (!isObj(ix) || isNull(ix) || isNumber$1(ix)) return false;
    for (let key of KEYS) if (!ix.hasOwnProperty(key)) return false;
    return true;
  };
  const Ok = ix => {
    ix.status = OK;
    return ix;
  };
  const Bad = (ix, reason) => {
    ix.status = BAD;
    ix.reason = reason;
    return ix;
  };
  const makeIx = wat => ix => {
    ix.tag = wat;
    return Ok(ix);
  };
  const prepAccountKeyId = acct => {
    if (acct.keyId == null) return acct;
    require$$0$1.invariant(!isNaN(parseInt(acct.keyId)), "account.keyId must be an integer");
    return {
      ...acct,
      keyId: parseInt(acct.keyId)
    };
  };
  const prepAccount = function (acct) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return ix => {
      require$$0$1.invariant(typeof acct === "function" || typeof acct === "object", "prepAccount must be passed an authorization function or an account object");
      require$$0$1.invariant(opts.role != null, "Account must have a role");
      const ACCOUNT = JSON.parse(ACCT);
      const role = opts.role;
      const tempId = dist.v4();
      if (acct.authorization && isFn$3(acct.authorization)) acct = {
        resolve: acct.authorization
      };
      if (!acct.authorization && isFn$3(acct)) acct = {
        resolve: acct
      };
      const resolve = acct.resolve;
      if (resolve) acct.resolve = function (acct) {
        for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          rest[_key - 1] = arguments[_key];
        }
        return [resolve, prepAccountKeyId].reduce(async (d, fn) => fn(await d, ...rest), acct);
      };
      acct = prepAccountKeyId(acct);
      ix.accounts[tempId] = {
        ...ACCOUNT,
        tempId,
        ...acct,
        role: {
          ...ACCOUNT.role,
          ...(typeof acct.role === "object" ? acct.role : {}),
          [role]: true
        }
      };
      if (role === AUTHORIZER) {
        ix.authorizations.push(tempId);
      } else if (role === PAYER) {
        ix.payer.push(tempId);
      } else {
        ix[role] = tempId;
      }
      return ix;
    };
  };
  const makeArgument = arg => ix => {
    let tempId = dist.v4();
    ix.message.arguments.push(tempId);
    ix.arguments[tempId] = JSON.parse(ARG);
    ix.arguments[tempId].tempId = tempId;
    ix.arguments[tempId].value = arg.value;
    ix.arguments[tempId].asArgument = arg.asArgument;
    ix.arguments[tempId].xform = arg.xform;
    ix.arguments[tempId].resolve = arg.resolve;
    ix.arguments[tempId].resolveArgument = isFn$3(arg.resolveArgument) ? arg.resolveArgument.bind(arg) : arg.resolveArgument;
    return Ok(ix);
  };
  const makeUnknown /*                 */ = makeIx(UNKNOWN);
  const makeScript /*                  */ = makeIx(SCRIPT);
  const makeTransaction /*             */ = makeIx(TRANSACTION);
  const makeGetTransactionStatus /*    */ = makeIx(GET_TRANSACTION_STATUS);
  const makeGetTransaction /*          */ = makeIx(GET_TRANSACTION);
  const makeGetAccount /*              */ = makeIx(GET_ACCOUNT);
  const makeGetEvents /*               */ = makeIx(GET_EVENTS);
  const makePing /*                    */ = makeIx(PING);
  const makeGetBlock /*                */ = makeIx(GET_BLOCK);
  const makeGetBlockHeader /*          */ = makeIx(GET_BLOCK_HEADER);
  const makeGetCollection /*           */ = makeIx(GET_COLLECTION);
  const makeGetNetworkParameters /*    */ = makeIx(GET_NETWORK_PARAMETERS);
  const is = wat => ix => ix.tag === wat;
  const isUnknown /*                 */ = is(UNKNOWN);
  const isScript /*                  */ = is(SCRIPT);
  const isTransaction /*             */ = is(TRANSACTION);
  const isGetTransactionStatus /*    */ = is(GET_TRANSACTION_STATUS);
  const isGetTransaction /*          */ = is(GET_TRANSACTION);
  const isGetAccount /*              */ = is(GET_ACCOUNT);
  const isGetEvents /*               */ = is(GET_EVENTS);
  const isPing /*                    */ = is(PING);
  const isGetBlock /*                */ = is(GET_BLOCK);
  const isGetBlockHeader /*          */ = is(GET_BLOCK_HEADER);
  const isGetCollection /*           */ = is(GET_COLLECTION);
  const isGetNetworkParameters /*    */ = is(GET_NETWORK_PARAMETERS);
  const isOk /*  */ = ix => ix.status === OK;
  const isBad /* */ = ix => ix.status === BAD;
  const why /*   */ = ix => ix.reason;
  const isAccount /*  */ = account => account.kind === ACCOUNT;
  const isParam /*    */ = param => param.kind === PARAM;
  const isArgument /* */ = argument => argument.kind === ARGUMENT;
  const hardMode = ix => {
    for (let key of Object.keys(ix)) {
      if (!KEYS.has(key)) throw new Error(`"${key}" is an invalid root level Interaction property.`);
    }
    return ix;
  };
  const recPipe = async function (ix) {
    let fns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    try {
      ix = hardMode(await ix);
      if (isBad(ix)) throw new Error(`Interaction Error: ${ix.reason}`);
      if (!fns.length) return ix;
      const [hd, ...rest] = fns;
      const cur = await hd;
      if (isFn$3(cur)) return recPipe(cur(ix), rest);
      if (isNull(cur) || !cur) return recPipe(ix, rest);
      if (isInteraction(cur)) return recPipe(cur, rest);
      throw new Error("Invalid Interaction Composition");
    } catch (e) {
      throw e;
    }
  };
  const pipe = function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    const [arg1, arg2] = args;
    if (isArray$1(arg1) && arg2 == null) return d => pipe(d, arg1);
    return recPipe(arg1, arg2);
  };
  const identity$1 = v => v;
  const get = (ix, key, fallback) => {
    return ix.assigns[key] == null ? fallback : ix.assigns[key];
  };
  const put = (key, value) => ix => {
    ix.assigns[key] = value;
    return Ok(ix);
  };
  const update = function (key) {
    let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$1;
    return ix => {
      ix.assigns[key] = fn(ix.assigns[key], ix);
      return Ok(ix);
    };
  };
  const destroy = key => ix => {
    delete ix.assigns[key];
    return Ok(ix);
  };

  var ixModule = /*#__PURE__*/Object.freeze({
    __proto__: null,
    UNKNOWN: UNKNOWN,
    SCRIPT: SCRIPT,
    TRANSACTION: TRANSACTION,
    GET_TRANSACTION_STATUS: GET_TRANSACTION_STATUS,
    GET_ACCOUNT: GET_ACCOUNT,
    GET_EVENTS: GET_EVENTS,
    PING: PING,
    GET_TRANSACTION: GET_TRANSACTION,
    GET_BLOCK: GET_BLOCK,
    GET_BLOCK_HEADER: GET_BLOCK_HEADER,
    GET_COLLECTION: GET_COLLECTION,
    GET_NETWORK_PARAMETERS: GET_NETWORK_PARAMETERS,
    BAD: BAD,
    OK: OK,
    ACCOUNT: ACCOUNT,
    PARAM: PARAM,
    ARGUMENT: ARGUMENT,
    AUTHORIZER: AUTHORIZER,
    PAYER: PAYER,
    PROPOSER: PROPOSER,
    interaction: interaction,
    isNumber: isNumber$1,
    isArray: isArray$1,
    isObj: isObj,
    isNull: isNull,
    isFn: isFn$3,
    isInteraction: isInteraction,
    Ok: Ok,
    Bad: Bad,
    prepAccount: prepAccount,
    makeArgument: makeArgument,
    makeUnknown: makeUnknown,
    makeScript: makeScript,
    makeTransaction: makeTransaction,
    makeGetTransactionStatus: makeGetTransactionStatus,
    makeGetTransaction: makeGetTransaction,
    makeGetAccount: makeGetAccount,
    makeGetEvents: makeGetEvents,
    makePing: makePing,
    makeGetBlock: makeGetBlock,
    makeGetBlockHeader: makeGetBlockHeader,
    makeGetCollection: makeGetCollection,
    makeGetNetworkParameters: makeGetNetworkParameters,
    isUnknown: isUnknown,
    isScript: isScript,
    isTransaction: isTransaction,
    isGetTransactionStatus: isGetTransactionStatus,
    isGetTransaction: isGetTransaction,
    isGetAccount: isGetAccount,
    isGetEvents: isGetEvents,
    isPing: isPing,
    isGetBlock: isGetBlock,
    isGetBlockHeader: isGetBlockHeader,
    isGetCollection: isGetCollection,
    isGetNetworkParameters: isGetNetworkParameters,
    isOk: isOk,
    isBad: isBad,
    why: why,
    isAccount: isAccount,
    isParam: isParam,
    isArgument: isArgument,
    pipe: pipe,
    get: get,
    put: put,
    update: update,
    destroy: destroy
  });

  function build() {
    let fns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return pipe(interaction(), fns);
  }

  var sdkSendHttp = {};

  Object.defineProperty(sdkSendHttp, '__esModule', {
    value: true
  });
  var utilInvariant = require$$0__default$1["default"];
  var logger = logger__default["default"];
  var fetchTransport = require$$3__default["default"];
  var utilAddress = require$$4__default["default"];
  function _interopDefaultLegacy$1(e) {
    return e && typeof e === 'object' && 'default' in e ? e : {
      'default': e
    };
  }
  function _interopNamespace$1(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () {
              return e[k];
            }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }
  var logger__namespace = /*#__PURE__*/_interopNamespace$1(logger);
  var fetchTransport__default = /*#__PURE__*/_interopDefaultLegacy$1(fetchTransport);
  const AbortController = globalThis.AbortController || require$$5__default["default"];
  class HTTPRequestError extends Error {
    constructor(_ref) {
      let {
        error,
        hostname,
        path,
        method,
        requestBody,
        responseBody,
        responseStatusText,
        statusCode
      } = _ref;
      const msg = `
      HTTP Request Error: An error occurred when interacting with the Access API.
      ${error ? `error=${error}` : ""}
      ${hostname ? `hostname=${hostname}` : ""}
      ${path ? `path=${path}` : ""}
      ${method ? `method=${method}` : ""}
      ${requestBody ? `requestBody=${requestBody}` : ""}
      ${responseBody ? `responseBody=${responseBody}` : ""}
      ${responseStatusText ? `responseStatusText=${responseStatusText}` : ""}
      ${statusCode ? `statusCode=${statusCode}` : ""}
    `;
      super(msg);
      this.name = "HTTP Request Error";
      this.statusCode = statusCode;
      this.errorMessage = error;
    }
  }

  /**
   * Creates an HTTP Request to be sent to a REST Access API via Fetch API.
   *
   * @param {object} options - Options for the HTTP Request
   * @param {String} options.hostname - Access API Hostname
   * @param {String} options.path - Path to the resource on the Access API
   * @param {String} options.method - HTTP Method
   * @param {object} options.body - HTTP Request Body
   * @param {object} [options.headers] - HTTP Request Headers
   * @param {boolean} [options.enableRequestLogging=true] - Enable/Disable request logging
   * @param {number} [options.retryLimit=5] - Number of times to retry request
   * @param {number} [options.retryIntervalMs=1000] - Time in milliseconds to wait before retrying request
   * @param {number} [options.timeoutLimit=30000] - Time in milliseconds to wait before timing out request
   *
   * @returns JSON object response from Access API.
   */
  async function httpRequest(_ref2) {
    let {
      hostname,
      path,
      method,
      body,
      headers,
      retryLimit = 5,
      retryIntervalMs = 1000,
      timeoutLimit = 30000,
      enableRequestLogging = true
    } = _ref2;
    const bodyJSON = body ? JSON.stringify(body) : null;
    function makeRequest() {
      const controller = new AbortController();
      const fetchTimeout = setTimeout(() => {
        controller.abort();
      }, timeoutLimit);
      return fetchTransport__default["default"](`${hostname}${path}`, {
        method: method,
        body: bodyJSON,
        headers,
        signal: controller.signal
      }).then(async res => {
        if (res.ok) {
          return res.json();
        }
        const responseText = await res.text().catch(() => null);
        const response = safeParseJSON(responseText);
        throw new HTTPRequestError({
          error: response?.message,
          hostname,
          path,
          method,
          requestBody: bodyJSON,
          responseBody: responseText,
          responseStatusText: res.statusText,
          statusCode: res.status
        });
      }).catch(async e => {
        if (e instanceof HTTPRequestError) {
          throw e;
        }
        if (e.name === "AbortError") {
          throw e;
        }

        // Show AN error for all network errors
        if (enableRequestLogging) {
          await logger__namespace.log({
            title: "Access Node Error",
            message: `The provided access node ${hostname} does not appear to be a valid REST/HTTP access node.
  Please verify that you are not unintentionally using a GRPC access node.
  See more here: https://docs.onflow.org/fcl/reference/sdk-guidelines/#connect`,
            level: logger__namespace.LEVELS.error
          });
        }
        throw new HTTPRequestError({
          error: e?.message,
          hostname,
          path,
          method,
          requestBody: bodyJSON
        });
      }).finally(() => {
        clearTimeout(fetchTimeout);
      });
    }
    async function requestLoop() {
      let retryAttempt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      try {
        const resp = await makeRequest();
        return resp;
      } catch (error) {
        const retryStatusCodes = [408, 429, 500, 502, 503, 504];
        if (error.name === "AbortError" || retryStatusCodes.includes(error.statusCode)) {
          return await new Promise((resolve, reject) => {
            if (retryAttempt < retryLimit) {
              if (enableRequestLogging) {
                console.warn(`Access node unavailable, retrying in ${retryIntervalMs} ms...`);
              }
              setTimeout(() => {
                resolve(requestLoop(retryAttempt + 1));
              }, retryIntervalMs);
            } else {
              reject(error);
            }
          });
        } else {
          throw error;
        }
      }
    }

    // Keep retrying request until server available or max attempts exceeded
    return await requestLoop();
  }
  function safeParseJSON(data) {
    try {
      return JSON.parse(data);
    } catch {
      return null;
    }
  }
  async function sendExecuteScriptAtBlockIDRequest(ix, context, opts) {
    const httpRequest$1 = opts.httpRequest || httpRequest;
    const res = await httpRequest$1({
      hostname: opts.node,
      path: `/v1/scripts?block_id=${ix.block.id}`,
      method: "POST",
      body: {
        script: context.Buffer.from(ix.message.cadence).toString("base64"),
        arguments: ix.message.arguments.map(arg => context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString("base64"))
      }
    });
    return constructResponse$4(ix, context, res);
  }
  async function sendExecuteScriptAtBlockHeightRequest(ix, context, opts) {
    const httpRequest$1 = opts.httpRequest || httpRequest;
    const res = await httpRequest$1({
      hostname: opts.node,
      path: `/v1/scripts?block_height=${ix.block.height}`,
      method: "POST",
      body: {
        script: context.Buffer.from(ix.message.cadence).toString("base64"),
        arguments: ix.message.arguments.map(arg => context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString("base64"))
      }
    });
    return constructResponse$4(ix, context, res);
  }
  async function sendExecuteScriptAtLatestBlockRequest(ix, context, opts) {
    const httpRequest$1 = opts.httpRequest || httpRequest;
    const res = await httpRequest$1({
      hostname: opts.node,
      path: `/v1/scripts?block_height=sealed`,
      method: "POST",
      body: {
        script: context.Buffer.from(ix.message.cadence).toString("base64"),
        arguments: ix.message.arguments.map(arg => context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString("base64"))
      }
    });
    return constructResponse$4(ix, context, res);
  }
  function constructResponse$4(ix, context, res) {
    let ret = context.response();
    ret.tag = ix.tag;
    ret.encodedData = JSON.parse(context.Buffer.from(res, "base64").toString());
    return ret;
  }
  async function sendExecuteScript(ix) {
    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    utilInvariant.invariant(opts.node, `SDK Send Execute Script Error: opts.node must be defined.`);
    utilInvariant.invariant(context.response, `SDK Send Execute Script Error: context.response must be defined.`);
    utilInvariant.invariant(context.Buffer, `SDK Send Execute Script Error: context.Buffer must be defined.`);
    ix = await ix;
    if (ix.block.id) {
      return await sendExecuteScriptAtBlockIDRequest(ix, context, opts);
    } else if (ix.block.height) {
      return await sendExecuteScriptAtBlockHeightRequest(ix, context, opts);
    } else {
      return await sendExecuteScriptAtLatestBlockRequest(ix, context, opts);
    }
  }
  const HashAlgorithmIDs = {
    SHA2_256: 1,
    SHA2_384: 2,
    SHA3_256: 3,
    SHA3_384: 4,
    KMAC128_BLS_BLS12_381: 5
  };
  const SignatureAlgorithmIDs = {
    ECDSA_P256: 1,
    ECDSA_secp256k1: 2,
    BLS_BLS12_381: 3
  };
  async function sendGetAccountAtBlockHeightRequest(ix, context, opts) {
    const httpRequest$1 = opts.httpRequest || httpRequest;
    const res = await httpRequest$1({
      hostname: opts.node,
      path: `/v1/accounts/${ix.account.addr}?block_height=${ix.block.height}&expand=contracts,keys`,
      method: "GET",
      body: null
    });
    return constructResponse$3(ix, context, res);
  }
  async function sendGetAccountAtLatestBlockRequest(ix, context, opts) {
    const httpRequest$1 = opts.httpRequest || httpRequest;
    const res = await httpRequest$1({
      hostname: opts.node,
      path: `/v1/accounts/${ix.account.addr}?block_height=sealed&expand=contracts,keys`,
      method: "GET",
      body: null
    });
    return constructResponse$3(ix, context, res);
  }
  function constructResponse$3(ix, context, res) {
    let ret = context.response();
    ret.tag = ix.tag;
    const unwrapContracts = contracts => {
      const c = {};
      if (!contracts) return c;
      for (let key of Object.keys(contracts)) {
        c[key] = context.Buffer.from(contracts[key], "base64").toString();
      }
      return c;
    };
    ret.account = {
      address: res.address,
      balance: Number(res.balance),
      code: "",
      contracts: unwrapContracts(res.contracts),
      keys: res.keys?.map(key => ({
        index: Number(key.index),
        publicKey: key.public_key.replace(/^0x/, ""),
        signAlgo: SignatureAlgorithmIDs[key.signing_algorithm],
        signAlgoString: key.signing_algorithm,
        hashAlgo: HashAlgorithmIDs[key.hashing_algorithm],
        hashAlgoString: key.hashing_algorithm,
        sequenceNumber: Number(key.sequence_number),
        weight: Number(key.weight),
        revoked: key.revoked
      })) ?? []
    };
    return ret;
  }
  async function sendGetAccount(ix) {
    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    utilInvariant.invariant(opts.node, `SDK Send Get Account Error: opts.node must be defined.`);
    utilInvariant.invariant(context.response, `SDK Send Get Account Error: context.response must be defined.`);
    utilInvariant.invariant(context.Buffer, `SDK Send Get Account Error: context.Buffer must be defined.`);
    ix = await ix;
    if (ix.block.height !== null) {
      return await sendGetAccountAtBlockHeightRequest(ix, context, opts);
    } else {
      return await sendGetAccountAtLatestBlockRequest(ix, context, opts);
    }
  }
  async function sendGetBlockHeaderByIDRequest(ix, context, opts) {
    const httpRequest$1 = opts.httpRequest || httpRequest;
    const res = await httpRequest$1({
      hostname: opts.node,
      path: `/v1/blocks/${ix.block.id}`,
      method: "GET",
      body: null
    });
    return constructResponse$2(ix, context, res);
  }
  async function sendGetBlockHeaderByHeightRequest(ix, context, opts) {
    const httpRequest$1 = opts.httpRequest || httpRequest;
    const res = await httpRequest$1({
      hostname: opts.node,
      path: `/v1/blocks?height=${ix.block.height}`,
      method: "GET",
      body: null
    });
    return constructResponse$2(ix, context, res);
  }
  async function sendGetLatestBlockHeaderRequest(ix, context, opts) {
    const httpRequest$1 = opts.httpRequest || httpRequest;
    const height = ix.block?.isSealed ? "sealed" : "final";
    const res = await httpRequest$1({
      hostname: opts.node,
      path: `/v1/blocks?height=${height}`,
      method: "GET",
      body: null
    });
    return constructResponse$2(ix, context, res);
  }
  function constructResponse$2(ix, context, res) {
    const block = res.length ? res[0] : null;
    const ret = context.response();
    ret.tag = ix.tag;
    ret.blockHeader = {
      id: block.header.id,
      parentId: block.header.parent_id,
      height: Number(block.header.height),
      timestamp: block.header.timestamp
    };
    return ret;
  }
  async function sendGetBlockHeader(ix) {
    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    utilInvariant.invariant(opts.node, `SDK Send Get Block Header Error: opts.node must be defined.`);
    utilInvariant.invariant(context.response, `SDK Send Get Block Header Error: context.response must be defined.`);
    ix = await ix;
    const interactionHasBlockID = ix.block.id !== null;
    const interactionHasBlockHeight = ix.block.height !== null;
    if (interactionHasBlockID) {
      return await sendGetBlockHeaderByIDRequest(ix, context, opts);
    } else if (interactionHasBlockHeight) {
      return await sendGetBlockHeaderByHeightRequest(ix, context, opts);
    } else {
      return await sendGetLatestBlockHeaderRequest(ix, context, opts);
    }
  }
  async function sendGetBlockByIDRequest(ix, context, opts) {
    const httpRequest$1 = opts.httpRequest || httpRequest;
    const res = await httpRequest$1({
      hostname: opts.node,
      path: `/v1/blocks/${ix.block.id}?expand=payload`,
      method: "GET",
      body: null
    });
    return constructResponse$1(ix, context, res);
  }
  async function sendGetBlockByHeightRequest(ix, context, opts) {
    const httpRequest$1 = opts.httpRequest || httpRequest;
    const res = await httpRequest$1({
      hostname: opts.node,
      path: `/v1/blocks?height=${ix.block.height}&expand=payload`,
      method: "GET",
      body: null
    });
    return constructResponse$1(ix, context, res);
  }
  async function sendGetBlockRequest(ix, context, opts) {
    const httpRequest$1 = opts.httpRequest || httpRequest;
    const height = ix.block?.isSealed ? "sealed" : "final";
    const res = await httpRequest$1({
      hostname: opts.node,
      path: `/v1/blocks?height=${height}&expand=payload`,
      method: "GET",
      body: null
    });
    return constructResponse$1(ix, context, res);
  }
  function constructResponse$1(ix, context, res) {
    const block = res.length ? res[0] : null;
    const ret = context.response();
    ret.tag = ix.tag;
    ret.block = {
      id: block.header.id,
      parentId: block.header.parent_id,
      height: Number(block.header.height),
      timestamp: block.header.timestamp,
      collectionGuarantees: block.payload.collection_guarantees.map(collectionGuarantee => ({
        collectionId: collectionGuarantee.collection_id,
        signerIds: collectionGuarantee.signer_ids
      })),
      blockSeals: block.payload.block_seals.map(blockSeal => ({
        blockId: blockSeal.block_id,
        executionReceiptId: blockSeal.result_id
      }))
    };
    return ret;
  }
  async function sendGetBlock(ix) {
    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    utilInvariant.invariant(opts.node, `SDK Send Get Block Error: opts.node must be defined.`);
    utilInvariant.invariant(context.response, `SDK Send Get Block Error: context.response must be defined.`);
    ix = await ix;
    const interactionHasBlockID = ix.block.id !== null;
    const interactionHasBlockHeight = ix.block.height !== null;
    if (interactionHasBlockID) {
      return await sendGetBlockByIDRequest(ix, context, opts);
    } else if (interactionHasBlockHeight) {
      return await sendGetBlockByHeightRequest(ix, context, opts);
    } else {
      return await sendGetBlockRequest(ix, context, opts);
    }
  }
  async function sendGetCollection(ix) {
    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    utilInvariant.invariant(opts.node, `SDK Send Get Collection Error: opts.node must be defined.`);
    utilInvariant.invariant(context.response, `SDK Send Get Collection Error: context.response must be defined.`);
    const httpRequest$1 = opts.httpRequest || httpRequest;
    const res = await httpRequest$1({
      hostname: opts.node,
      path: `/v1/collections/${ix.collection.id}?expand=transactions`,
      method: "GET",
      body: null
    });
    const ret = context.response();
    ret.tag = ix.tag;
    ret.collection = {
      id: res.id,
      transactionIds: res.transactions.map(transaction => transaction.id)
    };
    return ret;
  }
  async function sendGetEventsForHeightRangeRequest(ix, context, opts) {
    const httpRequest$1 = opts.httpRequest || httpRequest;
    const res = await httpRequest$1({
      hostname: opts.node,
      path: `/v1/events?type=${ix.events.eventType}&start_height=${ix.events.start}&end_height=${ix.events.end}`,
      method: "GET",
      body: null
    });
    return constructResponse(ix, context, res);
  }
  async function sendGetEventsForBlockIDsRequest(ix, context, opts) {
    const httpRequest$1 = opts.httpRequest || httpRequest;
    const res = await httpRequest$1({
      hostname: opts.node,
      path: `/v1/events?type=${ix.events.eventType}&block_ids=${ix.events.blockIds.join(",")}`,
      method: "GET",
      body: null
    });
    return constructResponse(ix, context, res);
  }
  function constructResponse(ix, context, res) {
    let ret = context.response();
    ret.tag = ix.tag;
    ret.events = [];
    res.forEach(block => block.events ? block.events.forEach(event => ret.events.push({
      blockId: block.block_id,
      blockHeight: Number(block.block_height),
      blockTimestamp: block.block_timestamp,
      type: event.type,
      transactionId: event.transaction_id,
      transactionIndex: Number(event.transaction_index),
      eventIndex: Number(event.event_index),
      payload: JSON.parse(context.Buffer.from(event.payload, "base64").toString())
    })) : null);
    return ret;
  }
  async function sendGetEvents(ix) {
    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    utilInvariant.invariant(opts.node, `SDK Send Get Events Error: opts.node must be defined.`);
    utilInvariant.invariant(context.response, `SDK Send Get Events Error: context.response must be defined.`);
    utilInvariant.invariant(context.Buffer, `SDK Send Get Events Error: context.Buffer must be defined.`);
    ix = await ix;
    const interactionContainsBlockHeightRange = ix.events.start !== null;
    const interactionContainsBlockIDsList = Array.isArray(ix.events.blockIds) && ix.events.blockIds.length > 0;
    utilInvariant.invariant(interactionContainsBlockHeightRange || interactionContainsBlockIDsList, "SendGetEventsError: Unable to determine which get events request to send. Either a block height range, or block IDs must be specified.");
    if (interactionContainsBlockHeightRange) {
      return await sendGetEventsForHeightRangeRequest(ix, context, opts);
    } else {
      return await sendGetEventsForBlockIDsRequest(ix, context, opts);
    }
  }
  async function sendGetTransaction(ix) {
    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    utilInvariant.invariant(opts.node, `SDK Send Get Transaction Error: opts.node must be defined.`);
    utilInvariant.invariant(context.response, `SDK Send Get Transaction Error: context.response must be defined.`);
    utilInvariant.invariant(context.Buffer, `SDK Send Get Transaction Error: context.Buffer must be defined.`);
    const httpRequest$1 = opts.httpRequest || httpRequest;
    ix = await ix;
    const res = await httpRequest$1({
      hostname: opts.node,
      path: `/v1/transactions/${ix.transaction.id}`,
      method: "GET",
      body: null
    });
    const unwrapKey = key => ({
      address: key.address,
      keyId: Number(key.key_id),
      sequenceNumber: Number(key.sequence_number)
    });
    const unwrapSignature = sig => ({
      address: sig.address,
      keyId: Number(sig.key_index),
      signature: sig.signature
    });
    const unwrapArg = arg => JSON.parse(context.Buffer.from(arg, "base64").toString());
    let ret = context.response();
    ret.tag = ix.tag;
    ret.transaction = {
      script: context.Buffer.from(res.script, "base64").toString(),
      args: [...res.arguments.map(unwrapArg)],
      referenceBlockId: res.reference_block_id,
      gasLimit: Number(res.gas_limit),
      payer: res.payer,
      proposalKey: res.proposal_key ? unwrapKey(res.proposal_key) : res.proposal_key,
      authorizers: res.authorizers,
      payloadSignatures: [...res.payload_signatures.map(unwrapSignature)],
      envelopeSignatures: [...res.envelope_signatures.map(unwrapSignature)]
    };
    return ret;
  }
  const STATUS_MAP = {
    UNKNOWN: 0,
    PENDING: 1,
    FINALIZED: 2,
    EXECUTED: 3,
    SEALED: 4,
    EXPIRED: 5
  };
  async function sendGetTransactionStatus(ix) {
    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    utilInvariant.invariant(opts.node, `SDK Send Get Transaction Status Error: opts.node must be defined.`);
    utilInvariant.invariant(context.response, `SDK Send Get Transaction Status Error: context.response must be defined.`);
    utilInvariant.invariant(context.Buffer, `SDK Send Get Transaction Status Error: context.Buffer must be defined.`);
    const httpRequest$1 = opts.httpRequest || httpRequest;
    ix = await ix;
    const res = await httpRequest$1({
      hostname: opts.node,
      path: `/v1/transaction_results/${ix.transaction.id}`,
      method: "GET",
      body: null
    });
    let ret = context.response();
    ret.tag = ix.tag;
    ret.transactionStatus = {
      blockId: res.block_id,
      status: STATUS_MAP[res.status.toUpperCase()] || "",
      statusString: res.status.toUpperCase(),
      statusCode: res.status_code,
      errorMessage: res.error_message,
      events: res.events.map(event => ({
        type: event.type,
        transactionId: event.transaction_id,
        transactionIndex: Number(event.transaction_index),
        eventIndex: Number(event.event_index),
        payload: JSON.parse(context.Buffer.from(event.payload, "base64").toString())
      }))
    };
    return ret;
  }
  async function sendPing(ix) {
    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    utilInvariant.invariant(opts.node, `SDK Send Ping Error: opts.node must be defined.`);
    utilInvariant.invariant(context.response, `SDK Send Ping Error: context.response must be defined.`);
    const httpRequest$1 = opts.httpRequest || httpRequest;
    await httpRequest$1({
      hostname: opts.node,
      path: "/v1/blocks?height=sealed",
      method: "GET",
      body: null
    });
    let ret = context.response();
    ret.tag = ix.tag;
    return ret;
  }
  const idof$2 = acct => `${withPrefix(acct.addr)}-${acct.keyId}`;
  async function sendTransaction(ix) {
    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    utilInvariant.invariant(opts.node, `SDK Send Transaction Error: opts.node must be defined.`);
    utilInvariant.invariant(context.response, `SDK Send Transaction Error: context.response must be defined.`);
    utilInvariant.invariant(context.Buffer, `SDK Send Transaction Error: context.Buffer must be defined.`);
    const httpRequest$1 = opts.httpRequest || httpRequest;
    ix = await ix;

    // Apply Non Payer Signatures to Payload Signatures
    let payloadSignatures = [];
    for (let acct of Object.values(ix.accounts)) {
      try {
        if (!acct.role.payer && acct.signature != null) {
          const signature = {
            address: utilAddress.sansPrefix(acct.addr),
            key_index: String(acct.keyId),
            signature: context.Buffer.from(acct.signature, "hex").toString("base64")
          };
          if (!payloadSignatures.find(existingSignature => existingSignature.address === signature.address && existingSignature.key_index === signature.key_index && existingSignature.signature === signature.signature)) {
            payloadSignatures.push(signature);
          }
        }
      } catch (error) {
        console.error("SDK HTTP Send Error: Trouble applying payload signature", {
          acct,
          ix
        });
        throw error;
      }
    }

    // Apply Payer Signatures to Envelope Signatures
    let envelopeSignatures = {};
    for (let acct of Object.values(ix.accounts)) {
      try {
        if (acct.role.payer && acct.signature != null) {
          let id = acct.tempId || idof$2(acct);
          envelopeSignatures[id] = envelopeSignatures[id] || {
            address: utilAddress.sansPrefix(acct.addr),
            key_index: String(acct.keyId),
            signature: context.Buffer.from(acct.signature, "hex").toString("base64")
          };
        }
      } catch (error) {
        console.error("SDK HTTP Send Error: Trouble applying envelope signature", {
          acct,
          ix
        });
        throw error;
      }
    }
    envelopeSignatures = Object.values(envelopeSignatures);
    var t1 = Date.now();
    const res = await httpRequest$1({
      hostname: opts.node,
      path: `/v1/transactions`,
      method: "POST",
      body: {
        script: context.Buffer.from(ix.message.cadence).toString("base64"),
        arguments: [...ix.message.arguments.map(arg => context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString("base64"))],
        reference_block_id: ix.message.refBlock ? ix.message.refBlock : null,
        gas_limit: String(ix.message.computeLimit),
        payer: utilAddress.sansPrefix(ix.accounts[Array.isArray(ix.payer) ? ix.payer[0] : ix.payer].addr),
        proposal_key: {
          address: utilAddress.sansPrefix(ix.accounts[ix.proposer].addr),
          key_index: String(ix.accounts[ix.proposer].keyId),
          sequence_number: String(ix.accounts[ix.proposer].sequenceNum)
        },
        authorizers: ix.authorizations.map(tempId => ix.accounts[tempId].addr).reduce((prev, current) => {
          return prev.find(item => item === current) ? prev : [...prev, current];
        }, []).map(utilAddress.sansPrefix),
        payload_signatures: payloadSignatures,
        envelope_signatures: envelopeSignatures
      }
    });
    var t2 = Date.now();
    let ret = context.response();
    ret.tag = ix.tag;
    ret.transactionId = res.id;
    if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") {
      window.dispatchEvent(new CustomEvent("FLOW::TX", {
        detail: {
          txId: ret.transactionId,
          delta: t2 - t1
        }
      }));
    }
    return ret;
  }
  async function sendGetNetworkParameters(ix) {
    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    utilInvariant.invariant(opts.node, `SDK Send Get Network Parameters Error: opts.node must be defined.`);
    utilInvariant.invariant(context.response, `SDK Send Get Network Parameters Error: context.response must be defined.`);
    const httpRequest$1 = opts.httpRequest || httpRequest;
    ix = await ix;
    const res = await httpRequest$1({
      hostname: opts.node,
      path: `/v1/network/parameters`,
      method: "GET",
      body: null,
      enableRequestLogging: opts.enableRequestLogging ?? true
    });
    let ret = context.response();
    ret.tag = ix.tag;
    ret.networkParameters = {
      chainId: res.chain_id
    };
    return ret;
  }
  const send$1 = async function (ix) {
    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    utilInvariant.invariant(opts.node, `SDK Send Error: Either opts.node or "accessNode.api" in config must be defined.`);
    utilInvariant.invariant(context.ix, `SDK Send Error: context.ix must be defined.`);
    ix = await ix;

    // prettier-ignore
    switch (true) {
      case context.ix.isTransaction(ix):
        return opts.sendTransaction ? opts.sendTransaction(ix, context, opts) : sendTransaction(ix, context, opts);
      case context.ix.isGetTransactionStatus(ix):
        return opts.sendGetTransactionStatus ? opts.sendGetTransactionStatus(ix, context, opts) : sendGetTransactionStatus(ix, context, opts);
      case context.ix.isGetTransaction(ix):
        return opts.sendGetTransaction ? opts.sendGetTransaction(ix, context, opts) : sendGetTransaction(ix, context, opts);
      case context.ix.isScript(ix):
        return opts.sendExecuteScript ? opts.sendExecuteScript(ix, context, opts) : sendExecuteScript(ix, context, opts);
      case context.ix.isGetAccount(ix):
        return opts.sendGetAccount ? opts.sendGetAccount(ix, context, opts) : sendGetAccount(ix, context, opts);
      case context.ix.isGetEvents(ix):
        return opts.sendGetEvents ? opts.sendGetEvents(ix, context, opts) : sendGetEvents(ix, context, opts);
      case context.ix.isGetBlock(ix):
        return opts.sendGetBlock ? opts.sendGetBlock(ix, context, opts) : sendGetBlock(ix, context, opts);
      case context.ix.isGetBlockHeader(ix):
        return opts.sendGetBlockHeader ? opts.sendGetBlockHeader(ix, context, opts) : sendGetBlockHeader(ix, context, opts);
      case context.ix.isGetCollection(ix):
        return opts.sendGetCollection ? opts.sendGetCollection(ix, context, opts) : sendGetCollection(ix, context, opts);
      case context.ix.isPing(ix):
        return opts.sendPing ? opts.sendPing(ix, context, opts) : sendPing(ix, context, opts);
      case context.ix.isGetNetworkParameters(ix):
        return opts.sendGetNetworkParameters ? opts.sendGetNetworkParameters(ix, context, opts) : sendGetNetworkParameters(ix, context, opts);
      default:
        return ix;
    }
  };
  var send_1 = sdkSendHttp.send = send$1;
  sdkSendHttp.sendExecuteScript = sendExecuteScript;
  sdkSendHttp.sendGetAccount = sendGetAccount;
  sdkSendHttp.sendGetBlock = sendGetBlock;
  sdkSendHttp.sendGetBlockHeader = sendGetBlockHeader;
  sdkSendHttp.sendGetCollection = sendGetCollection;
  sdkSendHttp.sendGetEvents = sendGetEvents;
  sdkSendHttp.sendGetNetworkParameters = sendGetNetworkParameters;
  sdkSendHttp.sendGetTransaction = sendGetTransaction;
  sdkSendHttp.sendGetTransactionStatus = sendGetTransactionStatus;
  sdkSendHttp.sendPing = sendPing;
  sdkSendHttp.sendTransaction = sendTransaction;

  const DEFAULT_RESPONSE = `{
    "tag":null,
    "transaction":null,
    "transactionStatus":null,
    "transactionId":null,
    "encodedData":null,
    "events":null,
    "account":null,
    "block":null,
    "blockHeader":null,
    "latestBlock":null,
    "collection":null,
    "networkParameters":null
}`;
  const response = () => JSON.parse(DEFAULT_RESPONSE);

  /**
   * @description - A builder function that returns the interaction to get the latest block
   * @param {boolean} [isSealed] - Whether or not the block should be sealed
   * @returns {Function} - An interaction object
   */
  function getBlock() {
    let isSealed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    return pipe([makeGetBlock, ix => {
      ix.block.isSealed = isSealed;
      return Ok(ix);
    }]);
  }

  /**
   * @description - A builder function that returns the interaction to get an account by address
   * @param {string} addr - The address of the account to getq
   * @returns {Function} - An interaction object
   */
  function getAccount(addr) {
    return pipe([makeGetAccount, ix => {
      ix.account.addr = require$$4.sansPrefix(addr);
      return Ok(ix);
    }]);
  }

  const latestBlockDeprecationNotice = () => {
    logger$1.log.deprecate({
      pkg: "@onflow/decode",
      subject: "Operating upon data of the latestBlock field of the response object",
      transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/decode/WARNINGS.md#0001-Deprecating-latestBlock-field"
    });
  };
  const decodeImplicit = async i => i;
  const decodeVoid = async () => null;
  const decodeType = async type => {
    return type.staticType;
  };
  const decodePath = async path => {
    return {
      domain: path.domain,
      identifier: path.identifier
    };
  };
  const decodeCapability = async cap => {
    return {
      path: cap.path,
      address: cap.address,
      borrowType: cap.borrowType
    };
  };
  const decodeOptional = async (optional, decoders, stack) => optional ? await recurseDecode(optional, decoders, stack) : null;
  const decodeReference = async v => ({
    address: v.address,
    type: v.type
  });
  const decodeArray = async (array, decoders, stack) => await Promise.all(array.map(v => new Promise(async res => res(await recurseDecode(v, decoders, [...stack, v.type])))));
  const decodeDictionary = async (dictionary, decoders, stack) => await dictionary.reduce(async (acc, v) => {
    acc = await acc;
    acc[await recurseDecode(v.key, decoders, [...stack, v.key])] = await recurseDecode(v.value, decoders, [...stack, v.key]);
    return acc;
  }, Promise.resolve({}));
  const decodeComposite = async (composite, decoders, stack) => {
    const decoded = await composite.fields.reduce(async (acc, v) => {
      acc = await acc;
      acc[v.name] = await recurseDecode(v.value, decoders, [...stack, v.name]);
      return acc;
    }, Promise.resolve({}));
    const decoder = composite.id && decoderLookup(decoders, composite.id);
    return decoder ? await decoder(decoded) : decoded;
  };
  const defaultDecoders = {
    UInt: decodeImplicit,
    Int: decodeImplicit,
    UInt8: decodeImplicit,
    Int8: decodeImplicit,
    UInt16: decodeImplicit,
    Int16: decodeImplicit,
    UInt32: decodeImplicit,
    Int32: decodeImplicit,
    UInt64: decodeImplicit,
    Int64: decodeImplicit,
    UInt128: decodeImplicit,
    Int128: decodeImplicit,
    UInt256: decodeImplicit,
    Int256: decodeImplicit,
    Word8: decodeImplicit,
    Word16: decodeImplicit,
    Word32: decodeImplicit,
    Word64: decodeImplicit,
    UFix64: decodeImplicit,
    Fix64: decodeImplicit,
    String: decodeImplicit,
    Character: decodeImplicit,
    Bool: decodeImplicit,
    Address: decodeImplicit,
    Void: decodeVoid,
    Optional: decodeOptional,
    Reference: decodeReference,
    Array: decodeArray,
    Dictionary: decodeDictionary,
    Event: decodeComposite,
    Resource: decodeComposite,
    Struct: decodeComposite,
    Enum: decodeComposite,
    Type: decodeType,
    Path: decodePath,
    Capability: decodeCapability
  };
  const decoderLookup = (decoders, lookup) => {
    const found = Object.keys(decoders).find(decoder => {
      if (/^\/.*\/$/.test(decoder)) {
        const reg = new RegExp(decoder.substring(1, decoder.length - 1));
        return reg.test(lookup);
      }
      return decoder === lookup;
    });
    return lookup && found && decoders[found];
  };
  const recurseDecode = async (decodeInstructions, decoders, stack) => {
    let decoder = decoderLookup(decoders, decodeInstructions.type);
    if (!decoder) throw new Error(`Undefined Decoder Error: ${decodeInstructions.type}@${stack.join(".")}`);
    return await decoder(decodeInstructions.value, decoders, stack);
  };

  /**
   * @description - Decodes a response from Flow into JSON
   * @param {*} decodeInstructions - The response object from Flow
   * @param {object} customDecoders - An object of custom decoders
   * @param {Array<*>} stack - The stack of the current decoding
   * @returns {Promise<*>} - The decoded response
   */
  const decode$1 = async function (decodeInstructions) {
    let customDecoders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let stack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    // Filter out all default decoders which are overridden by a custom decoder regex
    const filteredDecoders = Object.keys(defaultDecoders).filter(decoder => !Object.keys(customDecoders).find(customDecoder => new RegExp(customDecoder).test(decoder))).reduce((decoders, decoderKey) => {
      decoders[decoderKey] = defaultDecoders[decoderKey];
      return decoders;
    }, customDecoders);
    const decoders = {
      ...filteredDecoders,
      ...customDecoders
    };
    return recurseDecode(decodeInstructions, decoders, stack);
  };
  const decodeResponse = async function (response) {
    let customDecoders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (response.encodedData) {
      return decode$1(response.encodedData, customDecoders);
    } else if (response.transactionStatus) {
      return {
        ...response.transactionStatus,
        events: await Promise.all(response.transactionStatus.events.map(async function decodeEvents(e) {
          return {
            type: e.type,
            transactionId: e.transactionId,
            transactionIndex: e.transactionIndex,
            eventIndex: e.eventIndex,
            data: await decode$1(e.payload, customDecoders)
          };
        }))
      };
    } else if (response.transaction) {
      return response.transaction;
    } else if (response.events) {
      return await Promise.all(response.events.map(async function decodeEvents(e) {
        return {
          blockId: e.blockId,
          blockHeight: e.blockHeight,
          blockTimestamp: e.blockTimestamp,
          type: e.type,
          transactionId: e.transactionId,
          transactionIndex: e.transactionIndex,
          eventIndex: e.eventIndex,
          data: await decode$1(e.payload, customDecoders)
        };
      }));
    } else if (response.account) {
      return response.account;
    } else if (response.block) {
      return response.block;
    } else if (response.blockHeader) {
      return response.blockHeader;
    } else if (response.latestBlock) {
      latestBlockDeprecationNotice();
      return response.latestBlock;
    } else if (response.transactionId) {
      return response.transactionId;
    } else if (response.collection) {
      return response.collection;
    } else if (response.networkParameters) {
      const chainIdMap = {
        "flow-testnet": "testnet",
        "flow-mainnet": "mainnet",
        "flow-emulator": "local"
      };
      return {
        chainId: chainIdMap[response.networkParameters.chainId]
      };
    }
    return null;
  };

  const isFn$2 = v => typeof v === "function";
  const isString$1 = v => typeof v === "string";
  const oldIdentifierPatternFn = () => /\b(0x\w+)\b/g;
  function isOldIdentifierSyntax(cadence) {
    return oldIdentifierPatternFn().test(cadence);
  }
  const newIdentifierPatternFn = () => /import\s+"(\w+)"/g;
  function isNewIdentifierSyntax(cadence) {
    return newIdentifierPatternFn().test(cadence);
  }
  function getContractIdentifierSyntaxMatches(cadence) {
    return cadence.matchAll(newIdentifierPatternFn());
  }
  async function resolveCadence(ix) {
    if (!isTransaction(ix) && !isScript(ix)) return ix;
    var cadence = get(ix, "ix.cadence");
    require$$0$1.invariant(isFn$2(cadence) || isString$1(cadence), "Cadence needs to be a function or a string.");
    if (isFn$2(cadence)) cadence = await cadence({});
    require$$0$1.invariant(isString$1(cadence), "Cadence needs to be a string at this point.");
    require$$0$1.invariant(!isOldIdentifierSyntax(cadence) || !isNewIdentifierSyntax(cadence), "Both account identifier and contract identifier syntax not simultaneously supported.");
    if (isOldIdentifierSyntax(cadence)) {
      cadence = await config.config().where(/^0x/).then(d => Object.entries(d).reduce((cadence, _ref) => {
        let [key, value] = _ref;
        const regex = new RegExp("(\\b" + key + "\\b)", "g");
        return cadence.replace(regex, value);
      }, cadence));
    }
    if (isNewIdentifierSyntax(cadence)) {
      for (const [fullMatch, contractName] of getContractIdentifierSyntaxMatches(cadence)) {
        const address = await config.config().get(`system.contracts.${contractName}`);
        if (address) {
          cadence = cadence.replace(fullMatch, `import ${contractName} from ${require$$4.withPrefix(address)}`);
        } else {
          logger__namespace$1.log({
            title: "Contract Placeholder not found",
            message: `Cannot find a value for contract placeholder ${contractName}. Please add to your flow.json or explicitly add it to the config 'contracts.*' namespace.`,
            level: logger__namespace$1.LEVELS.warn
          });
        }
      }
    }

    // We need to move this over in any case.
    ix.message.cadence = cadence;
    return ix;
  }

  const isFn$1 = v => typeof v === "function";
  function cast(arg) {
    // prettier-ignore
    require$$0$1.invariant(typeof arg.xform != null, `No type specified for argument: ${arg.value}`);
    if (isFn$1(arg.xform)) return arg.xform(arg.value);
    if (isFn$1(arg.xform.asArgument)) return arg.xform.asArgument(arg.value);

    // prettier-ignore
    require$$0$1.invariant(false, `Invalid Argument`, arg);
  }
  async function handleArgResolution(arg) {
    let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
    require$$0$1.invariant(depth > 0, `Argument Resolve Recursion Limit Exceeded for Arg: ${arg.tempId}`);
    if (isFn$1(arg.resolveArgument)) {
      const resolvedArg = await arg.resolveArgument();
      return handleArgResolution(resolvedArg, depth - 1);
    } else {
      return arg;
    }
  }
  async function resolveArguments(ix) {
    if (isTransaction(ix) || isScript(ix)) {
      for (let [id, arg] of Object.entries(ix.arguments)) {
        const res = await handleArgResolution(arg);
        ix.arguments[id].asArgument = cast(res);
      }
    }
    return ix;
  }

  const encodeTransactionPayload = tx => prependTransactionDomainTag(rlpEncode(preparePayload(tx)));
  const encodeTransactionEnvelope = tx => prependTransactionDomainTag(rlpEncode(prepareEnvelope(tx)));
  const encodeTxIdFromVoucher = voucher => sha3_256(rlpEncode(prepareVoucher(voucher)));
  const rightPaddedHexBuffer = (value, pad) => rlp.Buffer.from(value.padEnd(pad * 2, 0), "hex");
  const leftPaddedHexBuffer = (value, pad) => rlp.Buffer.from(value.padStart(pad * 2, 0), "hex");
  const TRANSACTION_DOMAIN_TAG = rightPaddedHexBuffer(rlp.Buffer.from("FLOW-V0.0-transaction").toString("hex"), 32).toString("hex");
  const prependTransactionDomainTag = tx => TRANSACTION_DOMAIN_TAG + tx;
  const addressBuffer = addr => leftPaddedHexBuffer(addr, 8);
  const blockBuffer = block => leftPaddedHexBuffer(block, 32);
  const argumentToString = arg => rlp.Buffer.from(JSON.stringify(arg), "utf8");
  const scriptBuffer = script => rlp.Buffer.from(script, "utf8");
  const signatureBuffer = signature => rlp.Buffer.from(signature, "hex");
  const rlpEncode = v => {
    return rlp.encode(v).toString("hex");
  };
  const sha3_256 = msg => {
    const sha = new sha3.SHA3(256);
    sha.update(rlp.Buffer.from(msg, "hex"));
    return sha.digest().toString("hex");
  };
  const preparePayload = tx => {
    validatePayload(tx);
    return [scriptBuffer(tx.cadence), tx.arguments.map(argumentToString), blockBuffer(tx.refBlock), tx.computeLimit, addressBuffer(require$$4.sansPrefix(tx.proposalKey.address)), tx.proposalKey.keyId, tx.proposalKey.sequenceNum, addressBuffer(require$$4.sansPrefix(tx.payer)), tx.authorizers.map(authorizer => addressBuffer(require$$4.sansPrefix(authorizer)))];
  };
  const prepareEnvelope = tx => {
    validateEnvelope(tx);
    return [preparePayload(tx), preparePayloadSignatures(tx)];
  };
  const preparePayloadSignatures = tx => {
    const signers = collectSigners(tx);
    return tx.payloadSigs.map(sig => {
      return {
        signerIndex: signers.get(sig.address),
        keyId: sig.keyId,
        sig: sig.sig
      };
    }).sort((a, b) => {
      if (a.signerIndex > b.signerIndex) return 1;
      if (a.signerIndex < b.signerIndex) return -1;
      if (a.keyId > b.keyId) return 1;
      if (a.keyId < b.keyId) return -1;
    }).map(sig => {
      return [sig.signerIndex, sig.keyId, signatureBuffer(sig.sig)];
    });
  };
  const collectSigners = tx => {
    const signers = new Map();
    let i = 0;
    const addSigner = addr => {
      if (!signers.has(addr)) {
        signers.set(addr, i);
        i++;
      }
    };
    addSigner(tx.proposalKey.address);
    addSigner(tx.payer);
    tx.authorizers.forEach(addSigner);
    return signers;
  };
  const prepareVoucher = voucher => {
    validateVoucher(voucher);
    const signers = collectSigners(voucher);
    const prepareSigs = sigs => {
      return sigs.map(_ref => {
        let {
          address,
          keyId,
          sig
        } = _ref;
        return {
          signerIndex: signers.get(address),
          keyId,
          sig
        };
      }).sort((a, b) => {
        if (a.signerIndex > b.signerIndex) return 1;
        if (a.signerIndex < b.signerIndex) return -1;
        if (a.keyId > b.keyId) return 1;
        if (a.keyId < b.keyId) return -1;
      }).map(sig => {
        return [sig.signerIndex, sig.keyId, signatureBuffer(sig.sig)];
      });
    };
    return [[scriptBuffer(voucher.cadence), voucher.arguments.map(argumentToString), blockBuffer(voucher.refBlock), voucher.computeLimit, addressBuffer(require$$4.sansPrefix(voucher.proposalKey.address)), voucher.proposalKey.keyId, voucher.proposalKey.sequenceNum, addressBuffer(require$$4.sansPrefix(voucher.payer)), voucher.authorizers.map(authorizer => addressBuffer(require$$4.sansPrefix(authorizer)))], prepareSigs(voucher.payloadSigs), prepareSigs(voucher.envelopeSigs)];
  };
  const validatePayload = tx => {
    payloadFields.forEach(field => checkField(tx, field));
    proposalKeyFields.forEach(field => checkField(tx.proposalKey, field, "proposalKey"));
  };
  const validateEnvelope = tx => {
    payloadSigsFields.forEach(field => checkField(tx, field));
    tx.payloadSigs.forEach((sig, index) => {
      payloadSigFields.forEach(field => checkField(sig, field, "payloadSigs", index));
    });
  };
  const validateVoucher = voucher => {
    payloadFields.forEach(field => checkField(voucher, field));
    proposalKeyFields.forEach(field => checkField(voucher.proposalKey, field, "proposalKey"));
    payloadSigsFields.forEach(field => checkField(voucher, field));
    voucher.payloadSigs.forEach((sig, index) => {
      payloadSigFields.forEach(field => checkField(sig, field, "payloadSigs", index));
    });
    envelopeSigsFields.forEach(field => checkField(voucher, field));
    voucher.envelopeSigs.forEach((sig, index) => {
      envelopeSigFields.forEach(field => checkField(sig, field, "envelopeSigs", index));
    });
  };
  const isNumber = v => typeof v === "number";
  const isString = v => typeof v === "string";
  const isObject = v => v !== null && typeof v === "object";
  const isArray = v => isObject(v) && v instanceof Array;
  const payloadFields = [{
    name: "cadence",
    check: isString
  }, {
    name: "arguments",
    check: isArray
  }, {
    name: "refBlock",
    check: isString,
    defaultVal: "0"
  }, {
    name: "computeLimit",
    check: isNumber
  }, {
    name: "proposalKey",
    check: isObject
  }, {
    name: "payer",
    check: isString
  }, {
    name: "authorizers",
    check: isArray
  }];
  const proposalKeyFields = [{
    name: "address",
    check: isString
  }, {
    name: "keyId",
    check: isNumber
  }, {
    name: "sequenceNum",
    check: isNumber
  }];
  const payloadSigsFields = [{
    name: "payloadSigs",
    check: isArray
  }];
  const payloadSigFields = [{
    name: "address",
    check: isString
  }, {
    name: "keyId",
    check: isNumber
  }, {
    name: "sig",
    check: isString
  }];
  const envelopeSigsFields = [{
    name: "envelopeSigs",
    check: isArray
  }];
  const envelopeSigFields = [{
    name: "address",
    check: isString
  }, {
    name: "keyId",
    check: isNumber
  }, {
    name: "sig",
    check: isString
  }];
  const checkField = (obj, field, base, index) => {
    const {
      name,
      check,
      defaultVal
    } = field;
    if (obj[name] == null && defaultVal != null) obj[name] = defaultVal;
    if (obj[name] == null) throw missingFieldError(name, base, index);
    if (!check(obj[name])) throw invalidFieldError(name, base, index);
  };
  const printFieldName = (field, base, index) => {
    if (!!base) return index == null ? `${base}.${field}` : `${base}.${index}.${field}`;
    return field;
  };
  const missingFieldError = (field, base, index) => new Error(`Missing field ${printFieldName(field, base, index)}`);
  const invalidFieldError = (field, base, index) => new Error(`Invalid field ${printFieldName(field, base, index)}`);

  function findInsideSigners(ix) {
    // Inside Signers Are: (authorizers + proposer) - payer
    let inside = new Set(ix.authorizations);
    inside.add(ix.proposer);
    if (Array.isArray(ix.payer)) {
      ix.payer.forEach(p => inside.delete(p));
    } else {
      inside.delete(ix.payer);
    }
    return Array.from(inside);
  }
  function findOutsideSigners(ix) {
    // Outside Signers Are: (payer)
    let outside = new Set(Array.isArray(ix.payer) ? ix.payer : [ix.payer]);
    return Array.from(outside);
  }
  const createSignableVoucher = ix => {
    const buildAuthorizers = () => {
      const authorizations = ix.authorizations.map(cid => require$$4.withPrefix(ix.accounts[cid].addr)).reduce((prev, current) => {
        return prev.find(item => item === current) ? prev : [...prev, current];
      }, []);
      return authorizations[0] ? authorizations : [];
    };
    const buildInsideSigners = () => findInsideSigners(ix).map(id => ({
      address: require$$4.withPrefix(ix.accounts[id].addr),
      keyId: ix.accounts[id].keyId,
      sig: ix.accounts[id].signature
    }));
    const buildOutsideSigners = () => findOutsideSigners(ix).map(id => ({
      address: require$$4.withPrefix(ix.accounts[id].addr),
      keyId: ix.accounts[id].keyId,
      sig: ix.accounts[id].signature
    }));
    return {
      cadence: ix.message.cadence,
      refBlock: ix.message.refBlock || null,
      computeLimit: ix.message.computeLimit,
      arguments: ix.message.arguments.map(id => ix.arguments[id].asArgument),
      proposalKey: {
        address: require$$4.withPrefix(ix.accounts[ix.proposer].addr),
        keyId: ix.accounts[ix.proposer].keyId,
        sequenceNum: ix.accounts[ix.proposer].sequenceNum
      },
      payer: require$$4.withPrefix(ix.accounts[Array.isArray(ix.payer) ? ix.payer[0] : ix.payer].addr),
      authorizers: buildAuthorizers(),
      payloadSigs: buildInsideSigners(),
      envelopeSigs: buildOutsideSigners()
    };
  };
  const voucherToTxId = voucher => {
    return encodeTxIdFromVoucher(voucher);
  };

  const MAX_DEPTH_LIMIT = 5;
  const idof$1 = acct => `${require$$4.withPrefix(acct.addr)}-${acct.keyId}`;
  const isFn = v => v && (Object.prototype.toString.call(v) === "[object Function]" || "function" === typeof v || v instanceof Function);
  const genAccountId = function () {
    for (var _len = arguments.length, ids = new Array(_len), _key = 0; _key < _len; _key++) {
      ids[_key] = arguments[_key];
    }
    return ids.join("-");
  };
  const ROLES = {
    PAYER: "payer",
    PROPOSER: "proposer",
    AUTHORIZATIONS: "authorizations"
  };
  function debug$1() {
    const SPACE = " ";
    const SPACE_COUNT_PER_INDENT = 4;
    const DEBUG_MESSAGE = [];
    return [function (msg) {
      let indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      DEBUG_MESSAGE.push(Array(indent * SPACE_COUNT_PER_INDENT).fill(SPACE).join("-") + msg);
    }, function () {
      return DEBUG_MESSAGE.reduce((prev, curr) => prev + "\n" + curr);
    }];
  }
  function recurseFlatMap(el) {
    let depthLimit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
    if (depthLimit <= 0) return el;
    if (!Array.isArray(el)) return el;
    return recurseFlatMap(el.flatMap(e => e), depthLimit - 1);
  }
  function buildPreSignable(acct, ix) {
    try {
      return {
        f_type: "PreSignable",
        f_vsn: "1.0.1",
        roles: acct.role,
        cadence: ix.message.cadence,
        args: ix.message.arguments.map(d => ix.arguments[d].asArgument),
        data: {},
        interaction: ix,
        voucher: createSignableVoucher(ix)
      };
    } catch (error) {
      console.error("buildPreSignable", error);
      throw error;
    }
  }
  async function removeUnusedIxAccounts(ix) {
    const payerTempIds = Array.isArray(ix.payer) ? ix.payer : [ix.payer];
    const authorizersTempIds = Array.isArray(ix.authorizations) ? ix.authorizations : [ix.authorizations];
    const proposerTempIds = Array.isArray(ix.proposer) ? ix.proposer : [ix.proposer];
    const ixAccountKeys = Object.keys(ix.accounts);
    const uniqueTempIds = [...new Set(payerTempIds.concat(authorizersTempIds, proposerTempIds))];
    for (const ixAccountKey of ixAccountKeys) {
      if (!uniqueTempIds.find(id => id === ixAccountKey)) {
        delete ix.accounts[ixAccountKey];
      }
    }
  }
  function addAccountToIx(ix, newAccount) {
    if (typeof newAccount.addr === "string" && (typeof newAccount.keyId === "number" || typeof newAccount.keyId === "string")) {
      newAccount.tempId = idof$1(newAccount);
    } else {
      newAccount.tempId = newAccount.tempId || dist.v4();
    }
    const existingAccount = ix.accounts[newAccount.tempId] || newAccount;
    if (!ix.accounts[newAccount.tempId]) {
      ix.accounts[newAccount.tempId] = newAccount;
    }
    ix.accounts[newAccount.tempId].role.proposer = existingAccount.role.proposer || newAccount.role.proposer;
    ix.accounts[newAccount.tempId].role.payer = existingAccount.role.payer || newAccount.role.payer;
    ix.accounts[newAccount.tempId].role.authorizer = existingAccount.role.authorizer || newAccount.role.authorizer;
    return ix.accounts[newAccount.tempId];
  }
  function uniqueAccountsFlatMap(accounts) {
    const flatMapped = recurseFlatMap(accounts);
    const seen = new Set();
    const uniqueAccountsFlatMapped = flatMapped.map(account => {
      const accountId = genAccountId(account.tempId, account.role.payer, account.role.proposer, account.role.authorizer, account.role.param);
      if (seen.has(accountId)) return null;
      seen.add(accountId);
      return account;
    }).filter(e => e !== null);
    return uniqueAccountsFlatMapped;
  }
  async function recurseResolveAccount(ix, currentAccountTempId) {
    let depthLimit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : MAX_DEPTH_LIMIT;
    let {
      debugLogger
    } = arguments.length > 3 ? arguments[3] : undefined;
    if (depthLimit <= 0) {
      throw new Error(`recurseResolveAccount Error: Depth limit (${MAX_DEPTH_LIMIT}) reached. Ensure your authorization functions resolve to an account after ${MAX_DEPTH_LIMIT} resolves.`);
    }
    let account = ix.accounts[currentAccountTempId];
    if (!account) return null;
    debugLogger(`account: ${account.tempId}`, Math.max(MAX_DEPTH_LIMIT - depthLimit, 0));
    if (account?.resolve) {
      if (isFn(account?.resolve)) {
        debugLogger(`account: ${account.tempId} -- cache MISS`, Math.max(MAX_DEPTH_LIMIT - depthLimit, 0));
        const {
          resolve,
          ...accountWithoutResolve
        } = account;
        let resolvedAccounts = await resolve(accountWithoutResolve, buildPreSignable(accountWithoutResolve, ix));
        resolvedAccounts = Array.isArray(resolvedAccounts) ? resolvedAccounts : [resolvedAccounts];
        let flatResolvedAccounts = recurseFlatMap(resolvedAccounts);
        flatResolvedAccounts = flatResolvedAccounts.map(flatResolvedAccount => addAccountToIx(ix, flatResolvedAccount));
        account.resolve = flatResolvedAccounts.map(flatResolvedAccount => flatResolvedAccount.tempId);
        account = addAccountToIx(ix, account);
        const recursedAccounts = await Promise.all(flatResolvedAccounts.map(async resolvedAccount => {
          return await recurseResolveAccount(ix, resolvedAccount.tempId, depthLimit - 1, {
            debugLogger
          });
        }));
        return recursedAccounts ? recurseFlatMap(recursedAccounts) : account.tempId;
      } else {
        debugLogger(`account: ${account.tempId} -- cache HIT`, Math.max(MAX_DEPTH_LIMIT - depthLimit, 0));
        return account.resolve;
      }
    }
    return account.tempId;
  }
  async function resolveAccountType(ix, type, _ref) {
    let {
      debugLogger
    } = _ref;
    require$$0$1.invariant(ix && typeof ix === "object", "resolveAccountType Error: ix not defined");
    require$$0$1.invariant(type === ROLES.PAYER || type === ROLES.PROPOSER || type === ROLES.AUTHORIZATIONS, "resolveAccountType Error: type must be 'payer', 'proposer' or 'authorizations'");
    let accountTempIDs = Array.isArray(ix[type]) ? ix[type] : [ix[type]];
    let allResolvedAccounts = [];
    for (let accountId of accountTempIDs) {
      let account = ix.accounts[accountId];
      require$$0$1.invariant(account, `resolveAccountType Error: account not found`);
      let resolvedAccountTempIds = await recurseResolveAccount(ix, accountId, MAX_DEPTH_LIMIT, {
        debugLogger
      });
      resolvedAccountTempIds = Array.isArray(resolvedAccountTempIds) ? resolvedAccountTempIds : [resolvedAccountTempIds];
      let resolvedAccounts = resolvedAccountTempIds.map(resolvedAccountTempId => ix.accounts[resolvedAccountTempId]);
      let flatResolvedAccounts = uniqueAccountsFlatMap(resolvedAccounts);
      allResolvedAccounts = allResolvedAccounts.concat(flatResolvedAccounts);
    }
    require$$0$1.invariant(allResolvedAccounts.length > 0, "resolveAccountType Error: failed to resolve any accounts");
    if (type === ROLES.PAYER) {
      allResolvedAccounts = allResolvedAccounts.filter(acct => acct.role.payer === true);
    }
    if (type === ROLES.PROPOSER) {
      allResolvedAccounts = allResolvedAccounts.filter(acct => acct.role.proposer === true);
    }
    if (type === ROLES.AUTHORIZATIONS) {
      allResolvedAccounts = allResolvedAccounts.filter(acct => acct.role.authorizer === true);
    }
    ix[type] = Array.isArray(ix[type]) ? [...new Set(allResolvedAccounts.map(acct => acct.tempId))] : allResolvedAccounts[0].tempId;

    // Ensure all payers are of the same account
    if (type === ROLES.PAYER) {
      let address;
      for (const payerTempID of ix[ROLES.PAYER]) {
        let pAcct = ix.accounts[payerTempID];
        if (!address) address = pAcct.addr;else if (address !== pAcct.addr) {
          throw new Error("resolveAccountType Error: payers from different accounts detected");
        }
      }
    }
  }
  async function resolveAccounts(ix) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (isTransaction(ix)) {
      if (!Array.isArray(ix.payer)) {
        logger$1.log.deprecate({
          pkg: "FCL",
          subject: '"ix.payer" must be an array. Support for ix.payer as a singular',
          message: "See changelog for more info."
        });
      }
      let [debugLogger, getDebugMessage] = debug$1();
      try {
        await resolveAccountType(ix, ROLES.PROPOSER, {
          debugLogger
        });
        await resolveAccountType(ix, ROLES.AUTHORIZATIONS, {
          debugLogger
        });
        await resolveAccountType(ix, ROLES.PAYER, {
          debugLogger
        });
        await removeUnusedIxAccounts(ix, {
          debugLogger
        });
        if (opts.enableDebug) {
          console.debug(getDebugMessage());
        }
      } catch (error) {
        console.error("=== SAD PANDA ===\n\n", error, "\n\n=== SAD PANDA ===");
        throw error;
      }
    }
    return ix;
  }

  async function resolveSignatures(ix) {
    if (isTransaction(ix)) {
      try {
        let insideSigners = findInsideSigners(ix);
        const insidePayload = encodeTransactionPayload(prepForEncoding(ix));

        // Promise.all could potentially break the flow if there are multiple inside signers trying to resolve at the same time
        // causing multiple triggers of authz function that tries to render multiple auth iiframes/tabs/extensions
        // as an alternative, use this:
        // for(const insideSigner of insideSigners) {
        //   await fetchSignature(ix, insidePayload)(insideSigner);
        // }
        await Promise.all(insideSigners.map(fetchSignature(ix, insidePayload)));
        let outsideSigners = findOutsideSigners(ix);
        const outsidePayload = encodeTransactionEnvelope({
          ...prepForEncoding(ix),
          payloadSigs: insideSigners.map(id => ({
            address: ix.accounts[id].addr,
            keyId: ix.accounts[id].keyId,
            sig: ix.accounts[id].signature
          }))
        });

        // Promise.all could potentially break the flow if there are multiple outside signers trying to resolve at the same time
        // causing multiple triggers of authz function that tries to render multiple auth iframes/tabs/extensions
        // as an alternative, use this:
        // for(const outsideSigner of outsideSigners) {
        //   await fetchSignature(ix, outsidePayload)(outsideSigner);
        // }
        await Promise.all(outsideSigners.map(fetchSignature(ix, outsidePayload)));
      } catch (error) {
        console.error("Signatures", error, {
          ix
        });
        throw error;
      }
    }
    return ix;
  }
  function fetchSignature(ix, payload) {
    return async function innerFetchSignature(id) {
      const acct = ix.accounts[id];
      if (acct.signature != null && acct.signature !== undefined) return;
      const {
        signature
      } = await acct.signingFunction(buildSignable(acct, payload, ix));
      ix.accounts[id].signature = signature;
    };
  }
  function buildSignable(acct, message, ix) {
    try {
      return {
        f_type: "Signable",
        f_vsn: "1.0.1",
        message,
        addr: require$$4.sansPrefix(acct.addr),
        keyId: acct.keyId,
        roles: acct.role,
        cadence: ix.message.cadence,
        args: ix.message.arguments.map(d => ix.arguments[d].asArgument),
        data: {},
        interaction: ix,
        voucher: createSignableVoucher(ix)
      };
    } catch (error) {
      console.error("buildSignable", error);
      throw error;
    }
  }
  function prepForEncoding(ix) {
    const payerAddress = require$$4.sansPrefix((Array.isArray(ix.payer) ? ix.accounts[ix.payer[0]] : ix.accounts[ix.payer]).addr);
    return {
      cadence: ix.message.cadence,
      refBlock: ix.message.refBlock || null,
      computeLimit: ix.message.computeLimit,
      arguments: ix.message.arguments.map(id => ix.arguments[id].asArgument),
      proposalKey: {
        address: require$$4.sansPrefix(ix.accounts[ix.proposer].addr),
        keyId: ix.accounts[ix.proposer].keyId,
        sequenceNum: ix.accounts[ix.proposer].sequenceNum
      },
      payer: payerAddress,
      authorizers: ix.authorizations.map(cid => require$$4.sansPrefix(ix.accounts[cid].addr)).reduce((prev, current) => {
        return prev.find(item => item === current) ? prev : [...prev, current];
      }, [])
    };
  }

  async function resolveValidators(ix) {
    const validators = get(ix, "ix.validators", []);
    return pipe(ix, validators.map(cb => ix => cb(ix, {
      Ok,
      Bad
    })));
  }

  async function resolveFinalNormalization(ix) {
    for (let key of Object.keys(ix.accounts)) {
      ix.accounts[key].addr = require$$4.sansPrefix(ix.accounts[key].addr);
    }
    return ix;
  }

  async function resolveVoucherIntercept(ix) {
    const fn = get(ix, "ix.voucher-intercept");
    if (isFn$3(fn)) {
      await fn(createSignableVoucher(ix));
    }
    return ix;
  }

  const DEFAULT_COMPUTE_LIMIT = 100;
  async function resolveComputeLimit(ix) {
    if (isTransaction(ix)) {
      ix.message.computeLimit = ix.message.computeLimit || (await config.config.get("fcl.limit"));
      if (!ix.message.computeLimit) {
        logger__namespace$1.log.deprecate({
          pkg: "FCL/SDK",
          subject: "The built-in default compute limit (DEFAULT_COMPUTE_LIMIT=10)",
          transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0009-deprecate-default-compute-limit"
        });
        ix.message.computeLimit = DEFAULT_COMPUTE_LIMIT;
      }
    }
    return ix;
  }

  const noop = v => v;
  const debug = function (key) {
    let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
    return async ix => {
      const accts = ix => ["\nAccounts:", {
        proposer: ix.proposer,
        authorizations: ix.authorizations,
        payer: ix.payer
      }, "\n\nDetails:", ix.accounts].filter(Boolean);
      const log = function () {
        for (var _len = arguments.length, msg = new Array(_len), _key = 0; _key < _len; _key++) {
          msg[_key] = arguments[_key];
        }
        console.log(`debug[${key}] ---\n`, ...msg, "\n\n\n---");
      };
      if (await config.config.get(`debug.${key}`)) await fn(ix, log, accts);
      return ix;
    };
  };
  const resolve = pipe([resolveCadence, debug("cadence", (ix, log) => log(ix.message.cadence)), resolveComputeLimit, debug("compute limit", (ix, log) => log(ix.message.computeLimit)), resolveArguments, debug("arguments", (ix, log) => log(ix.message.arguments, ix.message)), resolveAccounts, debug("accounts", (ix, log, accts) => log(...accts(ix))), /* special */execFetchRef, /* special */execFetchSequenceNumber, resolveSignatures, debug("signatures", (ix, log, accts) => log(...accts(ix))), resolveFinalNormalization, resolveValidators, resolveVoucherIntercept, debug("resolved", (ix, log) => log(ix))]);
  async function execFetchRef(ix) {
    if (isTransaction(ix) && ix.message.refBlock == null) {
      const node = await config.config().get("accessNode.api");
      const sendFn = await config.config.first(["sdk.transport", "sdk.send"], send_1);
      require$$0$1.invariant(sendFn, `Required value for sdk.transport is not defined in config. See: ${"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"}`);
      ix.message.refBlock = (await sendFn(build([getBlock()]), {
        config: config.config,
        response,
        Buffer: rlp.Buffer,
        ix: ixModule
      }, {
        node
      }).then(decodeResponse)).id;
    }
    return ix;
  }
  async function execFetchSequenceNumber(ix) {
    if (isTransaction(ix)) {
      var acct = Object.values(ix.accounts).find(a => a.role.proposer);
      require$$0$1.invariant(acct, `Transactions require a proposer`);
      if (acct.sequenceNum == null) {
        const node = await config.config().get("accessNode.api");
        const sendFn = await config.config.first(["sdk.transport", "sdk.send"], send_1);
        require$$0$1.invariant(sendFn, `Required value for sdk.transport is not defined in config. See: ${"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"}`);
        ix.accounts[acct.tempId].sequenceNum = await sendFn(await build([getAccount(acct.addr)]), {
          config: config.config,
          response,
          Buffer: rlp.Buffer,
          ix: ixModule
        }, {
          node
        }).then(decodeResponse).then(acct => acct.keys).then(keys => keys.find(key => key.index === acct.keyId)).then(key => key.sequenceNumber);
      }
    }
    return ix;
  }

  function invariant() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length > 1) {
      const [predicate, message] = args;
      return invariant((ix, _ref) => {
        let {
          Ok,
          Bad
        } = _ref;
        return predicate ? Ok(ix) : Bad(ix, message);
      });
    }
    const [fn] = args;
    return ix => fn(ix, {
      Ok,
      Bad
    });
  }

  /**
   * @description - Sends arbitrary scripts, transactions, and requests to Flow
   * @param {Array.<Function>} args - An array of functions that take interaction and return interaction
   * @param {object} opts - Optional parameters
   * @returns {Promise<*>} - A promise that resolves to a response
   */
  const send = async function () {
    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const sendFn = await config.config.first(["sdk.transport", "sdk.send"], opts.send || send_1);
    invariant(sendFn, `Required value for sdk.transport is not defined in config. See: ${"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"}`);
    const resolveFn = await config.config.first(["sdk.resolve"], opts.resolve || resolve);
    opts.node = opts.node || (await config.config().get("accessNode.api"));
    if (Array.isArray(args)) args = pipe(interaction(), args);
    return sendFn(await resolveFn(args), {
      config: config.config,
      response,
      ix: ixModule,
      Buffer: rlp.Buffer
    }, opts);
  };

  async function decode(response) {
    const decodersFromConfig = await config.config().where(/^decoder\./);
    const decoders = Object.entries(decodersFromConfig).map(_ref => {
      let [pattern, xform] = _ref;
      pattern = `/${pattern.replace(/^decoder\./, "")}$/`;
      return [pattern, xform];
    });
    return decodeResponse(response, Object.fromEntries(decoders));
  }

  const findPayloadSigners = voucher => {
    // Payload Signers Are: (authorizers + proposer) - payer
    let payload = new Set(voucher.authorizers);
    payload.add(voucher.proposalKey.address);
    payload.delete(voucher.payer);
    return Array.from(payload).map(require$$4.withPrefix);
  };
  const findEnvelopeSigners = voucher => {
    // Envelope Signers Are: (payer)
    let envelope = new Set([voucher.payer]);
    return Array.from(envelope).map(require$$4.withPrefix);
  };
  class UnableToDetermineMessageEncodingTypeForSignerAddress extends Error {
    constructor(signerAddress) {
      const msg = `
        Encode Message From Signable Error: Unable to determine message encoding for signer addresss: ${signerAddress}. 
        Please ensure the address: ${signerAddress} is intended to sign the given transaction as specified by the transaction signable.
      `.trim();
      super(msg);
      this.name = "Unable To Determine Message Encoding For Signer Addresss";
    }
  }
  const encodeMessageFromSignable = (signable, signerAddress) => {
    let payloadSigners = findPayloadSigners(signable.voucher);
    let envelopeSigners = findEnvelopeSigners(signable.voucher);
    const isPayloadSigner = payloadSigners.includes(require$$4.withPrefix(signerAddress));
    const isEnvelopeSigner = envelopeSigners.includes(require$$4.withPrefix(signerAddress));
    if (!isPayloadSigner && !isEnvelopeSigner) {
      throw new UnableToDetermineMessageEncodingTypeForSignerAddress(signerAddress);
    }
    const message = {
      cadence: signable.voucher.cadence,
      refBlock: signable.voucher.refBlock,
      computeLimit: signable.voucher.computeLimit,
      arguments: signable.voucher.arguments,
      proposalKey: {
        ...signable.voucher.proposalKey,
        address: require$$4.sansPrefix(signable.voucher.proposalKey.address)
      },
      payer: require$$4.sansPrefix(signable.voucher.payer),
      authorizers: signable.voucher.authorizers.map(require$$4.sansPrefix),
      payloadSigs: signable.voucher.payloadSigs.map(ps => ({
        ...ps,
        address: require$$4.sansPrefix(ps.address)
      }))
    };
    return isPayloadSigner ? encodeTransactionPayload(message) : encodeTransactionEnvelope(message);
  };

  function validator(cb) {
    return update("ix.validators", validators => Array.isArray(validators) ? validators.push(cb) : [cb]);
  }

  /**
   * @description - A builder function that returns a partial interaction to a block at a specific height
   * @param {number} height - The height of the block to get
   * @returns {Function} - A partial interaction object
   */
  function atBlockHeight(height) {
    return pipe([ix => {
      ix.block.height = height;
      return ix;
    }, validator(ix => {
      if (typeof ix.block.isSealed === "boolean") throw new Error("Unable to specify both block height and isSealed.");
      if (ix.block.id) throw new Error("Unable to specify both block height and block id.");
      return ix;
    })]);
  }

  function atBlockId(id) {
    return pipe([ix => {
      ix.block.id = id;
      return Ok(ix);
    }, validator((ix, _ref) => {
      let {
        Ok,
        Bad
      } = _ref;
      if (isGetAccount(ix)) return Bad(ix, "Unable to specify a block id with a Get Account interaction.");
      if (typeof ix.block.isSealed === "boolean") return Bad(ix, "Unable to specify both block id and isSealed.");
      if (ix.block.height) return Bad(ix, "Unable to specify both block id and block height.");
      return Ok(ix);
    })]);
  }

  /**
   * @typedef {import("@onflow/typedefs").Account} Account
   */

  /**
   * @description  Returns the details of an account from their public address
   * @param {string} address - Address of the account
   * @param {object} [queryOptions] - Query parameters
   * @param {number} [queryOptions.height] - Block height to query
   * @param {string} [queryOptions.id] - Block ID to query
   * @param {object} [opts] - Optional parameters
   * @returns {Promise<Account>} - A promise that resolves to an account response
   */
  function account(address) {
    let {
      height,
      id
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let opts = arguments.length > 2 ? arguments[2] : undefined;
    require$$0$1.invariant(!(id && height), `Method: account -- Cannot pass "id" and "height" simultaneously`);

    // Get account by ID
    if (id) return send([getAccount(address), atBlockId(id)], opts).then(decodeResponse);

    // Get account by height
    if (height) return send([getAccount(address), atBlockHeight(height)], opts).then(decodeResponse);
    return send([getAccount(address)], opts).then(decodeResponse);
  }

  /**
   * @typedef {import("@onflow/typedefs").Block} Block
   */

  /**
   * @description Returns the latest block (optionally sealed or not), by id, or by height
   * @param {object} [queryOptions] - Query parameters
   * @param {boolean} [queryOptions.sealed=false] - Whether to query for a sealed block
   * @param {number} [queryOptions.height] - Block height to query
   * @param {string} [queryOptions.id] - Block ID to query
   * @param {object} [opts] - Optional parameters
   * @returns {Promise<Block>} - A promise that resolves to a block response
   */
  function block() {
    let {
      sealed = false,
      id,
      height
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    require$$0$1.invariant(!(sealed && id || sealed && height), `Method: block -- Cannot pass "sealed" with "id" or "height"`);
    require$$0$1.invariant(!(id && height), `Method: block -- Cannot pass "id" and "height" simultaneously`);

    // Get block by ID
    if (id) return send([getBlock(), atBlockId(id)], opts).then(decodeResponse);

    // Get block by height
    if (height) return send([getBlock(), atBlockHeight(height)], opts).then(decodeResponse);

    // Get latest block
    return send([getBlock(sealed)], opts).then(decodeResponse);
  }

  function authorizations() {
    let ax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return pipe(ax.map(authz => {
      return prepAccount(authz, {
        role: AUTHORIZER
      });
    }));
  }
  function authorization(addr, signingFunction, keyId, sequenceNum) {
    return {
      addr,
      signingFunction,
      keyId,
      sequenceNum
    };
  }

  function getEvents(eventType, start, end) {
    if (typeof start !== "undefined" || typeof end !== "undefined") {
      logger__namespace$1.log.deprecate({
        pkg: "FCL/SDK",
        subject: "Passing a start and end into getEvents",
        transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0005-deprecate-start-end-get-events-builder"
      });
    }
    return pipe([makeGetEvents, ix => {
      ix.events.eventType = eventType;
      ix.events.start = start;
      ix.events.end = end;
      return Ok(ix);
    }]);
  }

  /**
   * @description - A builder function that returns all instances of a particular event (by name) within a height range
   * NOTE:
   * - The block range provided must be from the current spork.
   * - The block range provided must be 250 blocks or lower per request.
   * @param {string} eventName - The name of the event to get
   * @param {number} fromBlockHeight - The height of the block to start looking for events (inclusive)
   * @param {number} toBlockHeight - The height of the block to stop looking for events (inclusive)
   * @returns {Function} - An interaction object
   */
  function getEventsAtBlockHeightRange(eventName, fromBlockHeight, toBlockHeight) {
    return pipe([makeGetEvents, ix => {
      ix.events.eventType = eventName;
      ix.events.start = fromBlockHeight;
      ix.events.end = toBlockHeight;
      return Ok(ix);
    }]);
  }

  /**
   * @description - A builder function that returns all instances of a particular event (by name) within a set of blocks, specified by block ids
   * NOTE:
   * - The block range provided must be from the current spork.
   * @param {string} eventName - The name of the event to get
   * @param {number[]} blockIds - The ids of the blocks to look for events
   * @returns {Function} - An interaction object
   */
  function getEventsAtBlockIds(eventName) {
    let blockIds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return pipe([makeGetEvents, ix => {
      ix.events.eventType = eventName;
      ix.events.blockIds = blockIds;
      return Ok(ix);
    }]);
  }

  /**
   * @description - A builder function that returns the interaction to get a block header
   * @param {boolean} [isSealed] - Whether or not the block should be sealed
   * @returns {Function} - An interaction object
   */
  function getBlockHeader() {
    let isSealed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    return pipe([makeGetBlockHeader, ix => {
      ix.block.isSealed = isSealed;
      return Ok(ix);
    }]);
  }

  /**
   * @description - A builder function that returns all a collection containing a list of transaction ids by its collection id
   * NOTE:
   * - The block range provided must be from the current spork. All events emitted during past sporks is current unavailable.
   * @param {string} [id] - The id of the collection to get
   * @returns {Function} - An interaction object
   */
  function getCollection() {
    let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    return pipe([makeGetCollection, ix => {
      ix.collection.id = id;
      return ix;
    }]);
  }

  /**
   * @description - A builder function that returns the status of transaction
   * NOTE: The transactionID provided must be from the current spork.
   * @param {string} transactionId - The id of the transaction to get status
   * @returns {Function} - An interaction object
   */
  function getTransactionStatus(transactionId) {
    return pipe([makeGetTransactionStatus, ix => {
      ix.transaction.id = transactionId;
      return Ok(ix);
    }]);
  }

  /**
   * @description - A builder function that returns a transaction
   * NOTE: The transactionID provided must be from the current spork.
   * @param {string} transactionId - The id of the transaction to get
   * @returns {Function} - An interaction object
   */
  function getTransaction(transactionId) {
    return pipe([makeGetTransaction, ix => {
      ix.transaction.id = transactionId;
      return Ok(ix);
    }]);
  }

  function getNetworkParameters() {
    return pipe([makeGetNetworkParameters, ix => {
      return Ok(ix);
    }]);
  }

  function limit(computeLimit) {
    return ix => {
      ix.message.computeLimit = computeLimit;
      return ix;
    };
  }

  /**
   * @description - A utility builder to be used with other builders to pass in arguments with a value and supported type
   * @param {Array.<*>} ax - An array of arguments
   * @returns {Function} - An interaction object
   */
  function args() {
    let ax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return pipe(ax.map(makeArgument));
  }

  /**
   * @description - A utility builder to be used with fcl.args[...] to create FCL supported arguments for interactions
   * @param {any} value - The value of the argument
   * @param {Function} xform - A function to transform the value
   * @returns {object} - An argument object
   */
  function arg(value, xform) {
    return {
      value,
      xform
    };
  }

  async function proposer(authz) {
    return prepAccount(authz, {
      role: PROPOSER
    });
  }

  function payer() {
    let ax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    if (!Array.isArray(ax)) ax = [ax];
    return pipe(ax.map(authz => {
      return prepAccount(authz, {
        role: PAYER
      });
    }));
  }

  function ping() {
    return makePing;
  }

  function ref(refBlock) {
    return pipe([ix => {
      ix.message.refBlock = refBlock;
      return Ok(ix);
    }]);
  }

  function script() {
    return pipe([makeScript, put("ix.cadence", utilTemplate.template(...arguments))]);
  }

  const DEFAULT_SCRIPT_ACCOUNTS = [];
  const DEFUALT_REF = null;

  /**
   * @description - A template builder to use a Cadence transaction for an interaction
   * @param {...*} args - The arguments to pass
   * @returns {Function} - An interaction object
   */
  function transaction() {
    return pipe([makeTransaction, put("ix.cadence", utilTemplate.template(...arguments)), ix => {
      ix.message.refBlock = ix.message.refBlock || DEFUALT_REF;
      ix.authorizations = ix.authorizations || DEFAULT_SCRIPT_ACCOUNTS;
      return Ok(ix);
    }]);
  }

  function voucherIntercept(fn) {
    return put("ix.voucher-intercept", fn);
  }

  const resolveProposerSequenceNumber = _ref => {
    let {
      node
    } = _ref;
    return async ix => {
      if (!isTransaction(ix)) return Ok(ix);
      if (ix.accounts[ix.proposer].sequenceNum) return Ok(ix);
      const sendFn = await config.config.first(["sdk.transport", "sdk.send"], send_1);
      require$$0$1.invariant(sendFn, `Required value for sdk.transport is not defined in config. See: ${"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"}`);
      const response$1 = await sendFn(await build([getAccount(ix.accounts[ix.proposer].addr)]), {
        config: config.config,
        response: response,
        Buffer: rlp.Buffer,
        ix: ixModule
      }, {
        node
      });
      const decoded = await decodeResponse(response$1);
      ix.accounts[ix.proposer].sequenceNum = decoded.keys[ix.accounts[ix.proposer].keyId].sequenceNumber;
      return Ok(ix);
    };
  };

  async function getRefId(opts) {
    const node = await config.config().get("accessNode.api");
    const sendFn = await config.config.first(["sdk.transport", "sdk.send"], send_1);
    require$$0$1.invariant(sendFn, `Required value for sdk.transport is not defined in config. See: ${"https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"}`);
    var ix;
    ix = await pipe(interaction(), [getBlock()]);
    ix = await sendFn(ix, {
      config: config.config,
      response,
      Buffer: rlp.Buffer,
      ix: ixModule
    }, {
      node
    });
    ix = await decodeResponse(ix);
    return ix.id;
  }
  function resolveRefBlockId(opts) {
    return async ix => {
      if (!isTransaction(ix)) return Ok(ix);
      if (ix.message.refBlock) return Ok(ix);
      ix.message.refBlock = await getRefId();
      return Ok(ix);
    };
  }

  function mockAccountResponse(ix) {
    let numberOfKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
    // prettier-ignore
    require$$0$1.invariant(ix.account, "mockAccountResponse(ix) -- ix.account is missing", ix);
    // prettier-ignore
    require$$0$1.invariant(ix.account.addr, "mockAccountResponse(ix) -- ix.account.addr is missing", ix);
    const address = ix.account.addr;
    return {
      account: {
        addr: address,
        keys: Array.from({
          length: numberOfKeys
        }, (_, i) => ({
          index: i,
          sequenceNumber: 42
        }))
      }
    };
  }
  function mockGetBlockResponse(ix) {
    return {
      tag: "GET_BLOCK",
      block: {
        id: "32"
      }
    };
  }
  const identity = v => v;
  function mockSend() {
    let fallback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;
    return async function execSend(ix) {
      ix = await ix;
      switch (true) {
        case isGetAccount(ix):
          return mockAccountResponse(ix);
        case isGetBlock(ix):
          return mockGetBlockResponse();
        default:
          return fallback(ix);
      }
    };
  }

  const idof = acct => `${require$$4.withPrefix(acct.addr)}-${acct.keyId}`;
  function sig(opts) {
    return ["SIGNATURE", opts.addr, opts.keyId].join(".");
  }
  function authzFn() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (account) {
      const acct = {
        ...account,
        ...opts,
        resolve: null,
        signingFunction: opts.signingFunction || account.signingFunction || fallbackSigningFunction
      };
      return acct;
      function fallbackSigningFunction(signable) {
        return {
          addr: acct.addr,
          keyId: acct.keyId,
          signature: sig(acct)
        };
      }
    };
  }
  function authzResolve() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (account) {
      const {
        tempId,
        ...rest
      } = opts;
      return {
        ...account,
        tempId: tempId || "WITH_RESOLVE",
        resolve: authzFn(rest)
      };
    };
  }
  const ROLE = {
    proposer: false,
    authorizer: false,
    payer: false
  };
  function authzResolveMany() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (account) {
      const tempId = opts.tempId || "AUTHZ_RESOLVE_MANY";
      return {
        ...account,
        tempId,
        resolve: () => [opts.proposer && authzFn(opts.proposer)({
          role: {
            ...ROLE,
            proposer: true
          }
        }), ...opts.authorizations.map(authzFn).map(d => d({
          role: {
            ...ROLE,
            authorizer: true
          }
        })), opts.payer && authzFn(opts.payer)({
          role: {
            ...ROLE,
            payer: true
          }
        })].filter(Boolean)
      };
    };
  }
  function authzDeepResolveMany() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return function (account) {
      const tempId = opts.tempId || "AUTHZ_DEEP_RESOLVE_MANY";
      return {
        ...account,
        tempId,
        resolve: depth > 0 ? authzDeepResolveMany(opts, depth - 1)(account).resolve : authzResolveMany(opts)(account).resolve
      };
    };
  }

  const run = function () {
    let fns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return build([ref("123"), ...fns]).then(resolve);
  };

  var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    mockSend: mockSend,
    authzFn: authzFn,
    authzResolve: authzResolve,
    authzResolveMany: authzResolveMany,
    authzDeepResolveMany: authzDeepResolveMany,
    sig: sig,
    idof: idof,
    run: run
  });

  const VERSION = "1.3.1" ;

  // Deprecated
  const params = params => logger__namespace$1.log.deprecate({
    pkg: "FCL/SDK",
    message: `The params builder has been removed from the Flow JS-SDK/FCL.`,
    transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params",
    level: logger__namespace$1.LEVELS.error
  });
  const param = params => logger__namespace$1.log.deprecate({
    pkg: "FCL/SDK",
    message: `The param builder has been removed from the Flow JS-SDK/FCL.`,
    transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params",
    level: logger__namespace$1.LEVELS.error
  });

  Object.defineProperty(exports, 'config', {
    enumerable: true,
    get: function () { return config.config; }
  });
  Object.defineProperty(exports, 'cadence', {
    enumerable: true,
    get: function () { return utilTemplate.template; }
  });
  Object.defineProperty(exports, 'cdc', {
    enumerable: true,
    get: function () { return utilTemplate.template; }
  });
  exports.TestUtils = index;
  exports.VERSION = VERSION;
  exports.account = account;
  exports.arg = arg;
  exports.args = args;
  exports.atBlockHeight = atBlockHeight;
  exports.atBlockId = atBlockId;
  exports.authorization = authorization;
  exports.authorizations = authorizations;
  exports.block = block;
  exports.build = build;
  exports.createSignableVoucher = createSignableVoucher;
  exports.decode = decode;
  exports.destroy = destroy;
  exports.encodeMessageFromSignable = encodeMessageFromSignable;
  exports.encodeTransactionEnvelope = encodeTransactionEnvelope;
  exports.encodeTransactionPayload = encodeTransactionPayload;
  exports.encodeTxIdFromVoucher = encodeTxIdFromVoucher;
  exports.get = get;
  exports.getAccount = getAccount;
  exports.getBlock = getBlock;
  exports.getBlockHeader = getBlockHeader;
  exports.getCollection = getCollection;
  exports.getEvents = getEvents;
  exports.getEventsAtBlockHeightRange = getEventsAtBlockHeightRange;
  exports.getEventsAtBlockIds = getEventsAtBlockIds;
  exports.getNetworkParameters = getNetworkParameters;
  exports.getTransaction = getTransaction;
  exports.getTransactionStatus = getTransactionStatus;
  exports.interaction = interaction;
  exports.invariant = invariant;
  exports.isBad = isBad;
  exports.isGetAccount = isGetAccount;
  exports.isGetBlock = isGetBlock;
  exports.isGetBlockHeader = isGetBlockHeader;
  exports.isGetCollection = isGetCollection;
  exports.isGetEvents = isGetEvents;
  exports.isGetNetworkParameters = isGetNetworkParameters;
  exports.isGetTransaction = isGetTransaction;
  exports.isGetTransactionStatus = isGetTransactionStatus;
  exports.isOk = isOk;
  exports.isPing = isPing;
  exports.isScript = isScript;
  exports.isTransaction = isTransaction;
  exports.isUnknown = isUnknown;
  exports.limit = limit;
  exports.param = param;
  exports.params = params;
  exports.payer = payer;
  exports.ping = ping;
  exports.pipe = pipe;
  exports.proposer = proposer;
  exports.put = put;
  exports.ref = ref;
  exports.resolve = resolve;
  exports.resolveAccounts = resolveAccounts;
  exports.resolveArguments = resolveArguments;
  exports.resolveCadence = resolveCadence;
  exports.resolveFinalNormalization = resolveFinalNormalization;
  exports.resolveProposerSequenceNumber = resolveProposerSequenceNumber;
  exports.resolveRefBlockId = resolveRefBlockId;
  exports.resolveSignatures = resolveSignatures;
  exports.resolveValidators = resolveValidators;
  exports.resolveVoucherIntercept = resolveVoucherIntercept;
  exports.response = response;
  exports.script = script;
  exports.send = send;
  exports.transaction = transaction;
  exports.update = update;
  exports.validator = validator;
  exports.voucherIntercept = voucherIntercept;
  exports.voucherToTxId = voucherToTxId;
  exports.why = why;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=sdk.umd.js.map
