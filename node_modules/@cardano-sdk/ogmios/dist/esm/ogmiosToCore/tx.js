import * as Crypto from '@cardano-sdk/crypto';
import { BYRON_TX_FEE_COEFFICIENT, BYRON_TX_FEE_CONSTANT, isAlonzoOrAbove, isExpiresAt, isMaryOrAbove, isNativeScript, isPlutusV1Script, isPlutusV2Script, isRequireAllOf, isRequireAnyOf, isRequireNOf, isShelleyTx, isStartsAt } from './util';
import { Base64Blob, HexBlob } from '@cardano-sdk/util';
import { Cardano, NotImplementedError, ProviderUtil, SerializationError, SerializationFailure, addressNetworkId, createRewardAccount } from '@cardano-sdk/core';
import Fraction from 'fraction.js';
import omit from 'lodash/omit';
const mapMargin = (margin) => {
    const { n: numerator, d: denominator } = new Fraction(margin);
    return { denominator, numerator };
};
const mapRelay = (relay) => {
    const port = relay.port || undefined;
    if ('hostname' in relay)
        return {
            __typename: 'RelayByName',
            hostname: relay.hostname,
            port
        };
    return {
        __typename: 'RelayByAddress',
        ipv4: relay.ipv4 || undefined,
        ipv6: relay.ipv6 || undefined,
        port
    };
};
const mapPoolParameters = (poolParameters) => {
    const rewardAccount = Cardano.RewardAccount(poolParameters.rewardAccount);
    return {
        ...omit(poolParameters, 'metadata'),
        id: Cardano.PoolId(poolParameters.id),
        margin: mapMargin(poolParameters.margin),
        metadataJson: poolParameters.metadata
            ? {
                hash: Crypto.Hash32ByteBase16(poolParameters.metadata.hash),
                url: poolParameters.metadata.url
            }
            : undefined,
        owners: poolParameters.owners.map((ownerKeyHash) => createRewardAccount(Crypto.Ed25519KeyHashHex(ownerKeyHash), addressNetworkId(rewardAccount))),
        relays: poolParameters.relays.map(mapRelay),
        rewardAccount,
        vrf: Cardano.VrfVkHex(poolParameters.vrf)
    };
};
const mapCertificate = (certificate) => {
    if ('stakeDelegation' in certificate) {
        return {
            __typename: Cardano.CertificateType.StakeDelegation,
            poolId: Cardano.PoolId(certificate.stakeDelegation.delegatee),
            stakeKeyHash: Crypto.Ed25519KeyHashHex(certificate.stakeDelegation.delegator)
        };
    }
    if ('stakeKeyRegistration' in certificate) {
        return {
            __typename: Cardano.CertificateType.StakeKeyRegistration,
            stakeKeyHash: Crypto.Ed25519KeyHashHex(certificate.stakeKeyRegistration)
        };
    }
    if ('stakeKeyDeregistration' in certificate) {
        return {
            __typename: Cardano.CertificateType.StakeKeyDeregistration,
            stakeKeyHash: Crypto.Ed25519KeyHashHex(certificate.stakeKeyDeregistration)
        };
    }
    if ('poolRegistration' in certificate) {
        return {
            __typename: Cardano.CertificateType.PoolRegistration,
            poolParameters: mapPoolParameters(certificate.poolRegistration)
        };
    }
    if ('poolRetirement' in certificate) {
        return {
            __typename: Cardano.CertificateType.PoolRetirement,
            epoch: Cardano.EpochNo(certificate.poolRetirement.retirementEpoch),
            poolId: Cardano.PoolId(certificate.poolRetirement.poolId)
        };
    }
    if ('genesisDelegation' in certificate) {
        return {
            __typename: Cardano.CertificateType.GenesisKeyDelegation,
            genesisDelegateHash: Crypto.Hash28ByteBase16(certificate.genesisDelegation.delegateKeyHash),
            genesisHash: Crypto.Hash28ByteBase16(certificate.genesisDelegation.verificationKeyHash),
            vrfKeyHash: Crypto.Hash32ByteBase16(certificate.genesisDelegation.vrfVerificationKeyHash)
        };
    }
    if ('moveInstantaneousRewards' in certificate) {
        return {
            __typename: Cardano.CertificateType.MIR,
            pot: certificate.moveInstantaneousRewards.pot === 'reserves'
                ? Cardano.MirCertificatePot.Reserves
                : Cardano.MirCertificatePot.Treasury,
            quantity: certificate.moveInstantaneousRewards.value || 0n
        };
    }
    throw new NotImplementedError('Unknown certificate mapping');
};
export const nativeScript = (script) => {
    let coreScript;
    if (typeof script === 'string') {
        coreScript = {
            __type: Cardano.ScriptType.Native,
            keyHash: Crypto.Ed25519KeyHashHex(script),
            kind: Cardano.NativeScriptKind.RequireSignature
        };
    }
    else if (isRequireAllOf(script)) {
        coreScript = {
            __type: Cardano.ScriptType.Native,
            kind: Cardano.NativeScriptKind.RequireAllOf,
            scripts: new Array()
        };
        for (let i = 0; i < script.all.length; ++i) {
            coreScript.scripts.push(nativeScript(script.all[i]));
        }
    }
    else if (isRequireAnyOf(script)) {
        coreScript = {
            __type: Cardano.ScriptType.Native,
            kind: Cardano.NativeScriptKind.RequireAnyOf,
            scripts: new Array()
        };
        for (let i = 0; i < script.any.length; ++i) {
            coreScript.scripts.push(nativeScript(script.any[i]));
        }
    }
    else if (isRequireNOf(script)) {
        const required = Number.parseInt(Object.keys(script)[0]);
        coreScript = {
            __type: Cardano.ScriptType.Native,
            kind: Cardano.NativeScriptKind.RequireNOf,
            required,
            scripts: new Array()
        };
        for (let i = 0; i < script[required].length; ++i) {
            coreScript.scripts.push(nativeScript(script[required][i]));
        }
    }
    else if (isExpiresAt(script)) {
        coreScript = {
            __type: Cardano.ScriptType.Native,
            kind: Cardano.NativeScriptKind.RequireTimeBefore,
            slot: Cardano.Slot(script.expiresAt)
        };
    }
    else if (isStartsAt(script)) {
        coreScript = {
            __type: Cardano.ScriptType.Native,
            kind: Cardano.NativeScriptKind.RequireTimeAfter,
            slot: Cardano.Slot(script.startsAt)
        };
    }
    else {
        throw new SerializationError(SerializationFailure.InvalidNativeScriptKind, `Native Script value '${script}' is not supported.`);
    }
    return coreScript;
};
const mapPlutusScript = (script) => {
    const version = isPlutusV1Script(script) ? Cardano.PlutusLanguageVersion.V1 : Cardano.PlutusLanguageVersion.V2;
    const plutusScript = isPlutusV1Script(script) ? script['plutus:v1'] : script['plutus:v2'];
    return {
        __type: Cardano.ScriptType.Plutus,
        bytes: HexBlob(plutusScript),
        version
    };
};
export const mapScript = (script) => {
    if (isNativeScript(script)) {
        return nativeScript(script.native);
    }
    else if (isPlutusV1Script(script) || isPlutusV2Script(script))
        return mapPlutusScript(script);
    throw new SerializationError(SerializationFailure.InvalidScriptType, `Script '${script}' is not supported.`);
};
const mapBootstrapWitness = (b) => ({
    addressAttributes: b.addressAttributes ? Base64Blob(b.addressAttributes) : undefined,
    chainCode: b.chainCode ? HexBlob(b.chainCode) : undefined,
    key: Crypto.Ed25519PublicKeyHex(b.key),
    signature: Crypto.Ed25519SignatureHex(HexBlob.fromBase64(b.signature))
});
const mapRedeemer = (key, redeemer) => {
    const purposeAndIndex = key.split(':');
    return {
        data: HexBlob(redeemer.redeemer),
        executionUnits: redeemer.executionUnits,
        index: Number(purposeAndIndex[1]),
        purpose: purposeAndIndex[0]
    };
};
const mapAuxiliaryData = (data) => {
    if (data === null)
        return undefined;
    return {
        body: {
            blob: data.body.blob
                ? new Map(Object.entries(data.body.blob).map(([key, value]) => [BigInt(key), ProviderUtil.jsonToMetadatum(value)]))
                : undefined,
            scripts: data.body.scripts ? data.body.scripts.map(mapScript) : undefined
        },
        hash: Crypto.Hash32ByteBase16(data.hash)
    };
};
const mapTxIn = (txIn) => ({
    index: txIn.index,
    txId: Cardano.TransactionId(txIn.txId)
});
const mapInlineDatum = (datum) => {
    if (typeof datum !== 'string')
        return;
    return HexBlob(datum);
};
const mapDatumHash = (datum) => {
    if (!datum)
        return;
    return Crypto.Hash32ByteBase16(datum);
};
const mapTxOut = (txOut) => ({
    address: Cardano.Address(txOut.address),
    datum: mapInlineDatum(txOut.datum),
    datumHash: mapDatumHash(txOut.datumHash),
    scriptReference: txOut.script ? mapScript(txOut.script) : undefined,
    value: {
        assets: txOut.value.assets
            ? new Map(Object.entries(txOut.value.assets).map(([key, value]) => [Cardano.AssetId(key), value]))
            : undefined,
        coins: txOut.value.coins
    }
});
const mapMint = (tx) => {
    if (tx.body.mint.assets === undefined)
        return undefined;
    return new Map(Object.entries(tx.body.mint.assets).map(([key, value]) => [Cardano.AssetId(key), value]));
};
const mapScriptIntegrityHash = ({ body: { scriptIntegrityHash } }) => {
    if (scriptIntegrityHash === null)
        return undefined;
    return Crypto.Hash32ByteBase16(scriptIntegrityHash);
};
const mapValidityInterval = ({ invalidBefore, invalidHereafter }) => ({
    invalidBefore: invalidBefore ? Cardano.Slot(invalidBefore) : undefined,
    invalidHereafter: invalidHereafter ? Cardano.Slot(invalidHereafter) : undefined
});
const mapCommonTx = (tx, kind) => ({
    auxiliaryData: mapAuxiliaryData(tx.metadata),
    body: {
        certificates: tx.body.certificates.map(mapCertificate),
        collaterals: isAlonzoOrAbove(kind) ? tx.body.collaterals.map(mapTxIn) : undefined,
        fee: tx.body.fee,
        inputs: tx.body.inputs.map(mapTxIn),
        mint: isMaryOrAbove(kind) ? mapMint(tx) : undefined,
        outputs: tx.body.outputs.map(mapTxOut),
        requiredExtraSignatures: isAlonzoOrAbove(kind)
            ? tx.body.requiredExtraSignatures.map(Crypto.Ed25519KeyHashHex)
            : undefined,
        scriptIntegrityHash: isAlonzoOrAbove(kind) ? mapScriptIntegrityHash(tx) : undefined,
        validityInterval: isShelleyTx(kind)
            ? undefined
            : mapValidityInterval(tx.body.validityInterval),
        withdrawals: Object.entries(tx.body.withdrawals).map(([key, value]) => ({
            quantity: value,
            stakeAddress: Cardano.RewardAccount(key)
        }))
    },
    id: Cardano.TransactionId(tx.id),
    witness: {
        bootstrap: tx.witness.bootstrap.map(mapBootstrapWitness),
        datums: isAlonzoOrAbove(kind)
            ? Object.values(tx.witness.datums).map((d) => HexBlob(d))
            : undefined,
        redeemers: isAlonzoOrAbove(kind)
            ? Object.entries(tx.witness.redeemers).map(([key, value]) => mapRedeemer(key, value))
            : undefined,
        scripts: [...Object.values(tx.witness.scripts).map(mapScript)],
        signatures: new Map(Object.entries(tx.witness.signatures).map(([key, value]) => [
            Crypto.Ed25519PublicKeyHex(key),
            Crypto.Ed25519SignatureHex(HexBlob.fromBase64(value))
        ]))
    }
});
export const mapCommonBlockBody = ({ body }, kind) => body.map((blockBody) => mapCommonTx(blockBody, kind));
export const mapByronTxFee = ({ raw }) => {
    const txSize = Buffer.from(Base64Blob(raw), 'base64').length;
    return BigInt(BYRON_TX_FEE_COEFFICIENT * txSize + BYRON_TX_FEE_CONSTANT);
};
const mapByronTx = (tx) => ({
    body: {
        fee: mapByronTxFee(tx),
        inputs: tx.body.inputs.map(mapTxIn),
        outputs: tx.body.outputs.map(mapTxOut)
    },
    id: Cardano.TransactionId(tx.id),
    witness: {
        signatures: new Map()
    }
});
export const mapByronBlockBody = ({ body }) => body.txPayload.map((txPayload) => mapByronTx(txPayload));
//# sourceMappingURL=tx.js.map