import { CardanoNodeErrors, ChainSyncEventType } from '@cardano-sdk/core';
import { safeJSON } from '@cardano-ogmios/client';
import { Observable, from, switchMap } from 'rxjs';
import { block as blockToCore } from '../../ogmiosToCore';
import { findIntersect, requestNext as sendRequestNext } from '@cardano-ogmios/client/dist/ChainSync';
import { nanoid } from 'nanoid';
import { ogmiosToCorePointOrOrigin, ogmiosToCoreTip, ogmiosToCoreTipOrOrigin, pointOrOriginToOgmios } from './util';
const RequestIdProp = 'requestId';
const notifySubscriberAndParseNewCursor = (response, subscriber, requestNext) => {
    if ('RollBackward' in response.result) {
        const point = ogmiosToCorePointOrOrigin(response.result.RollBackward.point);
        subscriber.next({
            eventType: ChainSyncEventType.RollBackward,
            point,
            requestNext,
            tip: ogmiosToCoreTipOrOrigin(response.result.RollBackward.tip)
        });
        return point;
    }
    else if ('RollForward' in response.result) {
        if (response.result.RollForward.tip === 'origin') {
            subscriber.error(new Error('Bug: "tip" at RollForward is "origin"'));
            return;
        }
        const coreBlock = blockToCore(response.result.RollForward.block);
        if (!coreBlock) {
            requestNext();
            return;
        }
        subscriber.next({
            block: coreBlock,
            eventType: ChainSyncEventType.RollForward,
            requestNext,
            tip: ogmiosToCoreTip(response.result.RollForward.tip)
        });
        return {
            hash: coreBlock.header.hash,
            slot: coreBlock.header.slot
        };
    }
    subscriber.error(new CardanoNodeErrors.CardanoClientErrors.UnknownResultError(response.result));
};
export const createObservableChainSyncClient = ({ intersectionPoint }, { interactionContext$ }) => {
    let cursor = intersectionPoint;
    return interactionContext$.pipe(switchMap((context) => from(findIntersect(context, [pointOrOriginToOgmios(cursor)]).then(() => context))), switchMap((context) => new Observable((subscriber) => {
        let requestId;
        const requestNext = () => {
            requestId = nanoid(5);
            sendRequestNext(context.socket, {
                mirror: {
                    [RequestIdProp]: requestId
                }
            });
        };
        const handler = (message) => {
            const response = safeJSON.parse(message);
            if (response.methodname === 'RequestNext') {
                if (response.reflection?.[RequestIdProp] !== requestId) {
                    return;
                }
                cursor = notifySubscriberAndParseNewCursor(response, subscriber, requestNext) || cursor;
            }
        };
        context.socket.on('message', handler);
        requestNext();
        return () => {
            context.socket.off('message', handler);
        };
    })));
};
//# sourceMappingURL=createObservableChainSyncClient.js.map