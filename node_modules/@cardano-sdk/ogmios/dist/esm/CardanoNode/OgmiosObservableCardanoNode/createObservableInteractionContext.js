import { CardanoNodeErrors } from '@cardano-sdk/core';
import { createInteractionContext } from '@cardano-ogmios/client';
import { Observable, switchMap } from 'rxjs';
import { retryBackoff } from 'backoff-rxjs';
import { contextLogger, isConnectionError } from '@cardano-sdk/util';
const defaultReconnectionConfig = { initialInterval: 10, maxInterval: 5000 };
export const createObservableInteractionContext = ({ connectionConfig$, interactionType, reconnectionConfig = defaultReconnectionConfig }, dependencies) => connectionConfig$.pipe(switchMap((connection) => new Observable((subscriber) => {
    const logger = contextLogger(dependencies.logger, 'InteractionContext');
    const interactionContextReady = createInteractionContext((error) => {
        logger.error(error.message);
        subscriber.error(error instanceof CardanoNodeErrors.CardanoClientErrors.ConnectionError
            ? error
            : new CardanoNodeErrors.UnknownCardanoNodeError(error));
    }, (code, reason) => {
        if (code === 1000) {
            logger.debug('Websocket closed with code 1000 (Normal Closure)');
            subscriber.complete();
        }
        else {
            const message = `Websocket unexpectedly closed with code ${code}: ${reason}`;
            logger.error(message);
            subscriber.error(new CardanoNodeErrors.CardanoClientErrors.ConnectionError());
        }
    }, {
        connection,
        interactionType
    })
        .then((interactionContext) => {
        logger.debug('Created');
        subscriber.next(interactionContext);
        return interactionContext;
    })
        .catch((error) => {
        logger.error('Failed to create', error);
        subscriber.error(isConnectionError(error)
            ? new CardanoNodeErrors.CardanoClientErrors.ConnectionError()
            : new CardanoNodeErrors.UnknownCardanoNodeError(error));
        return null;
    });
    return () => {
        void interactionContextReady
            .then((interactionContext) => {
            if (interactionContext &&
                interactionContext.socket.readyState !== interactionContext.socket.CLOSING &&
                interactionContext.socket.readyState !== interactionContext.socket.CLOSED) {
                interactionContext.socket.close();
            }
            return interactionContext;
        })
            .catch((error) => {
            logger.error('Failed to close', error);
        });
    };
})), retryBackoff({
    ...reconnectionConfig,
    shouldRetry: (error) => error instanceof CardanoNodeErrors.CardanoClientErrors.ConnectionError
}));
//# sourceMappingURL=createObservableInteractionContext.js.map