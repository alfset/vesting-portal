"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createObservableChainSyncClient = void 0;
const core_1 = require("@cardano-sdk/core");
const client_1 = require("@cardano-ogmios/client");
const rxjs_1 = require("rxjs");
const ogmiosToCore_1 = require("../../ogmiosToCore");
const ChainSync_1 = require("@cardano-ogmios/client/dist/ChainSync");
const nanoid_1 = require("nanoid");
const util_1 = require("./util");
const RequestIdProp = 'requestId';
const notifySubscriberAndParseNewCursor = (response, subscriber, requestNext) => {
    if ('RollBackward' in response.result) {
        const point = (0, util_1.ogmiosToCorePointOrOrigin)(response.result.RollBackward.point);
        subscriber.next({
            eventType: core_1.ChainSyncEventType.RollBackward,
            point,
            requestNext,
            tip: (0, util_1.ogmiosToCoreTipOrOrigin)(response.result.RollBackward.tip)
        });
        return point;
    }
    else if ('RollForward' in response.result) {
        if (response.result.RollForward.tip === 'origin') {
            subscriber.error(new Error('Bug: "tip" at RollForward is "origin"'));
            return;
        }
        const coreBlock = (0, ogmiosToCore_1.block)(response.result.RollForward.block);
        if (!coreBlock) {
            requestNext();
            return;
        }
        subscriber.next({
            block: coreBlock,
            eventType: core_1.ChainSyncEventType.RollForward,
            requestNext,
            tip: (0, util_1.ogmiosToCoreTip)(response.result.RollForward.tip)
        });
        return {
            hash: coreBlock.header.hash,
            slot: coreBlock.header.slot
        };
    }
    subscriber.error(new core_1.CardanoNodeErrors.CardanoClientErrors.UnknownResultError(response.result));
};
const createObservableChainSyncClient = ({ intersectionPoint }, { interactionContext$ }) => {
    let cursor = intersectionPoint;
    return interactionContext$.pipe((0, rxjs_1.switchMap)((context) => (0, rxjs_1.from)((0, ChainSync_1.findIntersect)(context, [(0, util_1.pointOrOriginToOgmios)(cursor)]).then(() => context))), (0, rxjs_1.switchMap)((context) => new rxjs_1.Observable((subscriber) => {
        let requestId;
        const requestNext = () => {
            requestId = (0, nanoid_1.nanoid)(5);
            (0, ChainSync_1.requestNext)(context.socket, {
                mirror: {
                    [RequestIdProp]: requestId
                }
            });
        };
        const handler = (message) => {
            const response = client_1.safeJSON.parse(message);
            if (response.methodname === 'RequestNext') {
                if (response.reflection?.[RequestIdProp] !== requestId) {
                    return;
                }
                cursor = notifySubscriberAndParseNewCursor(response, subscriber, requestNext) || cursor;
            }
        };
        context.socket.on('message', handler);
        requestNext();
        return () => {
            context.socket.off('message', handler);
        };
    })));
};
exports.createObservableChainSyncClient = createObservableChainSyncClient;
//# sourceMappingURL=createObservableChainSyncClient.js.map