"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createObservableInteractionContext = void 0;
const core_1 = require("@cardano-sdk/core");
const client_1 = require("@cardano-ogmios/client");
const rxjs_1 = require("rxjs");
const backoff_rxjs_1 = require("backoff-rxjs");
const util_1 = require("@cardano-sdk/util");
const defaultReconnectionConfig = { initialInterval: 10, maxInterval: 5000 };
const createObservableInteractionContext = ({ connectionConfig$, interactionType, reconnectionConfig = defaultReconnectionConfig }, dependencies) => connectionConfig$.pipe((0, rxjs_1.switchMap)((connection) => new rxjs_1.Observable((subscriber) => {
    const logger = (0, util_1.contextLogger)(dependencies.logger, 'InteractionContext');
    const interactionContextReady = (0, client_1.createInteractionContext)((error) => {
        logger.error(error.message);
        subscriber.error(error instanceof core_1.CardanoNodeErrors.CardanoClientErrors.ConnectionError
            ? error
            : new core_1.CardanoNodeErrors.UnknownCardanoNodeError(error));
    }, (code, reason) => {
        if (code === 1000) {
            logger.debug('Websocket closed with code 1000 (Normal Closure)');
            subscriber.complete();
        }
        else {
            const message = `Websocket unexpectedly closed with code ${code}: ${reason}`;
            logger.error(message);
            subscriber.error(new core_1.CardanoNodeErrors.CardanoClientErrors.ConnectionError());
        }
    }, {
        connection,
        interactionType
    })
        .then((interactionContext) => {
        logger.debug('Created');
        subscriber.next(interactionContext);
        return interactionContext;
    })
        .catch((error) => {
        logger.error('Failed to create', error);
        subscriber.error((0, util_1.isConnectionError)(error)
            ? new core_1.CardanoNodeErrors.CardanoClientErrors.ConnectionError()
            : new core_1.CardanoNodeErrors.UnknownCardanoNodeError(error));
        return null;
    });
    return () => {
        void interactionContextReady
            .then((interactionContext) => {
            if (interactionContext &&
                interactionContext.socket.readyState !== interactionContext.socket.CLOSING &&
                interactionContext.socket.readyState !== interactionContext.socket.CLOSED) {
                interactionContext.socket.close();
            }
            return interactionContext;
        })
            .catch((error) => {
            logger.error('Failed to close', error);
        });
    };
})), (0, backoff_rxjs_1.retryBackoff)({
    ...reconnectionConfig,
    shouldRetry: (error) => error instanceof core_1.CardanoNodeErrors.CardanoClientErrors.ConnectionError
}));
exports.createObservableInteractionContext = createObservableInteractionContext;
//# sourceMappingURL=createObservableInteractionContext.js.map