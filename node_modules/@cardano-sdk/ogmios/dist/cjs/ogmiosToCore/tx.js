"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapByronBlockBody = exports.mapByronTxFee = exports.mapCommonBlockBody = exports.mapScript = exports.nativeScript = void 0;
const Crypto = __importStar(require("@cardano-sdk/crypto"));
const util_1 = require("./util");
const util_2 = require("@cardano-sdk/util");
const core_1 = require("@cardano-sdk/core");
const fraction_js_1 = __importDefault(require("fraction.js"));
const omit_1 = __importDefault(require("lodash/omit"));
const mapMargin = (margin) => {
    const { n: numerator, d: denominator } = new fraction_js_1.default(margin);
    return { denominator, numerator };
};
const mapRelay = (relay) => {
    const port = relay.port || undefined;
    if ('hostname' in relay)
        return {
            __typename: 'RelayByName',
            hostname: relay.hostname,
            port
        };
    return {
        __typename: 'RelayByAddress',
        ipv4: relay.ipv4 || undefined,
        ipv6: relay.ipv6 || undefined,
        port
    };
};
const mapPoolParameters = (poolParameters) => {
    const rewardAccount = core_1.Cardano.RewardAccount(poolParameters.rewardAccount);
    return {
        ...(0, omit_1.default)(poolParameters, 'metadata'),
        id: core_1.Cardano.PoolId(poolParameters.id),
        margin: mapMargin(poolParameters.margin),
        metadataJson: poolParameters.metadata
            ? {
                hash: Crypto.Hash32ByteBase16(poolParameters.metadata.hash),
                url: poolParameters.metadata.url
            }
            : undefined,
        owners: poolParameters.owners.map((ownerKeyHash) => (0, core_1.createRewardAccount)(Crypto.Ed25519KeyHashHex(ownerKeyHash), (0, core_1.addressNetworkId)(rewardAccount))),
        relays: poolParameters.relays.map(mapRelay),
        rewardAccount,
        vrf: core_1.Cardano.VrfVkHex(poolParameters.vrf)
    };
};
const mapCertificate = (certificate) => {
    if ('stakeDelegation' in certificate) {
        return {
            __typename: core_1.Cardano.CertificateType.StakeDelegation,
            poolId: core_1.Cardano.PoolId(certificate.stakeDelegation.delegatee),
            stakeKeyHash: Crypto.Ed25519KeyHashHex(certificate.stakeDelegation.delegator)
        };
    }
    if ('stakeKeyRegistration' in certificate) {
        return {
            __typename: core_1.Cardano.CertificateType.StakeKeyRegistration,
            stakeKeyHash: Crypto.Ed25519KeyHashHex(certificate.stakeKeyRegistration)
        };
    }
    if ('stakeKeyDeregistration' in certificate) {
        return {
            __typename: core_1.Cardano.CertificateType.StakeKeyDeregistration,
            stakeKeyHash: Crypto.Ed25519KeyHashHex(certificate.stakeKeyDeregistration)
        };
    }
    if ('poolRegistration' in certificate) {
        return {
            __typename: core_1.Cardano.CertificateType.PoolRegistration,
            poolParameters: mapPoolParameters(certificate.poolRegistration)
        };
    }
    if ('poolRetirement' in certificate) {
        return {
            __typename: core_1.Cardano.CertificateType.PoolRetirement,
            epoch: core_1.Cardano.EpochNo(certificate.poolRetirement.retirementEpoch),
            poolId: core_1.Cardano.PoolId(certificate.poolRetirement.poolId)
        };
    }
    if ('genesisDelegation' in certificate) {
        return {
            __typename: core_1.Cardano.CertificateType.GenesisKeyDelegation,
            genesisDelegateHash: Crypto.Hash28ByteBase16(certificate.genesisDelegation.delegateKeyHash),
            genesisHash: Crypto.Hash28ByteBase16(certificate.genesisDelegation.verificationKeyHash),
            vrfKeyHash: Crypto.Hash32ByteBase16(certificate.genesisDelegation.vrfVerificationKeyHash)
        };
    }
    if ('moveInstantaneousRewards' in certificate) {
        return {
            __typename: core_1.Cardano.CertificateType.MIR,
            pot: certificate.moveInstantaneousRewards.pot === 'reserves'
                ? core_1.Cardano.MirCertificatePot.Reserves
                : core_1.Cardano.MirCertificatePot.Treasury,
            quantity: certificate.moveInstantaneousRewards.value || 0n
        };
    }
    throw new core_1.NotImplementedError('Unknown certificate mapping');
};
const nativeScript = (script) => {
    let coreScript;
    if (typeof script === 'string') {
        coreScript = {
            __type: core_1.Cardano.ScriptType.Native,
            keyHash: Crypto.Ed25519KeyHashHex(script),
            kind: core_1.Cardano.NativeScriptKind.RequireSignature
        };
    }
    else if ((0, util_1.isRequireAllOf)(script)) {
        coreScript = {
            __type: core_1.Cardano.ScriptType.Native,
            kind: core_1.Cardano.NativeScriptKind.RequireAllOf,
            scripts: new Array()
        };
        for (let i = 0; i < script.all.length; ++i) {
            coreScript.scripts.push((0, exports.nativeScript)(script.all[i]));
        }
    }
    else if ((0, util_1.isRequireAnyOf)(script)) {
        coreScript = {
            __type: core_1.Cardano.ScriptType.Native,
            kind: core_1.Cardano.NativeScriptKind.RequireAnyOf,
            scripts: new Array()
        };
        for (let i = 0; i < script.any.length; ++i) {
            coreScript.scripts.push((0, exports.nativeScript)(script.any[i]));
        }
    }
    else if ((0, util_1.isRequireNOf)(script)) {
        const required = Number.parseInt(Object.keys(script)[0]);
        coreScript = {
            __type: core_1.Cardano.ScriptType.Native,
            kind: core_1.Cardano.NativeScriptKind.RequireNOf,
            required,
            scripts: new Array()
        };
        for (let i = 0; i < script[required].length; ++i) {
            coreScript.scripts.push((0, exports.nativeScript)(script[required][i]));
        }
    }
    else if ((0, util_1.isExpiresAt)(script)) {
        coreScript = {
            __type: core_1.Cardano.ScriptType.Native,
            kind: core_1.Cardano.NativeScriptKind.RequireTimeBefore,
            slot: core_1.Cardano.Slot(script.expiresAt)
        };
    }
    else if ((0, util_1.isStartsAt)(script)) {
        coreScript = {
            __type: core_1.Cardano.ScriptType.Native,
            kind: core_1.Cardano.NativeScriptKind.RequireTimeAfter,
            slot: core_1.Cardano.Slot(script.startsAt)
        };
    }
    else {
        throw new core_1.SerializationError(core_1.SerializationFailure.InvalidNativeScriptKind, `Native Script value '${script}' is not supported.`);
    }
    return coreScript;
};
exports.nativeScript = nativeScript;
const mapPlutusScript = (script) => {
    const version = (0, util_1.isPlutusV1Script)(script) ? core_1.Cardano.PlutusLanguageVersion.V1 : core_1.Cardano.PlutusLanguageVersion.V2;
    const plutusScript = (0, util_1.isPlutusV1Script)(script) ? script['plutus:v1'] : script['plutus:v2'];
    return {
        __type: core_1.Cardano.ScriptType.Plutus,
        bytes: (0, util_2.HexBlob)(plutusScript),
        version
    };
};
const mapScript = (script) => {
    if ((0, util_1.isNativeScript)(script)) {
        return (0, exports.nativeScript)(script.native);
    }
    else if ((0, util_1.isPlutusV1Script)(script) || (0, util_1.isPlutusV2Script)(script))
        return mapPlutusScript(script);
    throw new core_1.SerializationError(core_1.SerializationFailure.InvalidScriptType, `Script '${script}' is not supported.`);
};
exports.mapScript = mapScript;
const mapBootstrapWitness = (b) => ({
    addressAttributes: b.addressAttributes ? (0, util_2.Base64Blob)(b.addressAttributes) : undefined,
    chainCode: b.chainCode ? (0, util_2.HexBlob)(b.chainCode) : undefined,
    key: Crypto.Ed25519PublicKeyHex(b.key),
    signature: Crypto.Ed25519SignatureHex(util_2.HexBlob.fromBase64(b.signature))
});
const mapRedeemer = (key, redeemer) => {
    const purposeAndIndex = key.split(':');
    return {
        data: (0, util_2.HexBlob)(redeemer.redeemer),
        executionUnits: redeemer.executionUnits,
        index: Number(purposeAndIndex[1]),
        purpose: purposeAndIndex[0]
    };
};
const mapAuxiliaryData = (data) => {
    if (data === null)
        return undefined;
    return {
        body: {
            blob: data.body.blob
                ? new Map(Object.entries(data.body.blob).map(([key, value]) => [BigInt(key), core_1.ProviderUtil.jsonToMetadatum(value)]))
                : undefined,
            scripts: data.body.scripts ? data.body.scripts.map(exports.mapScript) : undefined
        },
        hash: Crypto.Hash32ByteBase16(data.hash)
    };
};
const mapTxIn = (txIn) => ({
    index: txIn.index,
    txId: core_1.Cardano.TransactionId(txIn.txId)
});
const mapInlineDatum = (datum) => {
    if (typeof datum !== 'string')
        return;
    return (0, util_2.HexBlob)(datum);
};
const mapDatumHash = (datum) => {
    if (!datum)
        return;
    return Crypto.Hash32ByteBase16(datum);
};
const mapTxOut = (txOut) => ({
    address: core_1.Cardano.Address(txOut.address),
    datum: mapInlineDatum(txOut.datum),
    datumHash: mapDatumHash(txOut.datumHash),
    scriptReference: txOut.script ? (0, exports.mapScript)(txOut.script) : undefined,
    value: {
        assets: txOut.value.assets
            ? new Map(Object.entries(txOut.value.assets).map(([key, value]) => [core_1.Cardano.AssetId(key), value]))
            : undefined,
        coins: txOut.value.coins
    }
});
const mapMint = (tx) => {
    if (tx.body.mint.assets === undefined)
        return undefined;
    return new Map(Object.entries(tx.body.mint.assets).map(([key, value]) => [core_1.Cardano.AssetId(key), value]));
};
const mapScriptIntegrityHash = ({ body: { scriptIntegrityHash } }) => {
    if (scriptIntegrityHash === null)
        return undefined;
    return Crypto.Hash32ByteBase16(scriptIntegrityHash);
};
const mapValidityInterval = ({ invalidBefore, invalidHereafter }) => ({
    invalidBefore: invalidBefore ? core_1.Cardano.Slot(invalidBefore) : undefined,
    invalidHereafter: invalidHereafter ? core_1.Cardano.Slot(invalidHereafter) : undefined
});
const mapCommonTx = (tx, kind) => ({
    auxiliaryData: mapAuxiliaryData(tx.metadata),
    body: {
        certificates: tx.body.certificates.map(mapCertificate),
        collaterals: (0, util_1.isAlonzoOrAbove)(kind) ? tx.body.collaterals.map(mapTxIn) : undefined,
        fee: tx.body.fee,
        inputs: tx.body.inputs.map(mapTxIn),
        mint: (0, util_1.isMaryOrAbove)(kind) ? mapMint(tx) : undefined,
        outputs: tx.body.outputs.map(mapTxOut),
        requiredExtraSignatures: (0, util_1.isAlonzoOrAbove)(kind)
            ? tx.body.requiredExtraSignatures.map(Crypto.Ed25519KeyHashHex)
            : undefined,
        scriptIntegrityHash: (0, util_1.isAlonzoOrAbove)(kind) ? mapScriptIntegrityHash(tx) : undefined,
        validityInterval: (0, util_1.isShelleyTx)(kind)
            ? undefined
            : mapValidityInterval(tx.body.validityInterval),
        withdrawals: Object.entries(tx.body.withdrawals).map(([key, value]) => ({
            quantity: value,
            stakeAddress: core_1.Cardano.RewardAccount(key)
        }))
    },
    id: core_1.Cardano.TransactionId(tx.id),
    witness: {
        bootstrap: tx.witness.bootstrap.map(mapBootstrapWitness),
        datums: (0, util_1.isAlonzoOrAbove)(kind)
            ? Object.values(tx.witness.datums).map((d) => (0, util_2.HexBlob)(d))
            : undefined,
        redeemers: (0, util_1.isAlonzoOrAbove)(kind)
            ? Object.entries(tx.witness.redeemers).map(([key, value]) => mapRedeemer(key, value))
            : undefined,
        scripts: [...Object.values(tx.witness.scripts).map(exports.mapScript)],
        signatures: new Map(Object.entries(tx.witness.signatures).map(([key, value]) => [
            Crypto.Ed25519PublicKeyHex(key),
            Crypto.Ed25519SignatureHex(util_2.HexBlob.fromBase64(value))
        ]))
    }
});
const mapCommonBlockBody = ({ body }, kind) => body.map((blockBody) => mapCommonTx(blockBody, kind));
exports.mapCommonBlockBody = mapCommonBlockBody;
const mapByronTxFee = ({ raw }) => {
    const txSize = Buffer.from((0, util_2.Base64Blob)(raw), 'base64').length;
    return BigInt(util_1.BYRON_TX_FEE_COEFFICIENT * txSize + util_1.BYRON_TX_FEE_CONSTANT);
};
exports.mapByronTxFee = mapByronTxFee;
const mapByronTx = (tx) => ({
    body: {
        fee: (0, exports.mapByronTxFee)(tx),
        inputs: tx.body.inputs.map(mapTxIn),
        outputs: tx.body.outputs.map(mapTxOut)
    },
    id: core_1.Cardano.TransactionId(tx.id),
    witness: {
        signatures: new Map()
    }
});
const mapByronBlockBody = ({ body }) => body.txPayload.map((txPayload) => mapByronTx(txPayload));
exports.mapByronBlockBody = mapByronBlockBody;
//# sourceMappingURL=tx.js.map