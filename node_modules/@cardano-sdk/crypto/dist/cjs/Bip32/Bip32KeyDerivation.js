"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.derivePublic = exports.derivePrivate = void 0;
const bn_js_1 = require("bn.js");
const util_1 = require("@cardano-sdk/util");
const libsodium_wrappers_sumo_1 = require("libsodium-wrappers-sumo");
const isHardenedDerivation = (index) => index >= 2147483648;
const deriveHardened = (index, scalar, iv, chainCode) => {
    const data = Buffer.allocUnsafe(1 + 64 + 4);
    data.writeUInt32LE(index, 1 + 64);
    scalar.copy(data, 1);
    iv.copy(data, 1 + 32);
    data[0] = 0x00;
    const zMac = (0, libsodium_wrappers_sumo_1.crypto_auth_hmacsha512)(data, chainCode);
    data[0] = 0x01;
    const ccMac = (0, libsodium_wrappers_sumo_1.crypto_auth_hmacsha512)(data, chainCode);
    return { ccMac, zMac };
};
const deriveSoft = (index, scalar, chainCode) => {
    const data = Buffer.allocUnsafe(1 + 32 + 4);
    data.writeUInt32LE(index, 1 + 32);
    const vk = Buffer.from((0, libsodium_wrappers_sumo_1.crypto_scalarmult_ed25519_base_noclamp)(scalar));
    vk.copy(data, 1);
    data[0] = 0x02;
    const zMac = (0, libsodium_wrappers_sumo_1.crypto_auth_hmacsha512)(data, chainCode);
    data[0] = 0x03;
    const ccMac = (0, libsodium_wrappers_sumo_1.crypto_auth_hmacsha512)(data, chainCode);
    return { ccMac, zMac };
};
const truc28Mul8 = (lhs, rhs) => new bn_js_1.BN(lhs, 16, 'le').add(new bn_js_1.BN(rhs.slice(0, 28), 16, 'le').mul(new bn_js_1.BN(8))).toArrayLike(Buffer, 'le', 32);
const pointOfTrunc28Mul8 = (sk) => {
    const left = new bn_js_1.BN(sk.slice(0, 28), 16, 'le').mul(new bn_js_1.BN(8)).toArrayLike(Buffer, 'le', 32);
    return (0, libsodium_wrappers_sumo_1.crypto_scalarmult_ed25519_base_noclamp)(left);
};
const add = (lhs, rhs) => {
    let r = new bn_js_1.BN(lhs, 16, 'le').add(new bn_js_1.BN(rhs, 16, 'le')).toArrayLike(Buffer, 'le').subarray(0, 32);
    if (r.length !== 32) {
        r = Buffer.from(r.toString('hex').padEnd(32, '0'), 'hex');
    }
    return r;
};
const derivePrivate = (key, index) => {
    const kl = key.subarray(0, 32);
    const kr = key.subarray(32, 64);
    const cc = key.subarray(64, 96);
    const { ccMac, zMac } = isHardenedDerivation(index) ? deriveHardened(index, kl, kr, cc) : deriveSoft(index, kl, cc);
    const chainCode = ccMac.slice(32, 64);
    const zl = zMac.slice(0, 32);
    const zr = zMac.slice(32, 64);
    const left = truc28Mul8(kl, zl);
    const right = add(kr, zr);
    return Buffer.concat([left, right, chainCode]);
};
exports.derivePrivate = derivePrivate;
const derivePublic = (key, index) => {
    const pk = key.subarray(0, 32);
    const cc = key.subarray(32, 64);
    const data = Buffer.allocUnsafe(1 + 32 + 4);
    data.writeUInt32LE(index, 1 + 32);
    if (isHardenedDerivation(index))
        throw new util_1.InvalidArgumentError('index', 'Public key can not be derived from a hardened index.');
    pk.copy(data, 1);
    data[0] = 0x02;
    const z = (0, libsodium_wrappers_sumo_1.crypto_auth_hmacsha512)(data, cc);
    data[0] = 0x03;
    const c = (0, libsodium_wrappers_sumo_1.crypto_auth_hmacsha512)(data, cc);
    const chainCode = c.slice(32, 64);
    const zl = z.slice(0, 32);
    const p = pointOfTrunc28Mul8(zl);
    return Buffer.concat([(0, libsodium_wrappers_sumo_1.crypto_core_ed25519_add)(p, pk), chainCode]);
};
exports.derivePublic = derivePublic;
//# sourceMappingURL=Bip32KeyDerivation.js.map