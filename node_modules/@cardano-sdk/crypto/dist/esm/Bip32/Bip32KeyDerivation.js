import { BN } from 'bn.js';
import { InvalidArgumentError } from '@cardano-sdk/util';
import { crypto_auth_hmacsha512, crypto_core_ed25519_add, crypto_scalarmult_ed25519_base_noclamp } from 'libsodium-wrappers-sumo';
const isHardenedDerivation = (index) => index >= 2147483648;
const deriveHardened = (index, scalar, iv, chainCode) => {
    const data = Buffer.allocUnsafe(1 + 64 + 4);
    data.writeUInt32LE(index, 1 + 64);
    scalar.copy(data, 1);
    iv.copy(data, 1 + 32);
    data[0] = 0x00;
    const zMac = crypto_auth_hmacsha512(data, chainCode);
    data[0] = 0x01;
    const ccMac = crypto_auth_hmacsha512(data, chainCode);
    return { ccMac, zMac };
};
const deriveSoft = (index, scalar, chainCode) => {
    const data = Buffer.allocUnsafe(1 + 32 + 4);
    data.writeUInt32LE(index, 1 + 32);
    const vk = Buffer.from(crypto_scalarmult_ed25519_base_noclamp(scalar));
    vk.copy(data, 1);
    data[0] = 0x02;
    const zMac = crypto_auth_hmacsha512(data, chainCode);
    data[0] = 0x03;
    const ccMac = crypto_auth_hmacsha512(data, chainCode);
    return { ccMac, zMac };
};
const truc28Mul8 = (lhs, rhs) => new BN(lhs, 16, 'le').add(new BN(rhs.slice(0, 28), 16, 'le').mul(new BN(8))).toArrayLike(Buffer, 'le', 32);
const pointOfTrunc28Mul8 = (sk) => {
    const left = new BN(sk.slice(0, 28), 16, 'le').mul(new BN(8)).toArrayLike(Buffer, 'le', 32);
    return crypto_scalarmult_ed25519_base_noclamp(left);
};
const add = (lhs, rhs) => {
    let r = new BN(lhs, 16, 'le').add(new BN(rhs, 16, 'le')).toArrayLike(Buffer, 'le').subarray(0, 32);
    if (r.length !== 32) {
        r = Buffer.from(r.toString('hex').padEnd(32, '0'), 'hex');
    }
    return r;
};
export const derivePrivate = (key, index) => {
    const kl = key.subarray(0, 32);
    const kr = key.subarray(32, 64);
    const cc = key.subarray(64, 96);
    const { ccMac, zMac } = isHardenedDerivation(index) ? deriveHardened(index, kl, kr, cc) : deriveSoft(index, kl, cc);
    const chainCode = ccMac.slice(32, 64);
    const zl = zMac.slice(0, 32);
    const zr = zMac.slice(32, 64);
    const left = truc28Mul8(kl, zl);
    const right = add(kr, zr);
    return Buffer.concat([left, right, chainCode]);
};
export const derivePublic = (key, index) => {
    const pk = key.subarray(0, 32);
    const cc = key.subarray(32, 64);
    const data = Buffer.allocUnsafe(1 + 32 + 4);
    data.writeUInt32LE(index, 1 + 32);
    if (isHardenedDerivation(index))
        throw new InvalidArgumentError('index', 'Public key can not be derived from a hardened index.');
    pk.copy(data, 1);
    data[0] = 0x02;
    const z = crypto_auth_hmacsha512(data, cc);
    data[0] = 0x03;
    const c = crypto_auth_hmacsha512(data, cc);
    const chainCode = c.slice(32, 64);
    const zl = z.slice(0, 32);
    const p = pointOfTrunc28Mul8(zl);
    return Buffer.concat([crypto_core_ed25519_add(p, pk), chainCode]);
};
//# sourceMappingURL=Bip32KeyDerivation.js.map