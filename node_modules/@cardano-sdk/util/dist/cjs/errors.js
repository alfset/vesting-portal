"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidArgumentError = exports.InvalidStringError = exports.ComposableError = void 0;
const ts_custom_error_1 = require("ts-custom-error");
const isErrorLike = (error) => {
    if (!error || typeof error !== 'object' || !('message' in error && 'stack' in error))
        return false;
    const { message, stack } = error;
    return typeof message === 'string' && typeof stack === 'string';
};
class ComposableError extends ts_custom_error_1.CustomError {
    constructor(message, innerError) {
        let firstLineOfInnerErrorStack = '';
        let innerErrorStack = [];
        if (isErrorLike(innerError) && innerError.stack) {
            [firstLineOfInnerErrorStack, ...innerErrorStack] = innerError.stack.split(ComposableError.stackDelimiter);
            message = `${message} due to\n ${firstLineOfInnerErrorStack}`;
        }
        if (typeof innerError === 'string')
            message = `${message} due to\n ${innerError}`;
        super(message);
        this.innerError = innerError;
        if (!this.stack || innerErrorStack.length === 0)
            return;
        const [firstLineOfStack] = this.stack.split(ComposableError.stackDelimiter);
        Object.defineProperty(this, 'stack', {
            configurable: true,
            value: `${firstLineOfStack}${innerErrorStack.join(ComposableError.stackDelimiter)}`
        });
    }
}
exports.ComposableError = ComposableError;
ComposableError.stackDelimiter = '\n    at ';
class InvalidStringError extends ComposableError {
    constructor(expectation, innerError) {
        super(`Invalid string: "${expectation}"`, innerError);
    }
}
exports.InvalidStringError = InvalidStringError;
class InvalidArgumentError extends ts_custom_error_1.CustomError {
    constructor(argName, message) {
        super(`Invalid argument '${argName}': ${message}`);
    }
}
exports.InvalidArgumentError = InvalidArgumentError;
//# sourceMappingURL=errors.js.map