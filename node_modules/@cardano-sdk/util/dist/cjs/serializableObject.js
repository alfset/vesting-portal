"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromSerializableObject = exports.toSerializableObject = void 0;
const serialize_error_1 = require("serialize-error");
const transform_1 = __importDefault(require("lodash/transform"));
const PLAIN_TYPES = new Set(['boolean', 'number', 'string']);
const defaultGetErrorPrototype = () => Error.prototype;
const defaultTransformKey = (key) => key;
const defaultTransformationTypeKey = '__type';
const toSerializableObject = (obj, options = {}) => {
    if (PLAIN_TYPES.has(typeof obj))
        return obj;
    const { transformationTypeKey = defaultTransformationTypeKey, serializeKey = defaultTransformKey } = options;
    if (typeof obj === 'undefined') {
        return {
            [transformationTypeKey]: 'undefined'
        };
    }
    if (typeof obj === 'object') {
        if (obj === null)
            return null;
        if (Array.isArray(obj)) {
            return obj.map((item) => (0, exports.toSerializableObject)(item, options));
        }
        if (ArrayBuffer.isView(obj)) {
            const arr = new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength / Uint8Array.BYTES_PER_ELEMENT);
            const value = Buffer.from(arr).toString('hex');
            return { [transformationTypeKey]: 'Buffer', value };
        }
        if (obj instanceof Error) {
            return {
                [transformationTypeKey]: 'Error',
                value: (0, serialize_error_1.serializeError)(obj)
            };
        }
        if (obj instanceof Date) {
            return {
                [transformationTypeKey]: 'Date',
                value: obj.getTime()
            };
        }
        if (obj instanceof Set) {
            return {
                [transformationTypeKey]: 'Set',
                value: [...obj].map((item) => (0, exports.toSerializableObject)(item, options))
            };
        }
        if (obj instanceof Map) {
            return {
                [transformationTypeKey]: 'Map',
                value: [...obj.entries()].map(([key, value]) => [
                    (0, exports.toSerializableObject)(key, options),
                    (0, exports.toSerializableObject)(value, options)
                ])
            };
        }
        return (0, transform_1.default)(obj, (result, value, key) => {
            result[serializeKey(key)] = (0, exports.toSerializableObject)(value, options);
            return result;
        }, {});
    }
    if (typeof obj === 'bigint')
        return {
            [transformationTypeKey]: 'bigint',
            value: obj.toString()
        };
};
exports.toSerializableObject = toSerializableObject;
const fromSerializableObjectUnknown = (obj, options = {}) => {
    if (PLAIN_TYPES.has(typeof obj))
        return obj;
    if (typeof obj === 'object') {
        if (obj === null)
            return null;
        if (Array.isArray(obj)) {
            return obj.map((item) => fromSerializableObjectUnknown(item, options));
        }
        const { transformationTypeKey = defaultTransformationTypeKey, deserializeKey = defaultTransformKey, getErrorPrototype = defaultGetErrorPrototype } = options;
        const docAsAny = obj;
        switch (docAsAny[transformationTypeKey]) {
            case 'undefined':
                return undefined;
            case 'bigint':
                return BigInt(docAsAny.value);
            case 'Buffer':
                return Buffer.from(docAsAny.value, 'hex');
            case 'Date':
                return new Date(docAsAny.value);
            case 'Set':
                return new Set(docAsAny.value.map((item) => fromSerializableObjectUnknown(item, options)));
            case 'Map':
                return new Map(docAsAny.value.map((keyValues) => keyValues.map((kv) => fromSerializableObjectUnknown(kv, options))));
            case 'Error': {
                const error = fromSerializableObjectUnknown(docAsAny.value, options);
                return Object.setPrototypeOf(error, getErrorPrototype(error));
            }
            default:
                return (0, transform_1.default)(obj, (result, value, key) => {
                    result[deserializeKey(key)] = fromSerializableObjectUnknown(value, options);
                    return result;
                }, {});
        }
    }
};
const fromSerializableObject = (serializableObject, options) => fromSerializableObjectUnknown(serializableObject, options);
exports.fromSerializableObject = fromSerializableObject;
//# sourceMappingURL=serializableObject.js.map