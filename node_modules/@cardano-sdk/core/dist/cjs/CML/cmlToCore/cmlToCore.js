"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.newTx = exports.utxo = exports.txAuxiliaryData = exports.txMetadata = exports.txMetadatum = exports.txWitnessSet = exports.txWitnessScripts = exports.txWitnessDatums = exports.txWitnessRedeemers = exports.txWitnessBootstrap = exports.txBody = exports.txMint = exports.txCertificates = exports.txReferenceInputs = exports.txInputs = exports.txOutputs = exports.txOut = exports.getCoreScript = exports.txIn = exports.nativeScript = exports.value = exports.txWithdrawals = exports.txRequiredExtraSignatures = void 0;
const Cardano = __importStar(require("../../Cardano"));
const Crypto = __importStar(require("@cardano-sdk/crypto"));
const util_1 = require("@cardano-sdk/util");
const CML_1 = require("../CML");
const Cardano_1 = require("../../Cardano");
const cardano_multiplatform_lib_nodejs_1 = require("@dcspark/cardano-multiplatform-lib-nodejs");
const errors_1 = require("../../errors");
const misc_1 = require("../../util/misc");
const util_2 = require("../../Asset/util");
const certificate_1 = require("./certificate");
const txRequiredExtraSignatures = (signatures) => (0, util_1.usingAutoFree)((scope) => {
    if (!signatures)
        return;
    const requiredSignatures = [];
    for (let i = 0; i < signatures.len(); i++) {
        const signature = scope.manage(signatures.get(i));
        const cardanoSignature = Crypto.Ed25519KeyHashHex(Buffer.from(signature.to_bytes()).toString('hex'));
        requiredSignatures.push(cardanoSignature);
    }
    return requiredSignatures;
});
exports.txRequiredExtraSignatures = txRequiredExtraSignatures;
const txWithdrawals = (withdrawals) => (0, util_1.usingAutoFree)((scope) => {
    if (!withdrawals)
        return;
    const result = [];
    const keys = scope.manage(withdrawals.keys());
    for (let i = 0; i < keys.len(); i++) {
        const key = scope.manage(keys.get(i));
        const value = scope.manage(withdrawals.get(key));
        const rewardAccount = Cardano.RewardAccount(scope.manage(key.to_address()).to_bech32());
        result.push({ quantity: BigInt(value.to_str()), stakeAddress: rewardAccount });
    }
    return result;
});
exports.txWithdrawals = txWithdrawals;
const value = (cslValue) => (0, util_1.usingAutoFree)((scope) => {
    const result = {
        coins: BigInt(scope.manage(cslValue.coin()).to_str())
    };
    const multiasset = scope.manage(cslValue.multiasset());
    if (!multiasset) {
        return result;
    }
    result.assets = new Map();
    const scriptHashes = scope.manage(multiasset.keys());
    for (let scriptHashIdx = 0; scriptHashIdx < scriptHashes.len(); scriptHashIdx++) {
        const scriptHash = scope.manage(scriptHashes.get(scriptHashIdx));
        const assets = scope.manage(multiasset.get(scriptHash));
        const assetKeys = scope.manage(assets.keys());
        for (let assetIdx = 0; assetIdx < assetKeys.len(); assetIdx++) {
            const assetName = scope.manage(assetKeys.get(assetIdx));
            const assetAmount = BigInt(scope.manage(assets.get(assetName)).to_str());
            if (assetAmount > 0n) {
                result.assets.set((0, util_2.createAssetId)(scriptHash, assetName), assetAmount);
            }
        }
    }
    return result;
});
exports.value = value;
const nativeScript = (script) => (0, util_1.usingAutoFree)((scope) => {
    let coreScript;
    const scriptKind = script.kind();
    switch (scriptKind) {
        case Cardano.NativeScriptKind.RequireSignature: {
            coreScript = {
                __type: Cardano.ScriptType.Native,
                keyHash: Crypto.Ed25519KeyHashHex((0, misc_1.bytesToHex)(scope.manage(scope.manage(script.as_script_pubkey()).addr_keyhash()).to_bytes())),
                kind: Cardano.NativeScriptKind.RequireSignature
            };
            break;
        }
        case Cardano.NativeScriptKind.RequireAllOf: {
            coreScript = {
                __type: Cardano.ScriptType.Native,
                kind: Cardano.NativeScriptKind.RequireAllOf,
                scripts: new Array()
            };
            const scriptAll = scope.manage(script.as_script_all());
            for (let i = 0; i < scope.manage(scriptAll.native_scripts()).len(); ++i) {
                coreScript.scripts.push((0, exports.nativeScript)(scope.manage(scope.manage(scriptAll.native_scripts()).get(i))));
            }
            break;
        }
        case Cardano.NativeScriptKind.RequireAnyOf: {
            coreScript = {
                __type: Cardano.ScriptType.Native,
                kind: Cardano.NativeScriptKind.RequireAnyOf,
                scripts: new Array()
            };
            const scriptAny = scope.manage(script.as_script_any());
            for (let i = 0; i < scope.manage(scriptAny.native_scripts()).len(); ++i) {
                coreScript.scripts.push((0, exports.nativeScript)(scope.manage(scope.manage(scriptAny.native_scripts()).get(i))));
            }
            break;
        }
        case Cardano.NativeScriptKind.RequireNOf: {
            const scriptMofK = scope.manage(script.as_script_n_of_k());
            coreScript = {
                __type: Cardano.ScriptType.Native,
                kind: Cardano.NativeScriptKind.RequireNOf,
                required: scriptMofK.n(),
                scripts: new Array()
            };
            for (let i = 0; i < scope.manage(scriptMofK.native_scripts()).len(); ++i) {
                coreScript.scripts.push((0, exports.nativeScript)(scope.manage(scope.manage(scriptMofK.native_scripts()).get(i))));
            }
            break;
        }
        case Cardano.NativeScriptKind.RequireTimeBefore: {
            coreScript = {
                __type: Cardano.ScriptType.Native,
                kind: Cardano.NativeScriptKind.RequireTimeBefore,
                slot: Cardano.Slot(Number(scope.manage(scope.manage(script.as_timelock_expiry()).slot()).to_str()))
            };
            break;
        }
        case Cardano.NativeScriptKind.RequireTimeAfter: {
            coreScript = {
                __type: Cardano.ScriptType.Native,
                kind: Cardano.NativeScriptKind.RequireTimeAfter,
                slot: Cardano.Slot(Number(scope.manage(scope.manage(script.as_timelock_start()).slot()).to_str()))
            };
            break;
        }
        default:
            throw new errors_1.SerializationError(errors_1.SerializationFailure.InvalidNativeScriptKind, `Native Script Kind value '${scriptKind}' is not supported.`);
    }
    return coreScript;
});
exports.nativeScript = nativeScript;
const txIn = (input) => (0, util_1.usingAutoFree)((scope) => ({
    index: Number(scope.manage(input.index()).to_str()),
    txId: Cardano.TransactionId.fromHexBlob((0, misc_1.bytesToHex)(scope.manage(input.transaction_id()).to_bytes()))
}));
exports.txIn = txIn;
const getCoreScript = (scope, script) => {
    let coreScriptRef;
    switch (script.kind()) {
        case cardano_multiplatform_lib_nodejs_1.ScriptKind.NativeScript:
            coreScriptRef = (0, exports.nativeScript)(scope.manage(script.as_native()));
            break;
        case cardano_multiplatform_lib_nodejs_1.ScriptKind.PlutusScriptV1:
            coreScriptRef = {
                __type: Cardano_1.ScriptType.Plutus,
                bytes: util_1.HexBlob.fromBytes(scope.manage(script.as_plutus_v1()).to_bytes()),
                version: Cardano_1.PlutusLanguageVersion.V1
            };
            break;
        case cardano_multiplatform_lib_nodejs_1.ScriptKind.PlutusScriptV2:
            coreScriptRef = {
                __type: Cardano_1.ScriptType.Plutus,
                bytes: util_1.HexBlob.fromBytes(scope.manage(script.as_plutus_v2()).to_bytes()),
                version: Cardano_1.PlutusLanguageVersion.V2
            };
            break;
        default:
            throw new errors_1.SerializationError(errors_1.SerializationFailure.InvalidScriptType, `Script Kind value '${script.kind()}' is not supported.`);
    }
    return coreScriptRef;
};
exports.getCoreScript = getCoreScript;
const txOut = (output) => (0, util_1.usingAutoFree)((scope) => {
    const dataHashBytes = scope.manage(scope.manage(output.datum())?.as_data_hash())?.to_bytes();
    const inlineDatum = scope.manage(scope.manage(output.datum())?.as_inline_data())?.to_bytes();
    const scriptRef = scope.manage(output.script_ref());
    const cmlAddress = scope.manage(output.address());
    const byronAddress = scope.manage(cmlAddress.as_byron());
    const address = byronAddress ? byronAddress.to_base58() : cmlAddress.to_bech32();
    return {
        address: Cardano.Address(address),
        datum: inlineDatum ? (0, misc_1.bytesToHex)(inlineDatum) : undefined,
        datumHash: dataHashBytes ? Crypto.Hash32ByteBase16.fromHexBlob((0, misc_1.bytesToHex)(dataHashBytes)) : undefined,
        scriptReference: scriptRef ? (0, exports.getCoreScript)(scope, scope.manage(scriptRef.script())) : undefined,
        value: (0, exports.value)(scope.manage(output.amount()))
    };
});
exports.txOut = txOut;
const txOutputs = (outputs) => (0, util_1.usingAutoFree)((scope) => {
    const result = [];
    for (let i = 0; i < outputs.len(); i++) {
        result.push((0, exports.txOut)(scope.manage(outputs.get(i))));
    }
    return result;
});
exports.txOutputs = txOutputs;
const txInputs = (inputs) => (0, util_1.usingAutoFree)((scope) => {
    const result = [];
    for (let i = 0; i < inputs.len(); i++) {
        result.push((0, exports.txIn)(scope.manage(inputs.get(i))));
    }
    return result;
});
exports.txInputs = txInputs;
const txReferenceInputs = (referenceInputs) => {
    if (!referenceInputs)
        return;
    return (0, exports.txInputs)(referenceInputs);
};
exports.txReferenceInputs = txReferenceInputs;
const txCertificates = (certificates) => (0, util_1.usingAutoFree)((scope) => {
    if (!certificates)
        return;
    const result = [];
    for (let i = 0; i < certificates.len(); i++) {
        const cslCertificate = scope.manage(certificates.get(i));
        result.push((0, certificate_1.createCertificate)(cslCertificate));
    }
    return result;
});
exports.txCertificates = txCertificates;
const txMint = (assets) => (0, util_1.usingAutoFree)((scope) => {
    if (!assets)
        return;
    const assetMap = new Map();
    const keys = scope.manage(assets.keys());
    for (let i = 0; i < keys.len(); i++) {
        const scriptHash = scope.manage(keys.get(i));
        const mintAssets = scope.manage(assets.get(scriptHash));
        if (!mintAssets)
            continue;
        const mintKeys = scope.manage(mintAssets.keys());
        for (let k = 0; k < mintKeys.len(); k++) {
            const assetName = scope.manage(mintKeys.get(k));
            const assetValueInt = scope.manage(mintAssets.get(assetName));
            const assetId = (0, util_2.createAssetId)(scriptHash, assetName);
            if (!assetValueInt)
                continue;
            const quantity = assetValueInt.is_positive()
                ? BigInt(scope.manage(assetValueInt.as_positive()).to_str())
                : BigInt(scope.manage(assetValueInt.as_negative()).to_str()) * -1n;
            assetMap.set(assetId, quantity);
        }
    }
    return assetMap;
});
exports.txMint = txMint;
const validityInterval = (scope, body) => {
    const cmlInvalidBefore = body.validity_start_interval();
    const cmlInvalidHereafter = body.ttl();
    if (!cmlInvalidBefore && !cmlInvalidHereafter)
        return;
    return {
        invalidBefore: cmlInvalidBefore ? Cardano.Slot(Number(scope.manage(cmlInvalidBefore).to_str())) : undefined,
        invalidHereafter: cmlInvalidHereafter ? Cardano.Slot(Number(scope.manage(cmlInvalidHereafter).to_str())) : undefined
    };
};
const txBody = (body) => (0, util_1.usingAutoFree)((scope) => {
    const cslScriptDataHash = scope.manage(body.script_data_hash());
    const cslCollaterals = scope.manage(body.collateral());
    const cslReferenceInputs = scope.manage(body.reference_inputs());
    const cslCollateralReturn = scope.manage(body.collateral_return());
    const cslTotalCollateral = scope.manage(body.total_collateral());
    return {
        certificates: (0, exports.txCertificates)(scope.manage(body.certs())),
        collateralReturn: cslCollateralReturn ? (0, exports.txOut)(cslCollateralReturn) : undefined,
        collaterals: cslCollaterals && (0, exports.txInputs)(cslCollaterals),
        fee: BigInt(scope.manage(body.fee()).to_str()),
        inputs: (0, exports.txInputs)(scope.manage(body.inputs())),
        mint: (0, exports.txMint)(scope.manage(body.multiassets())),
        outputs: (0, exports.txOutputs)(scope.manage(body.outputs())),
        referenceInputs: cslReferenceInputs ? (0, exports.txInputs)(cslReferenceInputs) : undefined,
        requiredExtraSignatures: (0, exports.txRequiredExtraSignatures)(scope.manage(body.required_signers())),
        scriptIntegrityHash: cslScriptDataHash && Crypto.Hash32ByteBase16(Buffer.from(cslScriptDataHash.to_bytes()).toString('hex')),
        totalCollateral: cslTotalCollateral ? BigInt(cslTotalCollateral.to_str()) : undefined,
        validityInterval: validityInterval(scope, body),
        withdrawals: (0, exports.txWithdrawals)(scope.manage(body.withdrawals()))
    };
});
exports.txBody = txBody;
const txWitnessBootstrap = (bootstraps) => (0, util_1.usingAutoFree)((scope) => {
    if (!bootstraps)
        return;
    const result = [];
    for (let i = 0; i < bootstraps.len(); i++) {
        const bootstrap = scope.manage(bootstraps.get(i));
        const attributes = scope.manage(bootstrap.attributes()).to_bytes();
        const chainCode = bootstrap.chain_code();
        result.push({
            addressAttributes: attributes?.length > 0 ? util_1.Base64Blob.fromBytes(attributes) : undefined,
            chainCode: chainCode?.length > 0 ? util_1.HexBlob.fromBytes(chainCode) : undefined,
            key: Crypto.Ed25519PublicKeyHex(Buffer.from(scope.manage(scope.manage(bootstrap.vkey()).public_key()).as_bytes()).toString('hex')),
            signature: Crypto.Ed25519SignatureHex(scope.manage(bootstrap.signature()).to_hex())
        });
    }
    return result;
});
exports.txWitnessBootstrap = txWitnessBootstrap;
const txWitnessRedeemers = (redeemers) => (0, util_1.usingAutoFree)((scope) => {
    if (!redeemers)
        return;
    const result = [];
    for (let j = 0; j < redeemers.len(); j++) {
        const reedeemer = scope.manage(redeemers.get(j));
        const exUnits = scope.manage(reedeemer.ex_units());
        const redeemerTagKind = scope.manage(reedeemer.tag()).kind();
        result.push({
            data: util_1.HexBlob.fromBytes(scope.manage(reedeemer.data()).to_bytes()),
            executionUnits: {
                memory: Number(scope.manage(exUnits.mem()).to_str()),
                steps: Number(scope.manage(exUnits.steps()).to_str())
            },
            index: Number(scope.manage(reedeemer.index()).to_str()),
            purpose: Object.values(Cardano.RedeemerPurpose)[redeemerTagKind]
        });
    }
    return result;
});
exports.txWitnessRedeemers = txWitnessRedeemers;
const txWitnessDatums = (datums) => (0, util_1.usingAutoFree)((scope) => {
    if (!datums)
        return;
    const result = [];
    for (let j = 0; j < datums.len(); j++) {
        result.push(util_1.HexBlob.fromBytes(scope.manage(datums.get(j)).to_bytes()));
    }
    return result;
});
exports.txWitnessDatums = txWitnessDatums;
const txWitnessScripts = (witnessSet) => (0, util_1.usingAutoFree)((scope) => {
    const scripts = [];
    const plutusScriptsV1 = scope.manage(witnessSet.plutus_v1_scripts());
    const plutusScriptsV2 = scope.manage(witnessSet.plutus_v2_scripts());
    const nativeScripts = scope.manage(witnessSet.native_scripts());
    if (plutusScriptsV1) {
        for (let i = 0; i < plutusScriptsV1.len(); ++i) {
            scripts.push({
                __type: Cardano.ScriptType.Plutus,
                bytes: (0, util_1.HexBlob)(scope.manage(plutusScriptsV1.get(i)).to_js_value()),
                version: Cardano.PlutusLanguageVersion.V1
            });
        }
    }
    if (plutusScriptsV2) {
        for (let i = 0; i < plutusScriptsV2.len(); ++i) {
            scripts.push({
                __type: Cardano.ScriptType.Plutus,
                bytes: (0, util_1.HexBlob)(scope.manage(plutusScriptsV2.get(i)).to_js_value()),
                version: Cardano.PlutusLanguageVersion.V2
            });
        }
    }
    if (nativeScripts) {
        for (let i = 0; i < nativeScripts.len(); ++i) {
            scripts.push((0, exports.nativeScript)(scope.manage(nativeScripts.get(i))));
        }
    }
    return scripts.length === 0 ? undefined : scripts;
});
exports.txWitnessScripts = txWitnessScripts;
const txWitnessSet = (witnessSet) => (0, util_1.usingAutoFree)((scope) => {
    const vkeys = scope.manage(witnessSet.vkeys());
    const redeemers = scope.manage(witnessSet.redeemers());
    const plutusDatums = scope.manage(witnessSet.plutus_data());
    const bootstraps = scope.manage(witnessSet.bootstraps());
    const txSignatures = new Map();
    if (vkeys) {
        for (let i = 0; i < vkeys.len(); i++) {
            const witness = scope.manage(vkeys.get(i));
            txSignatures.set(Crypto.Ed25519PublicKeyHex(Buffer.from(scope.manage(scope.manage(witness.vkey()).public_key()).as_bytes()).toString('hex')), Crypto.Ed25519SignatureHex(scope.manage(witness.signature()).to_hex()));
        }
    }
    return {
        bootstrap: (0, exports.txWitnessBootstrap)(bootstraps),
        datums: (0, exports.txWitnessDatums)(plutusDatums),
        redeemers: (0, exports.txWitnessRedeemers)(redeemers),
        scripts: (0, exports.txWitnessScripts)(witnessSet),
        signatures: txSignatures
    };
});
exports.txWitnessSet = txWitnessSet;
const txMetadatum = (transactionMetadatum) => (0, util_1.usingAutoFree)((scope) => {
    switch (transactionMetadatum.kind()) {
        case CML_1.CML.TransactionMetadatumKind.Bytes:
            return transactionMetadatum.as_bytes();
        case CML_1.CML.TransactionMetadatumKind.Int: {
            const int = scope.manage(transactionMetadatum.as_int());
            if (int.is_positive())
                return BigInt(scope.manage(int.as_positive()).to_str());
            return BigInt(scope.manage(int.as_negative()).to_str()) * -1n;
        }
        case CML_1.CML.TransactionMetadatumKind.MetadataList: {
            const list = scope.manage(transactionMetadatum.as_list());
            const metaDatumList = [];
            for (let j = 0; j < list.len(); j++) {
                const listItem = scope.manage(list.get(j));
                metaDatumList.push((0, exports.txMetadatum)(listItem));
            }
            return metaDatumList;
        }
        case CML_1.CML.TransactionMetadatumKind.MetadataMap: {
            const txMap = scope.manage(transactionMetadatum.as_map());
            const metdatumMap = new Map();
            for (let i = 0; i < scope.manage(txMap.keys()).len(); i++) {
                const mapKey = scope.manage(scope.manage(txMap.keys()).get(i));
                const mapValue = scope.manage(txMap.get(mapKey));
                metdatumMap.set((0, exports.txMetadatum)(mapKey), (0, exports.txMetadatum)(mapValue));
            }
            return metdatumMap;
        }
        case CML_1.CML.TransactionMetadatumKind.Text:
            return transactionMetadatum.as_text();
        default:
            throw new errors_1.SerializationError(errors_1.SerializationFailure.InvalidType);
    }
});
exports.txMetadatum = txMetadatum;
const txMetadata = (auxiliaryMetadata) => (0, util_1.usingAutoFree)((scope) => {
    if (!auxiliaryMetadata)
        return;
    const auxiliaryMetadataMap = new Map();
    const metadataKeys = auxiliaryMetadata.keys();
    for (let i = 0; i < metadataKeys.len(); i++) {
        const key = scope.manage(metadataKeys.get(i));
        const transactionMetadatum = scope.manage(auxiliaryMetadata.get(key));
        if (transactionMetadatum) {
            scope.manage(transactionMetadatum);
            auxiliaryMetadataMap.set(BigInt(key.to_str()), (0, exports.txMetadatum)(transactionMetadatum));
        }
    }
    return auxiliaryMetadataMap;
});
exports.txMetadata = txMetadata;
const txAuxiliaryData = (auxiliaryData) => (0, util_1.usingAutoFree)((scope) => {
    if (!auxiliaryData)
        return;
    const auxiliaryMetadata = scope.manage(auxiliaryData.metadata());
    return {
        body: {
            blob: (0, exports.txMetadata)(auxiliaryMetadata)
        }
    };
});
exports.txAuxiliaryData = txAuxiliaryData;
const utxo = (cslUtxos) => (0, util_1.usingAutoFree)((scope) => cslUtxos.map((cslUtxo) => [(0, exports.txIn)(scope.manage(cslUtxo.input())), (0, exports.txOut)(scope.manage(cslUtxo.output()))]));
exports.utxo = utxo;
const newTx = (cslTx) => (0, util_1.usingAutoFree)((scope) => {
    const transactionHash = Cardano.TransactionId.fromHexBlob((0, misc_1.bytesToHex)(scope.manage(CML_1.CML.hash_transaction(scope.manage(cslTx.body()))).to_bytes()));
    const auxiliary_data = scope.manage(cslTx.auxiliary_data());
    const witnessSet = scope.manage(cslTx.witness_set());
    return {
        auxiliaryData: (0, exports.txAuxiliaryData)(auxiliary_data),
        body: (0, exports.txBody)(scope.manage(cslTx.body())),
        id: transactionHash,
        witness: (0, exports.txWitnessSet)(witnessSet)
    };
});
exports.newTx = newTx;
//# sourceMappingURL=cmlToCore.js.map