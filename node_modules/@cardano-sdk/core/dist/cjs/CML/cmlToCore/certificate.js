"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCertificate = exports.poolRegistration = void 0;
const Crypto = __importStar(require("@cardano-sdk/crypto"));
const CML_1 = require("../CML");
const types_1 = require("../../Cardano/types");
const errors_1 = require("../../errors");
const util_1 = require("@cardano-sdk/util");
const stakeRegistration = (certificate) => (0, util_1.usingAutoFree)((scope) => ({
    __typename: types_1.CertificateType.StakeKeyRegistration,
    stakeKeyHash: Crypto.Ed25519KeyHashHex(Buffer.from(scope.manage(scope.manage(certificate.stake_credential()).to_keyhash()).to_bytes()).toString('hex'))
}));
const stakeDeregistration = (certificate) => (0, util_1.usingAutoFree)((scope) => ({
    __typename: types_1.CertificateType.StakeKeyDeregistration,
    stakeKeyHash: Crypto.Ed25519KeyHashHex(Buffer.from(scope.manage(scope.manage(certificate.stake_credential()).to_keyhash()).to_bytes()).toString('hex'))
}));
const stakeDelegation = (certificate) => (0, util_1.usingAutoFree)((scope) => ({
    __typename: types_1.CertificateType.StakeDelegation,
    poolId: (0, types_1.PoolId)(scope.manage(certificate.pool_keyhash()).to_bech32('pool')),
    stakeKeyHash: Crypto.Ed25519KeyHashHex(Buffer.from(scope.manage(scope.manage(certificate.stake_credential()).to_keyhash()).to_bytes()).toString('hex'))
}));
const createCardanoRelays = (relays) => (0, util_1.usingAutoFree)((scope) => {
    const result = [];
    for (let i = 0; i < relays.len(); i++) {
        const relay = scope.manage(relays.get(i));
        const relayByAddress = scope.manage(relay.as_single_host_addr());
        const relayByName = scope.manage(relay.as_single_host_name());
        const relayByNameMultihost = scope.manage(relay.as_multi_host_name());
        if (relayByAddress) {
            result.push({
                __typename: 'RelayByAddress',
                ipv4: scope.manage(relayByAddress.ipv4())?.ip().join('.'),
                ipv6: scope.manage(relayByAddress.ipv6())?.ip().join('.'),
                port: relayByAddress.port()
            });
        }
        if (relayByName) {
            result.push({
                __typename: 'RelayByName',
                hostname: scope.manage(relayByName.dns_name()).record(),
                port: relayByName.port()
            });
        }
        if (relayByNameMultihost) {
            result.push({
                __typename: 'RelayByNameMultihost',
                dnsName: scope.manage(relayByNameMultihost.dns_name()).record()
            });
        }
    }
    return result;
});
const createCardanoOwners = (owners, networkId) => (0, util_1.usingAutoFree)((scope) => {
    const result = [];
    for (let i = 0; i < owners.len(); i++) {
        const keyHash = scope.manage(owners.get(i));
        const stakeCredential = scope.manage(CML_1.CML.StakeCredential.from_keyhash(keyHash));
        const rewardAccount = scope.manage(CML_1.CML.RewardAddress.new(networkId, stakeCredential));
        result.push((0, types_1.RewardAccount)(scope.manage(rewardAccount.to_address()).to_bech32()));
    }
    return result;
});
const jsonMetadata = (poolMetadata) => (0, util_1.usingAutoFree)((scope) => {
    if (!poolMetadata)
        return;
    return {
        hash: Crypto.Hash32ByteBase16(Buffer.from(scope.manage(poolMetadata.pool_metadata_hash()).to_bytes()).toString('hex')),
        url: scope.manage(poolMetadata.url()).url()
    };
});
const poolRegistration = (certificate) => (0, util_1.usingAutoFree)((scope) => {
    const poolParams = scope.manage(certificate.pool_params());
    const rewardAccountAddress = scope.manage(scope.manage(poolParams.reward_account()).to_address());
    return {
        __typename: types_1.CertificateType.PoolRegistration,
        poolParameters: {
            cost: BigInt(scope.manage(poolParams.cost()).to_str()),
            id: (0, types_1.PoolId)(scope.manage(poolParams.operator()).to_bech32('pool')),
            margin: {
                denominator: Number(scope.manage(scope.manage(poolParams.margin()).denominator()).to_str()),
                numerator: Number(scope.manage(scope.manage(poolParams.margin()).numerator()).to_str())
            },
            metadataJson: jsonMetadata(scope.manage(poolParams.pool_metadata())),
            owners: createCardanoOwners(scope.manage(poolParams.pool_owners()), rewardAccountAddress.network_id()),
            pledge: BigInt(scope.manage(poolParams.pledge()).to_str()),
            relays: createCardanoRelays(scope.manage(poolParams.relays())),
            rewardAccount: (0, types_1.RewardAccount)(rewardAccountAddress.to_bech32()),
            vrf: (0, types_1.VrfVkHex)(Buffer.from(scope.manage(poolParams.vrf_keyhash()).to_bytes()).toString('hex'))
        }
    };
});
exports.poolRegistration = poolRegistration;
const poolRetirement = (certificate) => (0, util_1.usingAutoFree)((scope) => ({
    __typename: types_1.CertificateType.PoolRetirement,
    epoch: (0, types_1.EpochNo)(certificate.epoch()),
    poolId: (0, types_1.PoolId)(scope.manage(certificate.pool_keyhash()).to_bech32('pool'))
}));
const genesisKeyDelegation = (certificate) => (0, util_1.usingAutoFree)((scope) => ({
    __typename: types_1.CertificateType.GenesisKeyDelegation,
    genesisDelegateHash: Crypto.Hash28ByteBase16(scope.manage(certificate.genesis_delegate_hash()).to_hex()),
    genesisHash: Crypto.Hash28ByteBase16(scope.manage(certificate.genesishash()).to_hex()),
    vrfKeyHash: Crypto.Hash32ByteBase16(scope.manage(certificate.vrf_keyhash()).to_hex())
}));
const createCertificate = (cmlCertificate) => (0, util_1.usingAutoFree)((scope) => {
    switch (cmlCertificate.kind()) {
        case CML_1.CML.CertificateKind.StakeRegistration:
            return stakeRegistration(scope.manage(cmlCertificate.as_stake_registration()));
        case CML_1.CML.CertificateKind.StakeDeregistration:
            return stakeDeregistration(scope.manage(cmlCertificate.as_stake_deregistration()));
        case CML_1.CML.CertificateKind.StakeDelegation:
            return stakeDelegation(scope.manage(cmlCertificate.as_stake_delegation()));
        case CML_1.CML.CertificateKind.PoolRegistration:
            return (0, exports.poolRegistration)(scope.manage(cmlCertificate.as_pool_registration()));
        case CML_1.CML.CertificateKind.PoolRetirement:
            return poolRetirement(scope.manage(cmlCertificate.as_pool_retirement()));
        case CML_1.CML.CertificateKind.GenesisKeyDelegation:
            return genesisKeyDelegation(scope.manage(cmlCertificate.as_genesis_key_delegation()));
        case CML_1.CML.CertificateKind.MoveInstantaneousRewardsCert:
            throw new errors_1.NotImplementedError('MIR certificate conversion');
        default:
            throw new errors_1.SerializationError(errors_1.SerializationFailure.InvalidType);
    }
});
exports.createCertificate = createCertificate;
//# sourceMappingURL=certificate.js.map