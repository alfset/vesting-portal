"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tx = exports.witnessSet = exports.txWitnessDatumList = exports.txWitnessRedeemers = exports.txWitnessBootstrap = exports.txBody = exports.txAuxiliaryData = exports.getScripts = exports.txMint = exports.txMetadata = exports.txMetadatum = exports.utxo = exports.txOut = exports.txIn = exports.value = exports.nativeScript = exports.tokenMap = void 0;
const Cardano = __importStar(require("../../Cardano"));
const cardano_multiplatform_lib_nodejs_1 = require("@dcspark/cardano-multiplatform-lib-nodejs");
const certificate = __importStar(require("./certificate"));
const CML_1 = require("../CML");
const Cardano_1 = require("../../Cardano");
const errors_1 = require("../../errors");
const util_1 = require("../../Asset/util");
const parseCmlAddress_1 = require("../parseCmlAddress");
const tokenMap = (scope, map) => {
    const multiasset = scope.manage(cardano_multiplatform_lib_nodejs_1.MultiAsset.new());
    const policyMap = new Map();
    for (const assetId of map.keys()) {
        const { assetName, scriptHash } = (0, util_1.parseAssetId)(assetId);
        scope.manage(assetName);
        scope.manage(scriptHash);
        const policyId = (0, util_1.policyIdFromAssetId)(assetId);
        const amount = scope.manage(cardano_multiplatform_lib_nodejs_1.BigNum.from_str(map.get(assetId).toString()));
        if (!policyMap.has(policyId)) {
            policyMap.set(policyId, { assetsMap: new Map([[assetName, amount]]), scriptHash });
        }
        else {
            const { assetsMap } = policyMap.get(policyId);
            policyMap.set(policyId, { assetsMap: assetsMap.set(assetName, amount), scriptHash });
        }
    }
    for (const { assetsMap, scriptHash } of policyMap.values()) {
        const assets = scope.manage(cardano_multiplatform_lib_nodejs_1.Assets.new());
        for (const [assetName, amount] of assetsMap.entries()) {
            scope.manage(assets.insert(assetName, amount));
        }
        scope.manage(multiasset.insert(scriptHash, assets));
    }
    return multiasset;
};
exports.tokenMap = tokenMap;
const nativeScript = (scope, script) => {
    let cslScript;
    const kind = script.kind;
    switch (kind) {
        case Cardano.NativeScriptKind.RequireSignature: {
            cslScript = scope.manage(cardano_multiplatform_lib_nodejs_1.NativeScript.new_script_pubkey(scope.manage(cardano_multiplatform_lib_nodejs_1.ScriptPubkey.new(scope.manage(cardano_multiplatform_lib_nodejs_1.Ed25519KeyHash.from_bytes(Buffer.from(script.keyHash, 'hex')))))));
            break;
        }
        case Cardano.NativeScriptKind.RequireAllOf: {
            const cslScripts = scope.manage(cardano_multiplatform_lib_nodejs_1.NativeScripts.new());
            for (const subscript of script.scripts) {
                cslScripts.add((0, exports.nativeScript)(scope, subscript));
            }
            cslScript = scope.manage(cardano_multiplatform_lib_nodejs_1.NativeScript.new_script_all(scope.manage(cardano_multiplatform_lib_nodejs_1.ScriptAll.new(cslScripts))));
            break;
        }
        case Cardano.NativeScriptKind.RequireAnyOf: {
            const cslScripts2 = scope.manage(cardano_multiplatform_lib_nodejs_1.NativeScripts.new());
            for (const subscript of script.scripts) {
                cslScripts2.add((0, exports.nativeScript)(scope, subscript));
            }
            cslScript = scope.manage(cardano_multiplatform_lib_nodejs_1.NativeScript.new_script_any(scope.manage(cardano_multiplatform_lib_nodejs_1.ScriptAny.new(cslScripts2))));
            break;
        }
        case Cardano.NativeScriptKind.RequireNOf: {
            const cslScripts3 = scope.manage(cardano_multiplatform_lib_nodejs_1.NativeScripts.new());
            for (const subscript of script.scripts) {
                cslScripts3.add((0, exports.nativeScript)(scope, subscript));
            }
            cslScript = scope.manage(cardano_multiplatform_lib_nodejs_1.NativeScript.new_script_n_of_k(scope.manage(cardano_multiplatform_lib_nodejs_1.ScriptNOfK.new(script.required, cslScripts3))));
            break;
        }
        case Cardano.NativeScriptKind.RequireTimeBefore: {
            cslScript = scope.manage(cardano_multiplatform_lib_nodejs_1.NativeScript.new_timelock_expiry(scope.manage(cardano_multiplatform_lib_nodejs_1.TimelockExpiry.new(scope.manage(cardano_multiplatform_lib_nodejs_1.BigNum.from_str(script.slot.toString()))))));
            break;
        }
        case Cardano.NativeScriptKind.RequireTimeAfter: {
            cslScript = scope.manage(cardano_multiplatform_lib_nodejs_1.NativeScript.new_timelock_start(scope.manage(cardano_multiplatform_lib_nodejs_1.TimelockStart.new(scope.manage(cardano_multiplatform_lib_nodejs_1.BigNum.from_str(script.slot.toString()))))));
            break;
        }
        default:
            throw new errors_1.SerializationError(errors_1.SerializationFailure.InvalidNativeScriptKind, `Native Script Type value '${kind}' is not supported.`);
    }
    return cslScript;
};
exports.nativeScript = nativeScript;
const value = (scope, { coins, assets }) => {
    const result = scope.manage(cardano_multiplatform_lib_nodejs_1.Value.new(scope.manage(cardano_multiplatform_lib_nodejs_1.BigNum.from_str(coins.toString()))));
    if (!assets) {
        return result;
    }
    if (assets.size > 0) {
        result.set_multiasset((0, exports.tokenMap)(scope, assets));
    }
    return result;
};
exports.value = value;
const txIn = (scope, core) => scope.manage(cardano_multiplatform_lib_nodejs_1.TransactionInput.new(scope.manage(cardano_multiplatform_lib_nodejs_1.TransactionHash.from_bytes(Buffer.from(core.txId, 'hex'))), scope.manage(cardano_multiplatform_lib_nodejs_1.BigNum.from_str(core.index.toString()))));
exports.txIn = txIn;
const txOut = (scope, core) => {
    const cslTxOut = scope.manage(cardano_multiplatform_lib_nodejs_1.TransactionOutput.new((0, parseCmlAddress_1.parseCmlAddress)(scope, core.address), (0, exports.value)(scope, core.value)));
    if (core.datum && core.datumHash)
        throw new errors_1.SerializationError(errors_1.SerializationFailure.InvalidDatum, 'Only one type of datum can be specified for a given output but both Datum hash and inline Datum were provided');
    if (core.datum) {
        cslTxOut.set_datum(scope.manage(cardano_multiplatform_lib_nodejs_1.Datum.new_data(scope.manage(cardano_multiplatform_lib_nodejs_1.PlutusData.from_bytes(Buffer.from(core.datum, 'hex'))))));
    }
    if (core.datumHash) {
        cslTxOut.set_datum(scope.manage(cardano_multiplatform_lib_nodejs_1.Datum.new_data_hash(scope.manage(cardano_multiplatform_lib_nodejs_1.DataHash.from_bytes(Buffer.from(core.datumHash, 'hex'))))));
    }
    if (core.scriptReference) {
        const scriptType = core.scriptReference.__type;
        let cmlScript;
        switch (scriptType) {
            case Cardano.ScriptType.Native:
                cmlScript = scope.manage(cardano_multiplatform_lib_nodejs_1.Script.new_native((0, exports.nativeScript)(scope, core.scriptReference)));
                break;
            case Cardano.ScriptType.Plutus:
                if (core.scriptReference.version === Cardano.PlutusLanguageVersion.V1) {
                    cmlScript = scope.manage(cardano_multiplatform_lib_nodejs_1.Script.new_plutus_v1(scope.manage(cardano_multiplatform_lib_nodejs_1.PlutusV1Script.new(Buffer.from(core.scriptReference.bytes, 'hex')))));
                }
                else if (core.scriptReference.version === Cardano.PlutusLanguageVersion.V2) {
                    cmlScript = scope.manage(cardano_multiplatform_lib_nodejs_1.Script.new_plutus_v2(scope.manage(cardano_multiplatform_lib_nodejs_1.PlutusV2Script.new(Buffer.from(core.scriptReference.bytes, 'hex')))));
                }
                break;
            default:
                throw new errors_1.SerializationError(errors_1.SerializationFailure.InvalidScriptType, `Script Type value '${scriptType}' is not supported.`);
        }
        cslTxOut.set_script_ref(cardano_multiplatform_lib_nodejs_1.ScriptRef.new(cmlScript));
    }
    return cslTxOut;
};
exports.txOut = txOut;
const utxo = (scope, core) => core.map((item) => scope.manage(cardano_multiplatform_lib_nodejs_1.TransactionUnspentOutput.new((0, exports.txIn)(scope, item[0]), (0, exports.txOut)(scope, item[1]))));
exports.utxo = utxo;
const check64Length = (metadatum) => {
    const len = typeof metadatum === 'string' ? Buffer.from(metadatum, 'utf8').length : metadatum.length;
    if (len > 64)
        throw new errors_1.SerializationError(errors_1.SerializationFailure.MaxLengthLimit, `Metadatum value '${metadatum}' is too long. Length is ${len}. Max length is 64 bytes`);
};
const txMetadatum = (scope, metadatum) => {
    if (metadatum === null)
        throw new errors_1.SerializationError(errors_1.SerializationFailure.InvalidType);
    switch (typeof metadatum) {
        case 'number':
        case 'boolean':
        case 'undefined':
            throw new errors_1.SerializationError(errors_1.SerializationFailure.InvalidType);
        case 'bigint': {
            const cslInt = metadatum >= 0
                ? scope.manage(cardano_multiplatform_lib_nodejs_1.Int.new(scope.manage(cardano_multiplatform_lib_nodejs_1.BigNum.from_str(metadatum.toString()))))
                : scope.manage(cardano_multiplatform_lib_nodejs_1.Int.new_negative(scope.manage(cardano_multiplatform_lib_nodejs_1.BigNum.from_str((metadatum * -1n).toString()))));
            return scope.manage(cardano_multiplatform_lib_nodejs_1.TransactionMetadatum.new_int(cslInt));
        }
        case 'string':
            check64Length(metadatum);
            return scope.manage(cardano_multiplatform_lib_nodejs_1.TransactionMetadatum.new_text(metadatum));
        default: {
            if (Array.isArray(metadatum)) {
                const metadataList = scope.manage(cardano_multiplatform_lib_nodejs_1.MetadataList.new());
                for (const metadataItem of metadatum) {
                    metadataList.add((0, exports.txMetadatum)(scope, metadataItem));
                }
                return scope.manage(cardano_multiplatform_lib_nodejs_1.TransactionMetadatum.new_list(metadataList));
            }
            else if (ArrayBuffer.isView(metadatum)) {
                check64Length(metadatum);
                return scope.manage(cardano_multiplatform_lib_nodejs_1.TransactionMetadatum.new_bytes(metadatum));
            }
            const metadataMap = scope.manage(cardano_multiplatform_lib_nodejs_1.MetadataMap.new());
            for (const [key, data] of metadatum.entries()) {
                metadataMap.insert((0, exports.txMetadatum)(scope, key), (0, exports.txMetadatum)(scope, data));
            }
            return scope.manage(cardano_multiplatform_lib_nodejs_1.TransactionMetadatum.new_map(metadataMap));
        }
    }
};
exports.txMetadatum = txMetadatum;
const txMetadata = (scope, blob) => {
    const metadata = scope.manage(cardano_multiplatform_lib_nodejs_1.GeneralTransactionMetadata.new());
    for (const [key, data] of blob.entries()) {
        metadata.insert(scope.manage(cardano_multiplatform_lib_nodejs_1.BigNum.from_str(key.toString())), (0, exports.txMetadatum)(scope, data));
    }
    return metadata;
};
exports.txMetadata = txMetadata;
const txMint = (scope, mint) => {
    const cslMint = scope.manage(cardano_multiplatform_lib_nodejs_1.Mint.new());
    const mintMap = new Map();
    for (const [assetId, quantity] of mint.entries()) {
        const policyId = (0, util_1.policyIdFromAssetId)(assetId);
        const assetName = (0, util_1.assetNameFromAssetId)(assetId);
        let [scriptHash, mintAssets] = mintMap.get(policyId) || [];
        if (!scriptHash || !mintAssets) {
            scriptHash = scope.manage(cardano_multiplatform_lib_nodejs_1.ScriptHash.from_bytes(Buffer.from(policyId, 'hex')));
            mintAssets = scope.manage(cardano_multiplatform_lib_nodejs_1.MintAssets.new());
            mintMap.set(policyId, [scriptHash, mintAssets]);
        }
        const intQuantity = quantity >= 0n
            ? scope.manage(cardano_multiplatform_lib_nodejs_1.Int.new(scope.manage(cardano_multiplatform_lib_nodejs_1.BigNum.from_str(quantity.toString()))))
            : scope.manage(cardano_multiplatform_lib_nodejs_1.Int.new_negative(scope.manage(cardano_multiplatform_lib_nodejs_1.BigNum.from_str((quantity * -1n).toString()))));
        mintAssets.insert(scope.manage(cardano_multiplatform_lib_nodejs_1.AssetName.new(Buffer.from(assetName, 'hex'))), intQuantity);
    }
    for (const [scriptHash, mintAssets] of mintMap.values()) {
        cslMint.insert(scriptHash, mintAssets);
    }
    return cslMint;
};
exports.txMint = txMint;
const getScripts = (scope, scripts) => {
    const nativeScripts = scope.manage(cardano_multiplatform_lib_nodejs_1.NativeScripts.new());
    const plutusV1Scripts = scope.manage(cardano_multiplatform_lib_nodejs_1.PlutusV1Scripts.new());
    const plutusV2Scripts = scope.manage(cardano_multiplatform_lib_nodejs_1.PlutusV2Scripts.new());
    for (const script of scripts) {
        switch (script.__type) {
            case Cardano.ScriptType.Native:
                nativeScripts.add((0, exports.nativeScript)(scope, script));
                break;
            case Cardano.ScriptType.Plutus:
                if (script.version === Cardano.PlutusLanguageVersion.V1) {
                    plutusV1Scripts.add(cardano_multiplatform_lib_nodejs_1.PlutusV1Script.new(Buffer.from(script.bytes, 'hex')));
                }
                else if (script.version === Cardano.PlutusLanguageVersion.V2) {
                    plutusV2Scripts.add(cardano_multiplatform_lib_nodejs_1.PlutusV2Script.new(Buffer.from(script.bytes, 'hex')));
                }
                break;
            default:
                throw new errors_1.SerializationError(errors_1.SerializationFailure.InvalidScriptType, `Script '${script}' is not supported.`);
        }
    }
    return { nativeScripts, plutusV1Scripts, plutusV2Scripts };
};
exports.getScripts = getScripts;
const txAuxiliaryData = (scope, auxiliaryData) => {
    if (!auxiliaryData)
        return;
    const result = scope.manage(cardano_multiplatform_lib_nodejs_1.AuxiliaryData.new());
    const { blob, scripts } = auxiliaryData.body;
    if (blob) {
        result.set_metadata((0, exports.txMetadata)(scope, blob));
    }
    if (scripts) {
        const { nativeScripts, plutusV1Scripts, plutusV2Scripts } = (0, exports.getScripts)(scope, scripts);
        result.set_native_scripts(nativeScripts);
        result.set_plutus_v1_scripts(plutusV1Scripts);
        result.set_plutus_v2_scripts(plutusV2Scripts);
    }
    return result;
};
exports.txAuxiliaryData = txAuxiliaryData;
const txInputs = (scope, coreInputs) => {
    const cslInputs = scope.manage(cardano_multiplatform_lib_nodejs_1.TransactionInputs.new());
    for (const input of coreInputs) {
        cslInputs.add((0, exports.txIn)(scope, input));
    }
    return cslInputs;
};
const keyHashes = (scope, coreHashes) => {
    const cslKeyHashes = scope.manage(cardano_multiplatform_lib_nodejs_1.Ed25519KeyHashes.new());
    for (const signature of coreHashes) {
        cslKeyHashes.add(scope.manage(cardano_multiplatform_lib_nodejs_1.Ed25519KeyHash.from_bytes(Buffer.from(signature, 'hex'))));
    }
    return cslKeyHashes;
};
const txWithdrawals = (scope, coreWithdrawals) => {
    const cslWithdrawals = scope.manage(cardano_multiplatform_lib_nodejs_1.Withdrawals.new());
    for (const { stakeAddress, quantity } of coreWithdrawals) {
        const cslAddress = cardano_multiplatform_lib_nodejs_1.RewardAddress.from_address(scope.manage(cardano_multiplatform_lib_nodejs_1.Address.from_bech32(stakeAddress)));
        if (!cslAddress) {
            throw new errors_1.SerializationError(errors_1.SerializationFailure.InvalidAddress, `Invalid withdrawal address: ${stakeAddress}`);
        }
        cslWithdrawals.insert(scope.manage(cslAddress), scope.manage(cardano_multiplatform_lib_nodejs_1.BigNum.from_str(quantity.toString())));
    }
    return cslWithdrawals;
};
const txBody = (scope, { inputs, outputs, fee, validityInterval, certificates, withdrawals, mint, collaterals, requiredExtraSignatures, scriptIntegrityHash, totalCollateral, collateralReturn, referenceInputs }, auxiliaryData) => {
    const cslOutputs = scope.manage(cardano_multiplatform_lib_nodejs_1.TransactionOutputs.new());
    for (const output of outputs) {
        cslOutputs.add((0, exports.txOut)(scope, output));
    }
    const cslBody = scope.manage(cardano_multiplatform_lib_nodejs_1.TransactionBody.new(txInputs(scope, inputs), cslOutputs, scope.manage(cardano_multiplatform_lib_nodejs_1.BigNum.from_str(fee.toString())), typeof validityInterval?.invalidHereafter !== 'undefined'
        ?
            cardano_multiplatform_lib_nodejs_1.BigNum.from_str(validityInterval.invalidHereafter.toString())
        : undefined));
    if (typeof validityInterval?.invalidBefore !== 'undefined') {
        cslBody.set_validity_start_interval(scope.manage(cardano_multiplatform_lib_nodejs_1.BigNum.from_str(validityInterval.invalidBefore.toString())));
    }
    if (mint) {
        cslBody.set_mint((0, exports.txMint)(scope, mint));
    }
    if (collaterals) {
        cslBody.set_collateral(txInputs(scope, collaterals));
    }
    if (totalCollateral) {
        cslBody.set_total_collateral(scope.manage(cardano_multiplatform_lib_nodejs_1.BigNum.from_str(totalCollateral.toString())));
    }
    if (collateralReturn) {
        cslBody.set_collateral_return(scope.manage((0, exports.txOut)(scope, collateralReturn)));
    }
    if (referenceInputs) {
        cslBody.set_reference_inputs(txInputs(scope, referenceInputs));
    }
    if (requiredExtraSignatures?.length) {
        cslBody.set_required_signers(keyHashes(scope, requiredExtraSignatures));
    }
    if (scriptIntegrityHash) {
        cslBody.set_script_data_hash(scope.manage(cardano_multiplatform_lib_nodejs_1.ScriptDataHash.from_bytes(Buffer.from(scriptIntegrityHash, 'hex'))));
    }
    if (certificates?.length) {
        const certs = scope.manage(cardano_multiplatform_lib_nodejs_1.Certificates.new());
        for (const cert of certificates) {
            certs.add(certificate.create(scope, cert));
        }
        cslBody.set_certs(certs);
    }
    if (withdrawals?.length) {
        cslBody.set_withdrawals(txWithdrawals(scope, withdrawals));
    }
    const cslAuxiliaryData = (0, exports.txAuxiliaryData)(scope, auxiliaryData);
    if (cslAuxiliaryData) {
        cslBody.set_auxiliary_data_hash(scope.manage((0, cardano_multiplatform_lib_nodejs_1.hash_auxiliary_data)(cslAuxiliaryData)));
    }
    return cslBody;
};
exports.txBody = txBody;
const txWitnessBootstrap = (scope, bootstrap) => {
    const witnesses = scope.manage(cardano_multiplatform_lib_nodejs_1.BootstrapWitnesses.new());
    for (const coreWitness of bootstrap) {
        witnesses.add(scope.manage(cardano_multiplatform_lib_nodejs_1.BootstrapWitness.new(scope.manage(cardano_multiplatform_lib_nodejs_1.Vkey.new(scope.manage(cardano_multiplatform_lib_nodejs_1.PublicKey.from_bytes(Buffer.from(coreWitness.key, 'hex'))))), scope.manage(cardano_multiplatform_lib_nodejs_1.Ed25519Signature.from_hex(coreWitness.signature)), Buffer.from(coreWitness.chainCode || '', 'hex'), scope.manage(cardano_multiplatform_lib_nodejs_1.AddrAttributes.from_bytes(Buffer.from(coreWitness.addressAttributes || '', 'base64'))))));
    }
    return witnesses;
};
exports.txWitnessBootstrap = txWitnessBootstrap;
const mapRedeemerTag = (scope, redeemerPurpose) => {
    switch (redeemerPurpose) {
        case Cardano_1.RedeemerPurpose.spend:
            return scope.manage(cardano_multiplatform_lib_nodejs_1.RedeemerTag.new_spend());
        case Cardano_1.RedeemerPurpose.mint:
            return scope.manage(cardano_multiplatform_lib_nodejs_1.RedeemerTag.new_mint());
        case Cardano_1.RedeemerPurpose.certificate:
            return scope.manage(cardano_multiplatform_lib_nodejs_1.RedeemerTag.new_cert());
        case Cardano_1.RedeemerPurpose.withdrawal:
            return scope.manage(cardano_multiplatform_lib_nodejs_1.RedeemerTag.new_reward());
    }
};
const txWitnessRedeemers = (scope, redeemers) => {
    const witnessRedeemers = scope.manage(cardano_multiplatform_lib_nodejs_1.Redeemers.new());
    for (const redeemer of redeemers) {
        const tag = mapRedeemerTag(scope, redeemer.purpose);
        const index = scope.manage(cardano_multiplatform_lib_nodejs_1.BigNum.from_str(redeemer.index.toString()));
        const data = scope.manage(cardano_multiplatform_lib_nodejs_1.PlutusData.from_bytes(Buffer.from(redeemer.data, 'hex')));
        const units = scope.manage(cardano_multiplatform_lib_nodejs_1.ExUnits.new(scope.manage(cardano_multiplatform_lib_nodejs_1.BigNum.from_str(redeemer.executionUnits.memory.toString())), scope.manage(cardano_multiplatform_lib_nodejs_1.BigNum.from_str(redeemer.executionUnits.steps.toString()))));
        witnessRedeemers.add(scope.manage(cardano_multiplatform_lib_nodejs_1.Redeemer.new(tag, index, data, units)));
    }
    return witnessRedeemers;
};
exports.txWitnessRedeemers = txWitnessRedeemers;
const txWitnessDatumList = (scope, datums) => {
    const plutusDatumList = scope.manage(cardano_multiplatform_lib_nodejs_1.PlutusList.new());
    for (const datum of datums) {
        plutusDatumList.add(scope.manage(CML_1.CML.PlutusData.from_bytes(Buffer.from(datum, 'hex'))));
    }
    return plutusDatumList;
};
exports.txWitnessDatumList = txWitnessDatumList;
const witnessSet = (scope, witness) => {
    const txWitnessSet = scope.manage(cardano_multiplatform_lib_nodejs_1.TransactionWitnessSet.new());
    const vkeyWitnesses = scope.manage(cardano_multiplatform_lib_nodejs_1.Vkeywitnesses.new());
    for (const [vkey, signature] of witness.signatures.entries()) {
        const publicKey = scope.manage(cardano_multiplatform_lib_nodejs_1.PublicKey.from_bytes(Buffer.from(vkey, 'hex')));
        const vkeyWitness = scope.manage(cardano_multiplatform_lib_nodejs_1.Vkeywitness.new(scope.manage(cardano_multiplatform_lib_nodejs_1.Vkey.new(publicKey)), scope.manage(cardano_multiplatform_lib_nodejs_1.Ed25519Signature.from_hex(signature))));
        vkeyWitnesses.add(vkeyWitness);
    }
    txWitnessSet.set_vkeys(vkeyWitnesses);
    if (witness.scripts) {
        const { nativeScripts, plutusV1Scripts, plutusV2Scripts } = (0, exports.getScripts)(scope, witness.scripts);
        txWitnessSet.set_native_scripts(nativeScripts);
        txWitnessSet.set_plutus_v1_scripts(plutusV1Scripts);
        txWitnessSet.set_plutus_v2_scripts(plutusV2Scripts);
    }
    if (witness.bootstrap) {
        txWitnessSet.set_bootstraps((0, exports.txWitnessBootstrap)(scope, witness.bootstrap));
    }
    if (witness.redeemers) {
        txWitnessSet.set_redeemers((0, exports.txWitnessRedeemers)(scope, witness.redeemers));
    }
    if (witness.datums) {
        txWitnessSet.set_plutus_data((0, exports.txWitnessDatumList)(scope, witness.datums));
    }
    return txWitnessSet;
};
exports.witnessSet = witnessSet;
const tx = (scope, { body, witness, auxiliaryData }) => {
    const txWitnessSet = (0, exports.witnessSet)(scope, witness);
    return scope.manage(cardano_multiplatform_lib_nodejs_1.Transaction.new((0, exports.txBody)(scope, body, auxiliaryData), txWitnessSet, (0, exports.txAuxiliaryData)(scope, auxiliaryData)));
};
exports.tx = tx;
//# sourceMappingURL=coreToCml.js.map