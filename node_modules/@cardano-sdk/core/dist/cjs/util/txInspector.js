"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTxInspector = exports.metadataInspector = exports.assetsBurnedInspector = exports.assetsMintedInspector = exports.mintInspector = exports.withdrawalInspector = exports.poolRetirementInspector = exports.poolRegistrationInspector = exports.stakeKeyRegistrationInspector = exports.stakeKeyDeregistrationInspector = exports.delegationInspector = exports.valueReceivedInspector = exports.valueSentInspector = exports.sentInspector = exports.signedCertificatesInspector = exports.totalAddressOutputsValueInspector = exports.totalAddressInputsValueInspector = void 0;
const types_1 = require("../Cardano/types");
const util_1 = require("@cardano-sdk/util");
const util_2 = require("../Asset/util");
const coalesceValueQuantities_1 = require("./coalesceValueQuantities");
const address_1 = require("../Cardano/util/address");
const nativeScript_1 = require("./nativeScript");
const resolveInputValue_1 = require("../Cardano/util/resolveInputValue");
const subtractValueQuantities_1 = require("./subtractValueQuantities");
const totalAddressInputsValueInspector = (ownAddresses, getHistoricalTxs) => (tx) => {
    const receivedInputs = tx.body.inputs.filter((input) => (0, address_1.isAddressWithin)(ownAddresses)(input));
    const receivedInputsValues = receivedInputs
        .map((input) => (0, resolveInputValue_1.resolveInputValue)(input, getHistoricalTxs()))
        .filter((value) => !!value);
    return (0, coalesceValueQuantities_1.coalesceValueQuantities)(receivedInputsValues);
};
exports.totalAddressInputsValueInspector = totalAddressInputsValueInspector;
const totalAddressOutputsValueInspector = (ownAddresses) => (tx) => {
    const receivedOutputs = tx.body.outputs.filter((out) => (0, address_1.isAddressWithin)(ownAddresses)(out));
    return (0, coalesceValueQuantities_1.coalesceValueQuantities)(receivedOutputs.map((output) => output.value));
};
exports.totalAddressOutputsValueInspector = totalAddressOutputsValueInspector;
const signedCertificatesInspector = (rewardAccounts, certificateTypes) => (tx) => {
    if (!tx.body.certificates || tx.body.certificates.length === 0)
        return [];
    const stakeKeyHashes = rewardAccounts?.map((account) => types_1.RewardAccount.toHash(account));
    const certificates = certificateTypes
        ? tx.body.certificates?.filter((certificate) => certificateTypes.includes(certificate.__typename))
        : tx.body.certificates;
    return certificates.filter((certificate) => {
        if ('stakeKeyHash' in certificate)
            return stakeKeyHashes.includes(certificate.stakeKeyHash);
        if ('rewardAccount' in certificate)
            return rewardAccounts.includes(certificate.rewardAccount);
        if ('poolParameters' in certificate)
            return rewardAccounts.includes(certificate.poolParameters.rewardAccount);
        return false;
    });
};
exports.signedCertificatesInspector = signedCertificatesInspector;
const sentInspector = ({ addresses, rewardAccounts }) => (tx) => ({
    certificates: rewardAccounts?.length ? (0, exports.signedCertificatesInspector)(rewardAccounts)(tx) : [],
    inputs: addresses?.length ? (0, address_1.inputsWithAddresses)(tx, addresses) : []
});
exports.sentInspector = sentInspector;
const valueSentInspector = (ownAddresses, historicalTxs) => (tx) => {
    let assets = new Map();
    if ((0, exports.sentInspector)({ addresses: ownAddresses })(tx).inputs.length === 0)
        return { coins: 0n };
    const totalOutputValue = (0, exports.totalAddressOutputsValueInspector)(ownAddresses)(tx);
    const totalInputValue = (0, exports.totalAddressInputsValueInspector)(ownAddresses, historicalTxs)(tx);
    const diff = (0, subtractValueQuantities_1.subtractValueQuantities)([totalInputValue, totalOutputValue]);
    if (diff.assets)
        assets = (0, util_2.removeNegativesFromTokenMap)(diff.assets);
    return {
        assets: assets.size > 0 ? assets : undefined,
        coins: diff.coins < 0n ? 0n : diff.coins
    };
};
exports.valueSentInspector = valueSentInspector;
const valueReceivedInspector = (ownAddresses, historicalTxs) => (tx) => {
    let assets = new Map();
    const totalOutputValue = (0, exports.totalAddressOutputsValueInspector)(ownAddresses)(tx);
    const totalInputValue = (0, exports.totalAddressInputsValueInspector)(ownAddresses, historicalTxs)(tx);
    const diff = (0, subtractValueQuantities_1.subtractValueQuantities)([totalOutputValue, totalInputValue]);
    if (diff.assets)
        assets = (0, util_2.removeNegativesFromTokenMap)(diff.assets);
    return {
        assets: assets.size > 0 ? assets : undefined,
        coins: diff.coins < 0n ? 0n : diff.coins
    };
};
exports.valueReceivedInspector = valueReceivedInspector;
const certificateInspector = (type) => (tx) => tx.body.certificates?.filter((cert) => cert.__typename === type) ?? [];
exports.delegationInspector = certificateInspector(types_1.CertificateType.StakeDelegation);
exports.stakeKeyDeregistrationInspector = certificateInspector(types_1.CertificateType.StakeKeyDeregistration);
exports.stakeKeyRegistrationInspector = certificateInspector(types_1.CertificateType.StakeKeyRegistration);
exports.poolRegistrationInspector = certificateInspector(types_1.CertificateType.PoolRegistration);
exports.poolRetirementInspector = certificateInspector(types_1.CertificateType.PoolRetirement);
const withdrawalInspector = (tx) => tx.body.withdrawals?.length ? util_1.BigIntMath.sum(tx.body.withdrawals.map(({ quantity }) => quantity)) : 0n;
exports.withdrawalInspector = withdrawalInspector;
const mintInspector = (matchQuantityCriteria) => (tx) => {
    const assets = [];
    const scriptMap = new Map();
    if (!tx.body.mint)
        return assets;
    const scripts = [...(tx.auxiliaryData?.body?.scripts || []), ...(tx.witness?.scripts || [])];
    for (const script of scripts) {
        switch (script.__type) {
            case types_1.ScriptType.Native: {
                const policyId = (0, nativeScript_1.nativeScriptPolicyId)(script);
                if (scriptMap.has(policyId))
                    continue;
                scriptMap.set(policyId, script);
                break;
            }
            case types_1.ScriptType.Plutus:
            default:
        }
    }
    for (const [key, value] of tx.body.mint.entries()) {
        const [policyId, assetName] = [(0, util_2.policyIdFromAssetId)(key), (0, util_2.assetNameFromAssetId)(key)];
        const mintedAsset = {
            assetName,
            fingerprint: types_1.AssetFingerprint.fromParts(policyId, assetName),
            policyId,
            quantity: value,
            script: scriptMap.get(policyId)
        };
        if (matchQuantityCriteria(mintedAsset.quantity))
            assets.push(mintedAsset);
    }
    return assets;
};
exports.mintInspector = mintInspector;
exports.assetsMintedInspector = (0, exports.mintInspector)((quantity) => quantity > 0);
exports.assetsBurnedInspector = (0, exports.mintInspector)((quantity) => quantity < 0);
const metadataInspector = (tx) => tx.auxiliaryData?.body?.blob ?? new Map();
exports.metadataInspector = metadataInspector;
const createTxInspector = (inspectors) => (tx) => Object.keys(inspectors).reduce((result, key) => {
    const inspector = inspectors[key];
    result[key] = inspector(tx);
    return result;
}, {});
exports.createTxInspector = createTxInspector;
//# sourceMappingURL=txInspector.js.map