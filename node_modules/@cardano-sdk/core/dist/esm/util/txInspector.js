import { AssetFingerprint, CertificateType, RewardAccount, ScriptType } from '../Cardano/types';
import { BigIntMath } from '@cardano-sdk/util';
import { assetNameFromAssetId, policyIdFromAssetId, removeNegativesFromTokenMap } from '../Asset/util';
import { coalesceValueQuantities } from './coalesceValueQuantities';
import { inputsWithAddresses, isAddressWithin } from '../Cardano/util/address';
import { nativeScriptPolicyId } from './nativeScript';
import { resolveInputValue } from '../Cardano/util/resolveInputValue';
import { subtractValueQuantities } from './subtractValueQuantities';
export const totalAddressInputsValueInspector = (ownAddresses, getHistoricalTxs) => (tx) => {
    const receivedInputs = tx.body.inputs.filter((input) => isAddressWithin(ownAddresses)(input));
    const receivedInputsValues = receivedInputs
        .map((input) => resolveInputValue(input, getHistoricalTxs()))
        .filter((value) => !!value);
    return coalesceValueQuantities(receivedInputsValues);
};
export const totalAddressOutputsValueInspector = (ownAddresses) => (tx) => {
    const receivedOutputs = tx.body.outputs.filter((out) => isAddressWithin(ownAddresses)(out));
    return coalesceValueQuantities(receivedOutputs.map((output) => output.value));
};
export const signedCertificatesInspector = (rewardAccounts, certificateTypes) => (tx) => {
    if (!tx.body.certificates || tx.body.certificates.length === 0)
        return [];
    const stakeKeyHashes = rewardAccounts?.map((account) => RewardAccount.toHash(account));
    const certificates = certificateTypes
        ? tx.body.certificates?.filter((certificate) => certificateTypes.includes(certificate.__typename))
        : tx.body.certificates;
    return certificates.filter((certificate) => {
        if ('stakeKeyHash' in certificate)
            return stakeKeyHashes.includes(certificate.stakeKeyHash);
        if ('rewardAccount' in certificate)
            return rewardAccounts.includes(certificate.rewardAccount);
        if ('poolParameters' in certificate)
            return rewardAccounts.includes(certificate.poolParameters.rewardAccount);
        return false;
    });
};
export const sentInspector = ({ addresses, rewardAccounts }) => (tx) => ({
    certificates: rewardAccounts?.length ? signedCertificatesInspector(rewardAccounts)(tx) : [],
    inputs: addresses?.length ? inputsWithAddresses(tx, addresses) : []
});
export const valueSentInspector = (ownAddresses, historicalTxs) => (tx) => {
    let assets = new Map();
    if (sentInspector({ addresses: ownAddresses })(tx).inputs.length === 0)
        return { coins: 0n };
    const totalOutputValue = totalAddressOutputsValueInspector(ownAddresses)(tx);
    const totalInputValue = totalAddressInputsValueInspector(ownAddresses, historicalTxs)(tx);
    const diff = subtractValueQuantities([totalInputValue, totalOutputValue]);
    if (diff.assets)
        assets = removeNegativesFromTokenMap(diff.assets);
    return {
        assets: assets.size > 0 ? assets : undefined,
        coins: diff.coins < 0n ? 0n : diff.coins
    };
};
export const valueReceivedInspector = (ownAddresses, historicalTxs) => (tx) => {
    let assets = new Map();
    const totalOutputValue = totalAddressOutputsValueInspector(ownAddresses)(tx);
    const totalInputValue = totalAddressInputsValueInspector(ownAddresses, historicalTxs)(tx);
    const diff = subtractValueQuantities([totalOutputValue, totalInputValue]);
    if (diff.assets)
        assets = removeNegativesFromTokenMap(diff.assets);
    return {
        assets: assets.size > 0 ? assets : undefined,
        coins: diff.coins < 0n ? 0n : diff.coins
    };
};
const certificateInspector = (type) => (tx) => tx.body.certificates?.filter((cert) => cert.__typename === type) ?? [];
export const delegationInspector = certificateInspector(CertificateType.StakeDelegation);
export const stakeKeyDeregistrationInspector = certificateInspector(CertificateType.StakeKeyDeregistration);
export const stakeKeyRegistrationInspector = certificateInspector(CertificateType.StakeKeyRegistration);
export const poolRegistrationInspector = certificateInspector(CertificateType.PoolRegistration);
export const poolRetirementInspector = certificateInspector(CertificateType.PoolRetirement);
export const withdrawalInspector = (tx) => tx.body.withdrawals?.length ? BigIntMath.sum(tx.body.withdrawals.map(({ quantity }) => quantity)) : 0n;
export const mintInspector = (matchQuantityCriteria) => (tx) => {
    const assets = [];
    const scriptMap = new Map();
    if (!tx.body.mint)
        return assets;
    const scripts = [...(tx.auxiliaryData?.body?.scripts || []), ...(tx.witness?.scripts || [])];
    for (const script of scripts) {
        switch (script.__type) {
            case ScriptType.Native: {
                const policyId = nativeScriptPolicyId(script);
                if (scriptMap.has(policyId))
                    continue;
                scriptMap.set(policyId, script);
                break;
            }
            case ScriptType.Plutus:
            default:
        }
    }
    for (const [key, value] of tx.body.mint.entries()) {
        const [policyId, assetName] = [policyIdFromAssetId(key), assetNameFromAssetId(key)];
        const mintedAsset = {
            assetName,
            fingerprint: AssetFingerprint.fromParts(policyId, assetName),
            policyId,
            quantity: value,
            script: scriptMap.get(policyId)
        };
        if (matchQuantityCriteria(mintedAsset.quantity))
            assets.push(mintedAsset);
    }
    return assets;
};
export const assetsMintedInspector = mintInspector((quantity) => quantity > 0);
export const assetsBurnedInspector = mintInspector((quantity) => quantity < 0);
export const metadataInspector = (tx) => tx.auxiliaryData?.body?.blob ?? new Map();
export const createTxInspector = (inspectors) => (tx) => Object.keys(inspectors).reduce((result, key) => {
    const inspector = inspectors[key];
    result[key] = inspector(tx);
    return result;
}, {});
//# sourceMappingURL=txInspector.js.map