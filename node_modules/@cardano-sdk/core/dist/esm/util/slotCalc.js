import { CustomError } from 'ts-custom-error';
import { EpochNo, Slot } from '../Cardano';
import groupBy from 'lodash/groupBy';
import last from 'lodash/last';
import memoize from 'lodash/memoize';
import orderBy from 'lodash/orderBy';
export class EraSummaryError extends CustomError {
}
const createSlotEpochCalcImpl = (eraSummaries) => {
    const eraSummariesWithoutSkippedEras = Object.values(groupBy(eraSummaries, 'start.slot')).map(last);
    const eraSummariesAsc = orderBy(eraSummariesWithoutSkippedEras, ({ start }) => start.slot);
    return (slotNo) => {
        const relevantEraSummariesAsc = orderBy(eraSummariesAsc.filter(({ start }) => start.slot <= slotNo), ({ start }) => start.slot);
        if (relevantEraSummariesAsc.length === 0) {
            throw new EraSummaryError(`No EraSummary for slot ${slotNo} found`);
        }
        let epochNo = 0;
        let currentEraSummary;
        for (let i = 0; i < relevantEraSummariesAsc.length; i++) {
            currentEraSummary = relevantEraSummariesAsc[i];
            const nextEraSummary = relevantEraSummariesAsc[i + 1];
            epochNo += Math.floor(((nextEraSummary?.start.slot || slotNo) - currentEraSummary.start.slot) /
                currentEraSummary.parameters.epochLength);
        }
        return { epochEraSummary: currentEraSummary, epochNo };
    };
};
export const createSlotEpochCalc = memoize((eraSummaries) => {
    const calc = createSlotEpochCalcImpl(eraSummaries);
    return (slotNo) => EpochNo(calc(slotNo).epochNo);
});
export const createSlotTimeCalc = (eraSummaries) => {
    const eraSummariesDesc = orderBy(eraSummaries, ({ start }) => start.slot, 'desc');
    return (slotNo) => {
        const activeEraSummary = eraSummariesDesc.find(({ start }) => start.slot <= slotNo);
        if (!activeEraSummary) {
            throw new EraSummaryError(`No EraSummary for slot ${slotNo} found`);
        }
        return new Date(activeEraSummary.start.time.getTime() +
            (slotNo - activeEraSummary.start.slot) * activeEraSummary.parameters.slotLength);
    };
};
export const createSlotEpochInfoCalc = (eraSummaries) => {
    const slotTimeCalc = createSlotTimeCalc(eraSummaries);
    const epochCalc = createSlotEpochCalcImpl(eraSummaries);
    return (slot) => {
        const { epochNo, epochEraSummary } = epochCalc(slot);
        const firstSlot = epochEraSummary.start.slot +
            Math.floor((slot - epochEraSummary.start.slot) / epochEraSummary.parameters.epochLength) *
                epochEraSummary.parameters.epochLength;
        const lastSlot = firstSlot + epochEraSummary.parameters.epochLength - 1;
        return {
            epochNo: EpochNo(epochNo),
            firstSlot: {
                date: slotTimeCalc(Slot(firstSlot)),
                slot: Slot(firstSlot)
            },
            lastSlot: {
                date: slotTimeCalc(Slot(lastSlot)),
                slot: Slot(lastSlot)
            }
        };
    };
};
//# sourceMappingURL=slotCalc.js.map