{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QueryClient = void 0;\n/* eslint-disable no-dupe-class-members, @typescript-eslint/ban-types, @typescript-eslint/naming-convention */\nconst ics23_1 = require(\"@confio/ics23\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst stream_1 = require(\"@cosmjs/stream\");\nconst utils_1 = require(\"@cosmjs/utils\");\nfunction checkAndParseOp(op, kind, key) {\n  if (op.type !== kind) {\n    throw new Error(\"Op expected to be \".concat(kind, \", got \\\"\").concat(op.type));\n  }\n  if (!(0, utils_1.arrayContentEquals)(key, op.key)) {\n    throw new Error(\"Proven key different than queried key.\\nQuery: \".concat((0, encoding_1.toHex)(key), \"\\nProven: \").concat((0, encoding_1.toHex)(op.key)));\n  }\n  return ics23_1.ics23.CommitmentProof.decode(op.data);\n}\nclass QueryClient {\n  constructor(tmClient) {\n    this.tmClient = tmClient;\n  }\n  static withExtensions(tmClient) {\n    const client = new QueryClient(tmClient);\n    for (var _len = arguments.length, extensionSetups = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      extensionSetups[_key - 1] = arguments[_key];\n    }\n    const extensions = extensionSetups.map(setupExtension => setupExtension(client));\n    for (const extension of extensions) {\n      (0, utils_1.assert)((0, utils_1.isNonNullObject)(extension), \"Extension must be a non-null object\");\n      for (const [moduleKey, moduleValue] of Object.entries(extension)) {\n        (0, utils_1.assert)((0, utils_1.isNonNullObject)(moduleValue), \"Module must be a non-null object. Found type \".concat(typeof moduleValue, \" for module \\\"\").concat(moduleKey, \"\\\".\"));\n        const current = client[moduleKey] || {};\n        client[moduleKey] = {\n          ...current,\n          ...moduleValue\n        };\n      }\n    }\n    return client;\n  }\n  /**\n   * @deprecated use queryStoreVerified instead\n   */\n  async queryVerified(store, queryKey, desiredHeight) {\n    const {\n      value\n    } = await this.queryStoreVerified(store, queryKey, desiredHeight);\n    return value;\n  }\n  /**\n   * Queries the database store with a proof, which is then verified.\n   *\n   * Please note: the current implementation trusts block headers it gets from the PRC endpoint.\n   */\n  async queryStoreVerified(store, queryKey, desiredHeight) {\n    const {\n      height,\n      proof,\n      key,\n      value\n    } = await this.queryRawProof(store, queryKey, desiredHeight);\n    const subProof = checkAndParseOp(proof.ops[0], \"ics23:iavl\", queryKey);\n    const storeProof = checkAndParseOp(proof.ops[1], \"ics23:simple\", (0, encoding_1.toAscii)(store));\n    // this must always be existence, if the store is not a typo\n    (0, utils_1.assert)(storeProof.exist);\n    (0, utils_1.assert)(storeProof.exist.value);\n    // this may be exist or non-exist, depends on response\n    if (!value || value.length === 0) {\n      // non-existence check\n      (0, utils_1.assert)(subProof.nonexist);\n      // the subproof must map the desired key to the \"value\" of the storeProof\n      (0, ics23_1.verifyNonExistence)(subProof.nonexist, ics23_1.iavlSpec, storeProof.exist.value, queryKey);\n    } else {\n      // existence check\n      (0, utils_1.assert)(subProof.exist);\n      (0, utils_1.assert)(subProof.exist.value);\n      // the subproof must map the desired key to the \"value\" of the storeProof\n      (0, ics23_1.verifyExistence)(subProof.exist, ics23_1.iavlSpec, storeProof.exist.value, queryKey, value);\n    }\n    // the store proof must map its declared value (root of subProof) to the appHash of the next block\n    const header = await this.getNextHeader(height);\n    (0, ics23_1.verifyExistence)(storeProof.exist, ics23_1.tendermintSpec, header.appHash, (0, encoding_1.toAscii)(store), storeProof.exist.value);\n    return {\n      key,\n      value,\n      height\n    };\n  }\n  async queryRawProof(store, queryKey, desiredHeight) {\n    var _a;\n    const {\n      key,\n      value,\n      height,\n      proof,\n      code,\n      log\n    } = await this.tmClient.abciQuery({\n      // we need the StoreKey for the module, not the module name\n      // https://github.com/cosmos/cosmos-sdk/blob/8cab43c8120fec5200c3459cbf4a92017bb6f287/x/auth/types/keys.go#L12\n      path: \"/store/\".concat(store, \"/key\"),\n      data: queryKey,\n      prove: true,\n      height: desiredHeight\n    });\n    if (code) {\n      throw new Error(\"Query failed with (\".concat(code, \"): \").concat(log));\n    }\n    if (!(0, utils_1.arrayContentEquals)(queryKey, key)) {\n      throw new Error(\"Response key \".concat((0, encoding_1.toHex)(key), \" doesn't match query key \").concat((0, encoding_1.toHex)(queryKey)));\n    }\n    if (!height) {\n      throw new Error(\"No query height returned\");\n    }\n    if (!proof || proof.ops.length !== 2) {\n      throw new Error(\"Expected 2 proof ops, got \".concat((_a = proof === null || proof === void 0 ? void 0 : proof.ops.length) !== null && _a !== void 0 ? _a : 0, \". Are you using stargate?\"));\n    }\n    // we don't need the results, but we can ensure the data is the proper format\n    checkAndParseOp(proof.ops[0], \"ics23:iavl\", key);\n    checkAndParseOp(proof.ops[1], \"ics23:simple\", (0, encoding_1.toAscii)(store));\n    return {\n      key: key,\n      value: value,\n      height: height,\n      // need to clone this: readonly input / writeable output\n      proof: {\n        ops: [...proof.ops]\n      }\n    };\n  }\n  /**\n   * Performs an ABCI query to Tendermint without requesting a proof.\n   *\n   * @deprecated use queryAbci instead\n   */\n  async queryUnverified(path, request, desiredHeight) {\n    const response = await this.queryAbci(path, request, desiredHeight);\n    return response.value;\n  }\n  /**\n   * Performs an ABCI query to Tendermint without requesting a proof.\n   *\n   * If the `desiredHeight` is set, a particular height is requested. Otherwise\n   * the latest height is requested. The response contains the actual height of\n   * the query.\n   */\n  async queryAbci(path, request, desiredHeight) {\n    const response = await this.tmClient.abciQuery({\n      path: path,\n      data: request,\n      prove: false,\n      height: desiredHeight\n    });\n    if (response.code) {\n      throw new Error(\"Query failed with (\".concat(response.code, \"): \").concat(response.log));\n    }\n    if (!response.height) {\n      throw new Error(\"No query height returned\");\n    }\n    return {\n      value: response.value,\n      height: response.height\n    };\n  }\n  // this must return the header for height+1\n  // throws an error if height is 0 or undefined\n  async getNextHeader(height) {\n    (0, utils_1.assertDefined)(height);\n    if (height === 0) {\n      throw new Error(\"Query returned height 0, cannot prove it\");\n    }\n    const searchHeight = height + 1;\n    let nextHeader;\n    let headersSubscription;\n    try {\n      headersSubscription = this.tmClient.subscribeNewBlockHeader();\n    } catch (_a) {\n      // Ignore exception caused by non-WebSocket Tendermint clients\n    }\n    if (headersSubscription) {\n      const firstHeader = await (0, stream_1.firstEvent)(headersSubscription);\n      // The first header we get might not be n+1 but n+2 or even higher. In such cases we fall back on a query.\n      if (firstHeader.height === searchHeight) {\n        nextHeader = firstHeader;\n      }\n    }\n    while (!nextHeader) {\n      // start from current height to avoid backend error for minHeight in the future\n      const correctHeader = (await this.tmClient.blockchain(height, searchHeight)).blockMetas.map(meta => meta.header).find(h => h.height === searchHeight);\n      if (correctHeader) {\n        nextHeader = correctHeader;\n      } else {\n        await (0, utils_1.sleep)(1000);\n      }\n    }\n    (0, utils_1.assert)(nextHeader.height === searchHeight, \"Got wrong header. This is a bug in the logic above.\");\n    return nextHeader;\n  }\n}\nexports.QueryClient = QueryClient;","map":{"version":3,"names":["ics23_1","require","encoding_1","stream_1","utils_1","checkAndParseOp","op","kind","key","type","Error","concat","arrayContentEquals","toHex","ics23","CommitmentProof","decode","data","QueryClient","constructor","tmClient","withExtensions","client","_len","arguments","length","extensionSetups","Array","_key","extensions","map","setupExtension","extension","assert","isNonNullObject","moduleKey","moduleValue","Object","entries","current","queryVerified","store","queryKey","desiredHeight","value","queryStoreVerified","height","proof","queryRawProof","subProof","ops","storeProof","toAscii","exist","nonexist","verifyNonExistence","iavlSpec","verifyExistence","header","getNextHeader","tendermintSpec","appHash","code","log","abciQuery","path","prove","_a","queryUnverified","request","response","queryAbci","assertDefined","searchHeight","nextHeader","headersSubscription","subscribeNewBlockHeader","firstHeader","firstEvent","correctHeader","blockchain","blockMetas","meta","find","h","sleep","exports"],"sources":["../../src/queryclient/queryclient.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}