{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.tweakKey = exports.tapTweakHash = exports.tapleafHash = exports.findScriptPath = exports.toHashTree = exports.rootHashFromPath = exports.MAX_TAPTREE_DEPTH = exports.LEAF_VERSION_TAPSCRIPT = void 0;\nconst buffer_1 = require('buffer');\nconst ecc_lib_1 = require('../ecc_lib');\nconst bcrypto = require('../crypto');\nconst bufferutils_1 = require('../bufferutils');\nconst types_1 = require('../types');\nexports.LEAF_VERSION_TAPSCRIPT = 0xc0;\nexports.MAX_TAPTREE_DEPTH = 128;\nconst isHashBranch = ht => 'left' in ht && 'right' in ht;\nfunction rootHashFromPath(controlBlock, leafHash) {\n  if (controlBlock.length < 33) throw new TypeError(\"The control-block length is too small. Got \".concat(controlBlock.length, \", expected min 33.\"));\n  const m = (controlBlock.length - 33) / 32;\n  let kj = leafHash;\n  for (let j = 0; j < m; j++) {\n    const ej = controlBlock.slice(33 + 32 * j, 65 + 32 * j);\n    if (kj.compare(ej) < 0) {\n      kj = tapBranchHash(kj, ej);\n    } else {\n      kj = tapBranchHash(ej, kj);\n    }\n  }\n  return kj;\n}\nexports.rootHashFromPath = rootHashFromPath;\n/**\n * Build a hash tree of merkle nodes from the scripts binary tree.\n * @param scriptTree - the tree of scripts to pairwise hash.\n */\nfunction toHashTree(scriptTree) {\n  if ((0, types_1.isTapleaf)(scriptTree)) return {\n    hash: tapleafHash(scriptTree)\n  };\n  const hashes = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];\n  hashes.sort((a, b) => a.hash.compare(b.hash));\n  const [left, right] = hashes;\n  return {\n    hash: tapBranchHash(left.hash, right.hash),\n    left,\n    right\n  };\n}\nexports.toHashTree = toHashTree;\n/**\n * Given a HashTree, finds the path from a particular hash to the root.\n * @param node - the root of the tree\n * @param hash - the hash to search for\n * @returns - array of sibling hashes, from leaf (inclusive) to root\n * (exclusive) needed to prove inclusion of the specified hash. undefined if no\n * path is found\n */\nfunction findScriptPath(node, hash) {\n  if (isHashBranch(node)) {\n    const leftPath = findScriptPath(node.left, hash);\n    if (leftPath !== undefined) return [...leftPath, node.right.hash];\n    const rightPath = findScriptPath(node.right, hash);\n    if (rightPath !== undefined) return [...rightPath, node.left.hash];\n  } else if (node.hash.equals(hash)) {\n    return [];\n  }\n  return undefined;\n}\nexports.findScriptPath = findScriptPath;\nfunction tapleafHash(leaf) {\n  const version = leaf.version || exports.LEAF_VERSION_TAPSCRIPT;\n  return bcrypto.taggedHash('TapLeaf', buffer_1.Buffer.concat([buffer_1.Buffer.from([version]), serializeScript(leaf.output)]));\n}\nexports.tapleafHash = tapleafHash;\nfunction tapTweakHash(pubKey, h) {\n  return bcrypto.taggedHash('TapTweak', buffer_1.Buffer.concat(h ? [pubKey, h] : [pubKey]));\n}\nexports.tapTweakHash = tapTweakHash;\nfunction tweakKey(pubKey, h) {\n  if (!buffer_1.Buffer.isBuffer(pubKey)) return null;\n  if (pubKey.length !== 32) return null;\n  if (h && h.length !== 32) return null;\n  const tweakHash = tapTweakHash(pubKey, h);\n  const res = (0, ecc_lib_1.getEccLib)().xOnlyPointAddTweak(pubKey, tweakHash);\n  if (!res || res.xOnlyPubkey === null) return null;\n  return {\n    parity: res.parity,\n    x: buffer_1.Buffer.from(res.xOnlyPubkey)\n  };\n}\nexports.tweakKey = tweakKey;\nfunction tapBranchHash(a, b) {\n  return bcrypto.taggedHash('TapBranch', buffer_1.Buffer.concat([a, b]));\n}\nfunction serializeScript(s) {\n  const varintLen = bufferutils_1.varuint.encodingLength(s.length);\n  const buffer = buffer_1.Buffer.allocUnsafe(varintLen); // better\n  bufferutils_1.varuint.encode(s.length, buffer);\n  return buffer_1.Buffer.concat([buffer, s]);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","tweakKey","tapTweakHash","tapleafHash","findScriptPath","toHashTree","rootHashFromPath","MAX_TAPTREE_DEPTH","LEAF_VERSION_TAPSCRIPT","buffer_1","require","ecc_lib_1","bcrypto","bufferutils_1","types_1","isHashBranch","ht","controlBlock","leafHash","length","TypeError","concat","m","kj","j","ej","slice","compare","tapBranchHash","scriptTree","isTapleaf","hash","hashes","sort","a","b","left","right","node","leftPath","undefined","rightPath","equals","leaf","version","taggedHash","Buffer","from","serializeScript","output","pubKey","h","isBuffer","tweakHash","res","getEccLib","xOnlyPointAddTweak","xOnlyPubkey","parity","x","s","varintLen","varuint","encodingLength","buffer","allocUnsafe","encode"],"sources":["/workspace/Planq-Dapps/vesting-portal/node_modules/bitcoinjs-lib/src/payments/bip341.js"],"sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.tweakKey =\n  exports.tapTweakHash =\n  exports.tapleafHash =\n  exports.findScriptPath =\n  exports.toHashTree =\n  exports.rootHashFromPath =\n  exports.MAX_TAPTREE_DEPTH =\n  exports.LEAF_VERSION_TAPSCRIPT =\n    void 0;\nconst buffer_1 = require('buffer');\nconst ecc_lib_1 = require('../ecc_lib');\nconst bcrypto = require('../crypto');\nconst bufferutils_1 = require('../bufferutils');\nconst types_1 = require('../types');\nexports.LEAF_VERSION_TAPSCRIPT = 0xc0;\nexports.MAX_TAPTREE_DEPTH = 128;\nconst isHashBranch = ht => 'left' in ht && 'right' in ht;\nfunction rootHashFromPath(controlBlock, leafHash) {\n  if (controlBlock.length < 33)\n    throw new TypeError(\n      `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,\n    );\n  const m = (controlBlock.length - 33) / 32;\n  let kj = leafHash;\n  for (let j = 0; j < m; j++) {\n    const ej = controlBlock.slice(33 + 32 * j, 65 + 32 * j);\n    if (kj.compare(ej) < 0) {\n      kj = tapBranchHash(kj, ej);\n    } else {\n      kj = tapBranchHash(ej, kj);\n    }\n  }\n  return kj;\n}\nexports.rootHashFromPath = rootHashFromPath;\n/**\n * Build a hash tree of merkle nodes from the scripts binary tree.\n * @param scriptTree - the tree of scripts to pairwise hash.\n */\nfunction toHashTree(scriptTree) {\n  if ((0, types_1.isTapleaf)(scriptTree))\n    return { hash: tapleafHash(scriptTree) };\n  const hashes = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];\n  hashes.sort((a, b) => a.hash.compare(b.hash));\n  const [left, right] = hashes;\n  return {\n    hash: tapBranchHash(left.hash, right.hash),\n    left,\n    right,\n  };\n}\nexports.toHashTree = toHashTree;\n/**\n * Given a HashTree, finds the path from a particular hash to the root.\n * @param node - the root of the tree\n * @param hash - the hash to search for\n * @returns - array of sibling hashes, from leaf (inclusive) to root\n * (exclusive) needed to prove inclusion of the specified hash. undefined if no\n * path is found\n */\nfunction findScriptPath(node, hash) {\n  if (isHashBranch(node)) {\n    const leftPath = findScriptPath(node.left, hash);\n    if (leftPath !== undefined) return [...leftPath, node.right.hash];\n    const rightPath = findScriptPath(node.right, hash);\n    if (rightPath !== undefined) return [...rightPath, node.left.hash];\n  } else if (node.hash.equals(hash)) {\n    return [];\n  }\n  return undefined;\n}\nexports.findScriptPath = findScriptPath;\nfunction tapleafHash(leaf) {\n  const version = leaf.version || exports.LEAF_VERSION_TAPSCRIPT;\n  return bcrypto.taggedHash(\n    'TapLeaf',\n    buffer_1.Buffer.concat([\n      buffer_1.Buffer.from([version]),\n      serializeScript(leaf.output),\n    ]),\n  );\n}\nexports.tapleafHash = tapleafHash;\nfunction tapTweakHash(pubKey, h) {\n  return bcrypto.taggedHash(\n    'TapTweak',\n    buffer_1.Buffer.concat(h ? [pubKey, h] : [pubKey]),\n  );\n}\nexports.tapTweakHash = tapTweakHash;\nfunction tweakKey(pubKey, h) {\n  if (!buffer_1.Buffer.isBuffer(pubKey)) return null;\n  if (pubKey.length !== 32) return null;\n  if (h && h.length !== 32) return null;\n  const tweakHash = tapTweakHash(pubKey, h);\n  const res = (0, ecc_lib_1.getEccLib)().xOnlyPointAddTweak(pubKey, tweakHash);\n  if (!res || res.xOnlyPubkey === null) return null;\n  return {\n    parity: res.parity,\n    x: buffer_1.Buffer.from(res.xOnlyPubkey),\n  };\n}\nexports.tweakKey = tweakKey;\nfunction tapBranchHash(a, b) {\n  return bcrypto.taggedHash('TapBranch', buffer_1.Buffer.concat([a, b]));\n}\nfunction serializeScript(s) {\n  const varintLen = bufferutils_1.varuint.encodingLength(s.length);\n  const buffer = buffer_1.Buffer.allocUnsafe(varintLen); // better\n  bufferutils_1.varuint.encode(s.length, buffer);\n  return buffer_1.Buffer.concat([buffer, s]);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}