{"ast":null,"code":"\"use strict\";\n\nvar Buffer = require('safe-buffer').Buffer;\nvar jsSHA = require('jssha');\nvar createKeccakHash = require('keccak');\nvar secp256k1 = require('secp256k1');\nvar crypto = require('crypto');\nvar scrypt = require('scryptsy');\nvar RIPEMD160 = require('ripemd160');\nvar uuid = require('uuid');\nvar utils = require('./utils.js');\nvar keccak = function (a, bits) {\n  a = toBuffer(a);\n  if (!bits) bits = 256;\n  return createKeccakHash('keccak' + bits).update(a).digest();\n};\nvar sha3 = function () {\n  var shaObj = new jsSHA(\"SHA3-256\", \"HEX\");\n  for (var i = 0; i < arguments.length; i++) {\n    var v = toBuffer(arguments[i]);\n    shaObj.update(v.toString(\"hex\"));\n  }\n  return Buffer.from(shaObj.getHash(\"HEX\"), \"hex\");\n};\nvar ripemd160 = function () {\n  var ripemd160stream = new RIPEMD160();\n  for (var i = 0; i < arguments.length; i++) {\n    var v = toBuffer(arguments[i]);\n    ripemd160stream.update(v);\n  }\n  return ripemd160stream.digest();\n};\n\n// check if hex string\nvar isHexPrefixed = function (str) {\n  if (typeof str !== 'string') {\n    throw new Error(\"[is-hex-prefixed] value must be type 'string', is currently type \" + typeof str + \", while checking isHexPrefixed.\");\n  }\n  return str.slice(0, 2) === '0x';\n};\n\n// returns hex string without 0x\nvar stripHexPrefix = function (str) {\n  if (typeof str !== 'string') {\n    return str;\n  }\n  return isHexPrefixed(str) ? str.slice(2) : str;\n};\nfunction isHexString(value, length) {\n  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n  if (length && value.length !== 2 + 2 * length) {\n    return false;\n  }\n  return true;\n}\n\n// returns hex string from int\nfunction intToHex(i) {\n  var hex = i.toString(16); // eslint-disable-line\n\n  return '0x' + padToEven(hex);\n}\n\n// returns buffer from int\nfunction intToBuffer(i) {\n  var hex = intToHex(i);\n  return new Buffer(hex.slice(2), 'hex');\n}\n\n// returns a buffer filled with 0\nvar zeros = function (bytes) {\n  return Buffer.allocUnsafe(bytes).fill(0);\n};\nvar padToEven = function (value) {\n  var a = value; // eslint-disable-line\n\n  if (typeof a !== 'string') {\n    throw new Error('padToEven only support string');\n  }\n  if (a.length % 2) {\n    a = '0' + a;\n  }\n  return a;\n};\n\n// convert value to digit/8 buffer with BigEndian.\nvar padToBigEndian = function (value, digit) {\n  value = toBuffer(value);\n  var buff = Buffer.alloc(digit / 8);\n  for (var i = 0; i < value.length; i++) {\n    var start = buff.length - value.length + i;\n    if (start >= 0) {\n      buff[start] = value[i];\n    }\n  }\n  return buff;\n};\n\n// attempts to turn a value to buffer, the input can be buffer, string,number\nvar toBuffer = function (v) {\n  /*jshint maxcomplexity:13 */\n  if (!Buffer.isBuffer(v)) {\n    if (Array.isArray(v)) {\n      v = Buffer.from(v);\n    } else if (typeof v === 'string') {\n      if (isHexString(v)) {\n        v = Buffer.from(padToEven(stripHexPrefix(v)), 'hex');\n      } else {\n        v = Buffer.from(v);\n      }\n    } else if (typeof v === 'number') {\n      v = intToBuffer(v);\n    } else if (v === null || v === undefined) {\n      v = Buffer.allocUnsafe(0);\n    } else if (utils.isBigNumber(v)) {\n      // TODO: neb number is a big int, not support if v is decimal, later fix it.\n      v = Buffer.from(padToEven(v.toString(16)), 'hex');\n    } else if (v.toArray) {\n      v = Buffer.from(v.toArray());\n    } else if (v.subarray) {\n      v = Buffer.from(v);\n    } else if (v === null || typeof v === \"undefined\") {\n      v = Buffer.allocUnsafe(0);\n    } else {\n      throw new Error('invalid type');\n    }\n  }\n  return v;\n};\nvar bufferToHex = function (buf) {\n  buf = toBuffer(buf);\n  return '0x' + buf.toString('hex');\n};\n\n// convert secp256k1 private key to public key\nvar privateToPublic = function (privateKey) {\n  privateKey = toBuffer(privateKey);\n  // skip the type flag and use the X, Y points\n  return secp256k1.publicKeyCreate(privateKey, false).slice(1);\n};\nvar isValidPublic = function (publicKey, sanitize) {\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n  }\n  if (!sanitize) {\n    return false;\n  }\n  return secp256k1.publicKeyVerify(publicKey);\n};\n\n// sign transaction hash\nvar sign = function (msgHash, privateKey) {\n  var sig = secp256k1.sign(toBuffer(msgHash), toBuffer(privateKey));\n  // var ret = {}\n  // ret.r = sig.signature.slice(0, 32)\n  // ret.s = sig.signature.slice(32, 64)\n  // ret.v = sig.recovery\n  return Buffer.concat([toBuffer(sig.signature), toBuffer(sig.recovery)]);\n};\nvar verify = function (message, signature, publicKey) {\n  signature = signature.slice(0, -1); //remove the sig.recovery byte\n  publicKey = Buffer.concat([toBuffer([0x04]), toBuffer(publicKey)]); //add 0x04 before publicKey\n  return secp256k1.verify(toBuffer(message), toBuffer(signature), toBuffer(publicKey));\n};\nvar recover = function (message, signature, recovery, compressed) {\n  return secp256k1.recover(toBuffer(message), toBuffer(signature), recovery, compressed);\n};\nmodule.exports = {\n  secp256k1: secp256k1,\n  keccak: keccak,\n  sha3: sha3,\n  ripemd160: ripemd160,\n  crypto: crypto,\n  scrypt: scrypt,\n  uuid: uuid,\n  zeros: zeros,\n  isHexPrefixed: isHexPrefixed,\n  padToBigEndian: padToBigEndian,\n  toBuffer: toBuffer,\n  bufferToHex: bufferToHex,\n  privateToPublic: privateToPublic,\n  isValidPublic: isValidPublic,\n  sign: sign,\n  verify: verify,\n  recover: recover\n};","map":{"version":3,"names":["Buffer","require","jsSHA","createKeccakHash","secp256k1","crypto","scrypt","RIPEMD160","uuid","utils","keccak","a","bits","toBuffer","update","digest","sha3","shaObj","i","arguments","length","v","toString","from","getHash","ripemd160","ripemd160stream","isHexPrefixed","str","Error","slice","stripHexPrefix","isHexString","value","match","intToHex","hex","padToEven","intToBuffer","zeros","bytes","allocUnsafe","fill","padToBigEndian","digit","buff","alloc","start","isBuffer","Array","isArray","undefined","isBigNumber","toArray","subarray","bufferToHex","buf","privateToPublic","privateKey","publicKeyCreate","isValidPublic","publicKey","sanitize","publicKeyVerify","concat","sign","msgHash","sig","signature","recovery","verify","message","recover","compressed","module","exports"],"sources":["/workspace/Planq-Dapps/vesting-portal/node_modules/nebulas/lib/utils/crypto-utils.js"],"sourcesContent":["\n\"use strict\";\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar jsSHA = require('jssha');\nvar createKeccakHash = require('keccak');\nvar secp256k1 = require('secp256k1');\nvar crypto = require('crypto');\nvar scrypt = require('scryptsy');\nvar RIPEMD160 = require('ripemd160');\n\nvar uuid = require('uuid');\n\nvar utils = require('./utils.js');\n\nvar keccak = function (a, bits) {\n    a = toBuffer(a);\n    if (!bits) bits = 256;\n\n    return createKeccakHash('keccak' + bits).update(a).digest();\n};\n\nvar sha3 = function () {\n    var shaObj = new jsSHA(\"SHA3-256\", \"HEX\");\n    for (var i = 0; i < arguments.length; i++) {\n        var v = toBuffer(arguments[i]);\n        shaObj.update(v.toString(\"hex\"));\n    }\n    return Buffer.from(shaObj.getHash(\"HEX\"), \"hex\");\n};\n\nvar ripemd160 = function () {\n    var ripemd160stream = new RIPEMD160();\n    for (var i = 0; i < arguments.length; i++) {\n        var v = toBuffer(arguments[i]);\n        ripemd160stream.update(v);\n    }\n    return ripemd160stream.digest();\n};\n\n// check if hex string\nvar isHexPrefixed = function (str) {\n    if (typeof str !== 'string') {\n        throw new Error(\"[is-hex-prefixed] value must be type 'string', is currently type \" + (typeof str) + \", while checking isHexPrefixed.\");\n    }\n\n    return str.slice(0, 2) === '0x';\n};\n\n// returns hex string without 0x\nvar stripHexPrefix = function (str) {\n    if (typeof str !== 'string') {\n        return str;\n    }\n    return isHexPrefixed(str) ? str.slice(2) : str;\n};\n\nfunction isHexString(value, length) {\n    if (typeof(value) !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n\n    if (length && value.length !== 2 + 2 * length) { return false; }\n\n    return true;\n}\n\n// returns hex string from int\nfunction intToHex(i) {\n    var hex = i.toString(16); // eslint-disable-line\n\n    return '0x' + padToEven(hex);\n}\n\n// returns buffer from int\nfunction intToBuffer(i) {\n    var hex = intToHex(i);\n\n    return new Buffer(hex.slice(2), 'hex');\n}\n\n// returns a buffer filled with 0\nvar zeros = function (bytes) {\n    return Buffer.allocUnsafe(bytes).fill(0);\n};\n\nvar padToEven = function (value) {\n    var a = value; // eslint-disable-line\n\n    if (typeof a !== 'string') {\n        throw new Error('padToEven only support string');\n    }\n\n    if (a.length % 2) {\n        a = '0' + a;\n    }\n\n    return a;\n};\n\n// convert value to digit/8 buffer with BigEndian.\nvar padToBigEndian = function (value, digit) {\n    value = toBuffer(value);\n    var buff = Buffer.alloc(digit/8);\n    for (var i = 0; i < value.length; i++) {\n        var start = buff.length - value.length + i;\n        if ( start >= 0) {\n            buff[start] = value[i];\n        }\n    }\n    return buff;\n};\n\n// attempts to turn a value to buffer, the input can be buffer, string,number\nvar toBuffer = function (v) {\n    /*jshint maxcomplexity:13 */\n    if (!Buffer.isBuffer(v)) {\n        if (Array.isArray(v)) {\n            v = Buffer.from(v);\n        } else if (typeof v === 'string') {\n            if (isHexString(v)) {\n                v = Buffer.from(padToEven(stripHexPrefix(v)), 'hex');\n            } else {\n                v = Buffer.from(v);\n            }\n        } else if (typeof v === 'number') {\n            v = intToBuffer(v);\n        } else if (v === null || v === undefined) {\n            v = Buffer.allocUnsafe(0);\n        } else if (utils.isBigNumber(v)) {\n            // TODO: neb number is a big int, not support if v is decimal, later fix it.\n            v = Buffer.from(padToEven(v.toString(16)), 'hex');\n        } else if (v.toArray) {\n            v = Buffer.from(v.toArray());\n        } else if (v.subarray) {\n            v = Buffer.from(v);\n        } else if (v === null || typeof v === \"undefined\") {\n            v = Buffer.allocUnsafe(0);\n        } else {\n            throw new Error('invalid type');\n        }\n    }\n    return v;\n};\n\nvar bufferToHex = function (buf) {\n    buf = toBuffer(buf);\n    return '0x' + buf.toString('hex');\n};\n\n// convert secp256k1 private key to public key\nvar privateToPublic = function (privateKey) {\n    privateKey = toBuffer(privateKey);\n    // skip the type flag and use the X, Y points\n    return secp256k1.publicKeyCreate(privateKey, false).slice(1);\n};\n\nvar isValidPublic = function (publicKey, sanitize) {\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        return secp256k1.publicKeyVerify(Buffer.concat([ Buffer.from([4]), publicKey ]));\n    }\n\n    if (!sanitize) {\n        return false;\n    }\n\n    return secp256k1.publicKeyVerify(publicKey);\n};\n\n// sign transaction hash\nvar sign = function (msgHash, privateKey) {\n\n    var sig = secp256k1.sign(toBuffer(msgHash), toBuffer(privateKey));\n    // var ret = {}\n    // ret.r = sig.signature.slice(0, 32)\n    // ret.s = sig.signature.slice(32, 64)\n    // ret.v = sig.recovery\n    return Buffer.concat([toBuffer(sig.signature), toBuffer(sig.recovery)]);\n};\n\nvar verify = function (message, signature, publicKey) {\n    signature = signature.slice(0,-1);  //remove the sig.recovery byte\n    publicKey = Buffer.concat([toBuffer([0x04]), toBuffer(publicKey)]);  //add 0x04 before publicKey\n    return secp256k1.verify(toBuffer(message), toBuffer(signature), toBuffer(publicKey));\n};\n\nvar recover = function(message, signature, recovery, compressed) {\n    return secp256k1.recover(toBuffer(message), toBuffer(signature), recovery, compressed);\n};\n\nmodule.exports = {\n    secp256k1: secp256k1,\n    keccak: keccak,\n    sha3: sha3,\n    ripemd160: ripemd160,\n    crypto: crypto,\n    scrypt: scrypt,\n    uuid: uuid,\n\n    zeros: zeros,\n    isHexPrefixed: isHexPrefixed,\n    padToBigEndian: padToBigEndian,\n    toBuffer: toBuffer,\n    bufferToHex: bufferToHex,\n    privateToPublic: privateToPublic,\n    isValidPublic: isValidPublic,\n    sign: sign,\n    verify: verify,\n    recover: recover\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}