{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConnectedWalletAccount = exports.WalletAccount = exports.WalletConnection = void 0;\n/**\n * The classes in this module are used in conjunction with the {@link BrowserLocalStorageKeyStore}. This module exposes two classes:\n * * {@link WalletConnection} which redirects users to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for key management.\n * * {@link ConnectedWalletAccount} is an {@link Account} implementation that uses {@link WalletConnection} to get keys\n *\n * @module walletAccount\n */\nconst depd_1 = __importDefault(require(\"depd\"));\nconst account_1 = require(\"./account\");\nconst transaction_1 = require(\"./transaction\");\nconst utils_1 = require(\"./utils\");\nconst borsh_1 = require(\"borsh\");\nconst borsh_2 = require(\"borsh\");\nconst LOGIN_WALLET_URL_SUFFIX = '/login/';\nconst MULTISIG_HAS_METHOD = 'add_request_and_confirm';\nconst LOCAL_STORAGE_KEY_SUFFIX = '_wallet_auth_key';\nconst PENDING_ACCESS_KEY_PREFIX = 'pending_key'; // browser storage key for a pending access key (i.e. key has been generated but we are not sure it was added yet)\n/**\n * This class is used in conjunction with the {@link BrowserLocalStorageKeyStore}.\n * It redirects users to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for key management.\n *\n * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#wallet}\n * @example\n * ```js\n * // create new WalletConnection instance\n * const wallet = new WalletConnection(near, 'my-app');\n *\n * // If not signed in redirect to the NEAR wallet to sign in\n * // keys will be stored in the BrowserLocalStorageKeyStore\n * if(!wallet.isSingnedIn()) return wallet.requestSignIn()\n * ```\n */\nclass WalletConnection {\n  constructor(near, appKeyPrefix) {\n    this._near = near;\n    const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;\n    const authData = JSON.parse(window.localStorage.getItem(authDataKey));\n    this._networkId = near.config.networkId;\n    this._walletBaseUrl = near.config.walletUrl;\n    appKeyPrefix = appKeyPrefix || near.config.contractName || 'default';\n    this._keyStore = near.connection.signer.keyStore;\n    this._authData = authData || {\n      allKeys: []\n    };\n    this._authDataKey = authDataKey;\n    if (!this.isSignedIn()) {\n      this._completeSignInWithAccessKey();\n    }\n  }\n  /**\n   * Returns true, if this WalletAccount is authorized with the wallet.\n   * @example\n   * ```js\n   * const wallet = new WalletConnection(near, 'my-app');\n   * wallet.isSignedIn();\n   * ```\n   */\n  isSignedIn() {\n    return !!this._authData.accountId;\n  }\n  /**\n   * Returns authorized Account ID.\n   * @example\n   * ```js\n   * const wallet = new WalletConnection(near, 'my-app');\n   * wallet.getAccountId();\n   * ```\n   */\n  getAccountId() {\n    return this._authData.accountId || '';\n  }\n  /**\n   * Redirects current page to the wallet authentication page.\n   * @param options An optional options object\n   * @param options.contractId The NEAR account where the contract is deployed\n   * @param options.successUrl URL to redirect upon success. Default: current url\n   * @param options.failureUrl URL to redirect upon failure. Default: current url\n   *\n   * @example\n   * ```js\n   * const wallet = new WalletConnection(near, 'my-app');\n   * // redirects to the NEAR Wallet\n   * wallet.requestSignIn({ contractId: 'account-with-deploy-contract.near' });\n   * ```\n   */\n  async requestSignIn() {\n    let contractIdOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let title = arguments.length > 1 ? arguments[1] : undefined;\n    let successUrl = arguments.length > 2 ? arguments[2] : undefined;\n    let failureUrl = arguments.length > 3 ? arguments[3] : undefined;\n    let options;\n    if (typeof contractIdOrOptions === 'string') {\n      const deprecate = depd_1.default('requestSignIn(contractId, title)');\n      deprecate('`title` ignored; use `requestSignIn({ contractId, methodNames, successUrl, failureUrl })` instead');\n      options = {\n        contractId: contractIdOrOptions,\n        successUrl,\n        failureUrl\n      };\n    } else {\n      options = contractIdOrOptions;\n    }\n    const currentUrl = new URL(window.location.href);\n    const newUrl = new URL(this._walletBaseUrl + LOGIN_WALLET_URL_SUFFIX);\n    newUrl.searchParams.set('success_url', options.successUrl || currentUrl.href);\n    newUrl.searchParams.set('failure_url', options.failureUrl || currentUrl.href);\n    if (options.contractId) {\n      /* Throws exception if contract account does not exist */\n      const contractAccount = await this._near.account(options.contractId);\n      await contractAccount.state();\n      newUrl.searchParams.set('contract_id', options.contractId);\n      const accessKey = utils_1.KeyPair.fromRandom('ed25519');\n      newUrl.searchParams.set('public_key', accessKey.getPublicKey().toString());\n      await this._keyStore.setKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + accessKey.getPublicKey(), accessKey);\n    }\n    if (options.methodNames) {\n      options.methodNames.forEach(methodName => {\n        newUrl.searchParams.append('methodNames', methodName);\n      });\n    }\n    window.location.assign(newUrl.toString());\n  }\n  async requestSignTransactions() {\n    if (Array.isArray(arguments.length <= 0 ? undefined : arguments[0])) {\n      const deprecate = depd_1.default('WalletConnection.requestSignTransactions(transactions, callbackUrl, meta)');\n      deprecate('use `WalletConnection.requestSignTransactions(RequestSignTransactionsOptions)` instead');\n      return this._requestSignTransactions({\n        transactions: arguments.length <= 0 ? undefined : arguments[0],\n        callbackUrl: arguments.length <= 1 ? undefined : arguments[1],\n        meta: arguments.length <= 2 ? undefined : arguments[2]\n      });\n    }\n    return this._requestSignTransactions(arguments.length <= 0 ? undefined : arguments[0]);\n  }\n  async _requestSignTransactions(_ref) {\n    let {\n      transactions,\n      meta,\n      callbackUrl\n    } = _ref;\n    const currentUrl = new URL(window.location.href);\n    const newUrl = new URL('sign', this._walletBaseUrl);\n    newUrl.searchParams.set('transactions', transactions.map(transaction => borsh_2.serialize(transaction_1.SCHEMA, transaction)).map(serialized => Buffer.from(serialized).toString('base64')).join(','));\n    newUrl.searchParams.set('callbackUrl', callbackUrl || currentUrl.href);\n    if (meta) newUrl.searchParams.set('meta', meta);\n    window.location.assign(newUrl.toString());\n  }\n  /**\n   * @hidden\n   * Complete sign in for a given account id and public key. To be invoked by the app when getting a callback from the wallet.\n   */\n  async _completeSignInWithAccessKey() {\n    const currentUrl = new URL(window.location.href);\n    const publicKey = currentUrl.searchParams.get('public_key') || '';\n    const allKeys = (currentUrl.searchParams.get('all_keys') || '').split(',');\n    const accountId = currentUrl.searchParams.get('account_id') || '';\n    // TODO: Handle errors during login\n    if (accountId) {\n      this._authData = {\n        accountId,\n        allKeys\n      };\n      window.localStorage.setItem(this._authDataKey, JSON.stringify(this._authData));\n      if (publicKey) {\n        await this._moveKeyFromTempToPermanent(accountId, publicKey);\n      }\n    }\n    currentUrl.searchParams.delete('public_key');\n    currentUrl.searchParams.delete('all_keys');\n    currentUrl.searchParams.delete('account_id');\n    currentUrl.searchParams.delete('meta');\n    currentUrl.searchParams.delete('transactionHashes');\n    window.history.replaceState({}, document.title, currentUrl.toString());\n  }\n  /**\n   * @hidden\n   * @param accountId The NEAR account owning the given public key\n   * @param publicKey The public key being set to the key store\n   */\n  async _moveKeyFromTempToPermanent(accountId, publicKey) {\n    const keyPair = await this._keyStore.getKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n    await this._keyStore.setKey(this._networkId, accountId, keyPair);\n    await this._keyStore.removeKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n  }\n  /**\n   * Sign out from the current account\n   * @example\n   * walletAccount.signOut();\n   */\n  signOut() {\n    this._authData = {};\n    window.localStorage.removeItem(this._authDataKey);\n  }\n  /**\n   * Returns the current connected wallet account\n   */\n  account() {\n    if (!this._connectedAccount) {\n      this._connectedAccount = new ConnectedWalletAccount(this, this._near.connection, this._authData.accountId);\n    }\n    return this._connectedAccount;\n  }\n}\nexports.WalletConnection = WalletConnection;\nexports.WalletAccount = WalletConnection;\n/**\n * {@link Account} implementation which redirects to wallet using {@link WalletConnection} when no local key is available.\n */\nclass ConnectedWalletAccount extends account_1.Account {\n  constructor(walletConnection, connection, accountId) {\n    super(connection, accountId);\n    this.walletConnection = walletConnection;\n  }\n  // Overriding Account methods\n  /**\n   * Sign a transaction by redirecting to the NEAR Wallet\n   * @see {@link WalletConnection.requestSignTransactions}\n   */\n  signAndSendTransaction() {\n    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {\n      return this._signAndSendTransaction({\n        receiverId: arguments.length <= 0 ? undefined : arguments[0],\n        actions: arguments.length <= 1 ? undefined : arguments[1]\n      });\n    }\n    return this._signAndSendTransaction(arguments.length <= 0 ? undefined : arguments[0]);\n  }\n  async _signAndSendTransaction(_ref2) {\n    let {\n      receiverId,\n      actions,\n      walletMeta,\n      walletCallbackUrl = window.location.href\n    } = _ref2;\n    const localKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\n    let accessKey = await this.accessKeyForTransaction(receiverId, actions, localKey);\n    if (!accessKey) {\n      throw new Error(\"Cannot find matching key for transaction sent to \".concat(receiverId));\n    }\n    if (localKey && localKey.toString() === accessKey.public_key) {\n      try {\n        return await super.signAndSendTransaction({\n          receiverId,\n          actions\n        });\n      } catch (e) {\n        if (e.type === 'NotEnoughAllowance') {\n          accessKey = await this.accessKeyForTransaction(receiverId, actions);\n        } else {\n          throw e;\n        }\n      }\n    }\n    const block = await this.connection.provider.block({\n      finality: 'final'\n    });\n    const blockHash = borsh_1.baseDecode(block.header.hash);\n    const publicKey = utils_1.PublicKey.from(accessKey.public_key);\n    // TODO: Cache & listen for nonce updates for given access key\n    const nonce = accessKey.access_key.nonce + 1;\n    const transaction = transaction_1.createTransaction(this.accountId, publicKey, receiverId, nonce, actions, blockHash);\n    await this.walletConnection.requestSignTransactions({\n      transactions: [transaction],\n      meta: walletMeta,\n      callbackUrl: walletCallbackUrl\n    });\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        reject(new Error('Failed to redirect to sign transaction'));\n      }, 1000);\n    });\n    // TODO: Aggregate multiple transaction request with \"debounce\".\n    // TODO: Introduce TrasactionQueue which also can be used to watch for status?\n  }\n  /**\n   * Check if given access key allows the function call or method attempted in transaction\n   * @param accessKey Array of {access_key: AccessKey, public_key: PublicKey} items\n   * @param receiverId The NEAR account attempting to have access\n   * @param actions The action(s) needed to be checked for access\n   */\n  async accessKeyMatchesTransaction(accessKey, receiverId, actions) {\n    const {\n      access_key: {\n        permission\n      }\n    } = accessKey;\n    if (permission === 'FullAccess') {\n      return true;\n    }\n    if (permission.FunctionCall) {\n      const {\n        receiver_id: allowedReceiverId,\n        method_names: allowedMethods\n      } = permission.FunctionCall;\n      /********************************\n      Accept multisig access keys and let wallets attempt to signAndSendTransaction\n      If an access key has itself as receiverId and method permission add_request_and_confirm, then it is being used in a wallet with multisig contract: https://github.com/near/core-contracts/blob/671c05f09abecabe7a7e58efe942550a35fc3292/multisig/src/lib.rs#L149-L153\n      ********************************/\n      if (allowedReceiverId === this.accountId && allowedMethods.includes(MULTISIG_HAS_METHOD)) {\n        return true;\n      }\n      if (allowedReceiverId === receiverId) {\n        if (actions.length !== 1) {\n          return false;\n        }\n        const [{\n          functionCall\n        }] = actions;\n        return functionCall && (!functionCall.deposit || functionCall.deposit.toString() === '0') && (\n        // TODO: Should support charging amount smaller than allowance?\n        allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName));\n        // TODO: Handle cases when allowance doesn't have enough to pay for gas\n      }\n    }\n    // TODO: Support other permissions than FunctionCall\n    return false;\n  }\n  /**\n   * Helper function returning the access key (if it exists) to the receiver that grants the designated permission\n   * @param receiverId The NEAR account seeking the access key for a transaction\n   * @param actions The action(s) sought to gain access to\n   * @param localKey A local public key provided to check for access\n   * @returns Promise<any>\n   */\n  async accessKeyForTransaction(receiverId, actions, localKey) {\n    const accessKeys = await this.getAccessKeys();\n    if (localKey) {\n      const accessKey = accessKeys.find(key => key.public_key.toString() === localKey.toString());\n      if (accessKey && (await this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {\n        return accessKey;\n      }\n    }\n    const walletKeys = this.walletConnection._authData.allKeys;\n    for (const accessKey of accessKeys) {\n      if (walletKeys.indexOf(accessKey.public_key) !== -1 && (await this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {\n        return accessKey;\n      }\n    }\n    return null;\n  }\n}\nexports.ConnectedWalletAccount = ConnectedWalletAccount;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","ConnectedWalletAccount","WalletAccount","WalletConnection","depd_1","require","account_1","transaction_1","utils_1","borsh_1","borsh_2","LOGIN_WALLET_URL_SUFFIX","MULTISIG_HAS_METHOD","LOCAL_STORAGE_KEY_SUFFIX","PENDING_ACCESS_KEY_PREFIX","constructor","near","appKeyPrefix","_near","authDataKey","authData","JSON","parse","window","localStorage","getItem","_networkId","config","networkId","_walletBaseUrl","walletUrl","contractName","_keyStore","connection","signer","keyStore","_authData","allKeys","_authDataKey","isSignedIn","_completeSignInWithAccessKey","accountId","getAccountId","requestSignIn","contractIdOrOptions","arguments","length","undefined","title","successUrl","failureUrl","options","deprecate","default","contractId","currentUrl","URL","location","href","newUrl","searchParams","set","contractAccount","account","state","accessKey","KeyPair","fromRandom","getPublicKey","toString","setKey","methodNames","forEach","methodName","append","assign","requestSignTransactions","Array","isArray","_requestSignTransactions","transactions","callbackUrl","meta","_ref","map","transaction","serialize","SCHEMA","serialized","Buffer","from","join","publicKey","get","split","setItem","stringify","_moveKeyFromTempToPermanent","delete","history","replaceState","document","keyPair","getKey","removeKey","signOut","removeItem","_connectedAccount","Account","walletConnection","signAndSendTransaction","_signAndSendTransaction","receiverId","actions","_ref2","walletMeta","walletCallbackUrl","localKey","accessKeyForTransaction","Error","concat","public_key","e","type","block","provider","finality","blockHash","baseDecode","header","hash","PublicKey","nonce","access_key","createTransaction","Promise","resolve","reject","setTimeout","accessKeyMatchesTransaction","permission","FunctionCall","receiver_id","allowedReceiverId","method_names","allowedMethods","includes","functionCall","deposit","accessKeys","getAccessKeys","find","key","walletKeys","indexOf"],"sources":["/workspace/Planq-Dapps/vesting-portal/node_modules/near-api-js/lib/wallet-account.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConnectedWalletAccount = exports.WalletAccount = exports.WalletConnection = void 0;\n/**\n * The classes in this module are used in conjunction with the {@link BrowserLocalStorageKeyStore}. This module exposes two classes:\n * * {@link WalletConnection} which redirects users to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for key management.\n * * {@link ConnectedWalletAccount} is an {@link Account} implementation that uses {@link WalletConnection} to get keys\n *\n * @module walletAccount\n */\nconst depd_1 = __importDefault(require(\"depd\"));\nconst account_1 = require(\"./account\");\nconst transaction_1 = require(\"./transaction\");\nconst utils_1 = require(\"./utils\");\nconst borsh_1 = require(\"borsh\");\nconst borsh_2 = require(\"borsh\");\nconst LOGIN_WALLET_URL_SUFFIX = '/login/';\nconst MULTISIG_HAS_METHOD = 'add_request_and_confirm';\nconst LOCAL_STORAGE_KEY_SUFFIX = '_wallet_auth_key';\nconst PENDING_ACCESS_KEY_PREFIX = 'pending_key'; // browser storage key for a pending access key (i.e. key has been generated but we are not sure it was added yet)\n/**\n * This class is used in conjunction with the {@link BrowserLocalStorageKeyStore}.\n * It redirects users to {@link https://docs.near.org/docs/tools/near-wallet | NEAR Wallet} for key management.\n *\n * @example {@link https://docs.near.org/docs/develop/front-end/naj-quick-reference#wallet}\n * @example\n * ```js\n * // create new WalletConnection instance\n * const wallet = new WalletConnection(near, 'my-app');\n *\n * // If not signed in redirect to the NEAR wallet to sign in\n * // keys will be stored in the BrowserLocalStorageKeyStore\n * if(!wallet.isSingnedIn()) return wallet.requestSignIn()\n * ```\n */\nclass WalletConnection {\n    constructor(near, appKeyPrefix) {\n        this._near = near;\n        const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;\n        const authData = JSON.parse(window.localStorage.getItem(authDataKey));\n        this._networkId = near.config.networkId;\n        this._walletBaseUrl = near.config.walletUrl;\n        appKeyPrefix = appKeyPrefix || near.config.contractName || 'default';\n        this._keyStore = near.connection.signer.keyStore;\n        this._authData = authData || { allKeys: [] };\n        this._authDataKey = authDataKey;\n        if (!this.isSignedIn()) {\n            this._completeSignInWithAccessKey();\n        }\n    }\n    /**\n     * Returns true, if this WalletAccount is authorized with the wallet.\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * wallet.isSignedIn();\n     * ```\n     */\n    isSignedIn() {\n        return !!this._authData.accountId;\n    }\n    /**\n     * Returns authorized Account ID.\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * wallet.getAccountId();\n     * ```\n     */\n    getAccountId() {\n        return this._authData.accountId || '';\n    }\n    /**\n     * Redirects current page to the wallet authentication page.\n     * @param options An optional options object\n     * @param options.contractId The NEAR account where the contract is deployed\n     * @param options.successUrl URL to redirect upon success. Default: current url\n     * @param options.failureUrl URL to redirect upon failure. Default: current url\n     *\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * // redirects to the NEAR Wallet\n     * wallet.requestSignIn({ contractId: 'account-with-deploy-contract.near' });\n     * ```\n     */\n    async requestSignIn(contractIdOrOptions = {}, title, successUrl, failureUrl) {\n        let options;\n        if (typeof contractIdOrOptions === 'string') {\n            const deprecate = depd_1.default('requestSignIn(contractId, title)');\n            deprecate('`title` ignored; use `requestSignIn({ contractId, methodNames, successUrl, failureUrl })` instead');\n            options = { contractId: contractIdOrOptions, successUrl, failureUrl };\n        }\n        else {\n            options = contractIdOrOptions;\n        }\n        const currentUrl = new URL(window.location.href);\n        const newUrl = new URL(this._walletBaseUrl + LOGIN_WALLET_URL_SUFFIX);\n        newUrl.searchParams.set('success_url', options.successUrl || currentUrl.href);\n        newUrl.searchParams.set('failure_url', options.failureUrl || currentUrl.href);\n        if (options.contractId) {\n            /* Throws exception if contract account does not exist */\n            const contractAccount = await this._near.account(options.contractId);\n            await contractAccount.state();\n            newUrl.searchParams.set('contract_id', options.contractId);\n            const accessKey = utils_1.KeyPair.fromRandom('ed25519');\n            newUrl.searchParams.set('public_key', accessKey.getPublicKey().toString());\n            await this._keyStore.setKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + accessKey.getPublicKey(), accessKey);\n        }\n        if (options.methodNames) {\n            options.methodNames.forEach(methodName => {\n                newUrl.searchParams.append('methodNames', methodName);\n            });\n        }\n        window.location.assign(newUrl.toString());\n    }\n    async requestSignTransactions(...args) {\n        if (Array.isArray(args[0])) {\n            const deprecate = depd_1.default('WalletConnection.requestSignTransactions(transactions, callbackUrl, meta)');\n            deprecate('use `WalletConnection.requestSignTransactions(RequestSignTransactionsOptions)` instead');\n            return this._requestSignTransactions({\n                transactions: args[0],\n                callbackUrl: args[1],\n                meta: args[2]\n            });\n        }\n        return this._requestSignTransactions(args[0]);\n    }\n    async _requestSignTransactions({ transactions, meta, callbackUrl }) {\n        const currentUrl = new URL(window.location.href);\n        const newUrl = new URL('sign', this._walletBaseUrl);\n        newUrl.searchParams.set('transactions', transactions\n            .map(transaction => borsh_2.serialize(transaction_1.SCHEMA, transaction))\n            .map(serialized => Buffer.from(serialized).toString('base64'))\n            .join(','));\n        newUrl.searchParams.set('callbackUrl', callbackUrl || currentUrl.href);\n        if (meta)\n            newUrl.searchParams.set('meta', meta);\n        window.location.assign(newUrl.toString());\n    }\n    /**\n     * @hidden\n     * Complete sign in for a given account id and public key. To be invoked by the app when getting a callback from the wallet.\n     */\n    async _completeSignInWithAccessKey() {\n        const currentUrl = new URL(window.location.href);\n        const publicKey = currentUrl.searchParams.get('public_key') || '';\n        const allKeys = (currentUrl.searchParams.get('all_keys') || '').split(',');\n        const accountId = currentUrl.searchParams.get('account_id') || '';\n        // TODO: Handle errors during login\n        if (accountId) {\n            this._authData = {\n                accountId,\n                allKeys\n            };\n            window.localStorage.setItem(this._authDataKey, JSON.stringify(this._authData));\n            if (publicKey) {\n                await this._moveKeyFromTempToPermanent(accountId, publicKey);\n            }\n        }\n        currentUrl.searchParams.delete('public_key');\n        currentUrl.searchParams.delete('all_keys');\n        currentUrl.searchParams.delete('account_id');\n        currentUrl.searchParams.delete('meta');\n        currentUrl.searchParams.delete('transactionHashes');\n        window.history.replaceState({}, document.title, currentUrl.toString());\n    }\n    /**\n     * @hidden\n     * @param accountId The NEAR account owning the given public key\n     * @param publicKey The public key being set to the key store\n     */\n    async _moveKeyFromTempToPermanent(accountId, publicKey) {\n        const keyPair = await this._keyStore.getKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n        await this._keyStore.setKey(this._networkId, accountId, keyPair);\n        await this._keyStore.removeKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n    }\n    /**\n     * Sign out from the current account\n     * @example\n     * walletAccount.signOut();\n     */\n    signOut() {\n        this._authData = {};\n        window.localStorage.removeItem(this._authDataKey);\n    }\n    /**\n     * Returns the current connected wallet account\n     */\n    account() {\n        if (!this._connectedAccount) {\n            this._connectedAccount = new ConnectedWalletAccount(this, this._near.connection, this._authData.accountId);\n        }\n        return this._connectedAccount;\n    }\n}\nexports.WalletConnection = WalletConnection;\nexports.WalletAccount = WalletConnection;\n/**\n * {@link Account} implementation which redirects to wallet using {@link WalletConnection} when no local key is available.\n */\nclass ConnectedWalletAccount extends account_1.Account {\n    constructor(walletConnection, connection, accountId) {\n        super(connection, accountId);\n        this.walletConnection = walletConnection;\n    }\n    // Overriding Account methods\n    /**\n     * Sign a transaction by redirecting to the NEAR Wallet\n     * @see {@link WalletConnection.requestSignTransactions}\n     */\n    signAndSendTransaction(...args) {\n        if (typeof args[0] === 'string') {\n            return this._signAndSendTransaction({ receiverId: args[0], actions: args[1] });\n        }\n        return this._signAndSendTransaction(args[0]);\n    }\n    async _signAndSendTransaction({ receiverId, actions, walletMeta, walletCallbackUrl = window.location.href }) {\n        const localKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\n        let accessKey = await this.accessKeyForTransaction(receiverId, actions, localKey);\n        if (!accessKey) {\n            throw new Error(`Cannot find matching key for transaction sent to ${receiverId}`);\n        }\n        if (localKey && localKey.toString() === accessKey.public_key) {\n            try {\n                return await super.signAndSendTransaction({ receiverId, actions });\n            }\n            catch (e) {\n                if (e.type === 'NotEnoughAllowance') {\n                    accessKey = await this.accessKeyForTransaction(receiverId, actions);\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        const block = await this.connection.provider.block({ finality: 'final' });\n        const blockHash = borsh_1.baseDecode(block.header.hash);\n        const publicKey = utils_1.PublicKey.from(accessKey.public_key);\n        // TODO: Cache & listen for nonce updates for given access key\n        const nonce = accessKey.access_key.nonce + 1;\n        const transaction = transaction_1.createTransaction(this.accountId, publicKey, receiverId, nonce, actions, blockHash);\n        await this.walletConnection.requestSignTransactions({\n            transactions: [transaction],\n            meta: walletMeta,\n            callbackUrl: walletCallbackUrl\n        });\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                reject(new Error('Failed to redirect to sign transaction'));\n            }, 1000);\n        });\n        // TODO: Aggregate multiple transaction request with \"debounce\".\n        // TODO: Introduce TrasactionQueue which also can be used to watch for status?\n    }\n    /**\n     * Check if given access key allows the function call or method attempted in transaction\n     * @param accessKey Array of {access_key: AccessKey, public_key: PublicKey} items\n     * @param receiverId The NEAR account attempting to have access\n     * @param actions The action(s) needed to be checked for access\n     */\n    async accessKeyMatchesTransaction(accessKey, receiverId, actions) {\n        const { access_key: { permission } } = accessKey;\n        if (permission === 'FullAccess') {\n            return true;\n        }\n        if (permission.FunctionCall) {\n            const { receiver_id: allowedReceiverId, method_names: allowedMethods } = permission.FunctionCall;\n            /********************************\n            Accept multisig access keys and let wallets attempt to signAndSendTransaction\n            If an access key has itself as receiverId and method permission add_request_and_confirm, then it is being used in a wallet with multisig contract: https://github.com/near/core-contracts/blob/671c05f09abecabe7a7e58efe942550a35fc3292/multisig/src/lib.rs#L149-L153\n            ********************************/\n            if (allowedReceiverId === this.accountId && allowedMethods.includes(MULTISIG_HAS_METHOD)) {\n                return true;\n            }\n            if (allowedReceiverId === receiverId) {\n                if (actions.length !== 1) {\n                    return false;\n                }\n                const [{ functionCall }] = actions;\n                return functionCall &&\n                    (!functionCall.deposit || functionCall.deposit.toString() === '0') && // TODO: Should support charging amount smaller than allowance?\n                    (allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName));\n                // TODO: Handle cases when allowance doesn't have enough to pay for gas\n            }\n        }\n        // TODO: Support other permissions than FunctionCall\n        return false;\n    }\n    /**\n     * Helper function returning the access key (if it exists) to the receiver that grants the designated permission\n     * @param receiverId The NEAR account seeking the access key for a transaction\n     * @param actions The action(s) sought to gain access to\n     * @param localKey A local public key provided to check for access\n     * @returns Promise<any>\n     */\n    async accessKeyForTransaction(receiverId, actions, localKey) {\n        const accessKeys = await this.getAccessKeys();\n        if (localKey) {\n            const accessKey = accessKeys.find(key => key.public_key.toString() === localKey.toString());\n            if (accessKey && await this.accessKeyMatchesTransaction(accessKey, receiverId, actions)) {\n                return accessKey;\n            }\n        }\n        const walletKeys = this.walletConnection._authData.allKeys;\n        for (const accessKey of accessKeys) {\n            if (walletKeys.indexOf(accessKey.public_key) !== -1 && await this.accessKeyMatchesTransaction(accessKey, receiverId, actions)) {\n                return accessKey;\n            }\n        }\n        return null;\n    }\n}\nexports.ConnectedWalletAccount = ConnectedWalletAccount;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}