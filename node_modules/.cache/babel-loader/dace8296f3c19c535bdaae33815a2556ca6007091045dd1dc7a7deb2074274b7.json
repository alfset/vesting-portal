{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.checkTaprootInputForSigs = exports.tapTreeFromList = exports.tapTreeToList = exports.tweakInternalPubKey = exports.checkTaprootOutputFields = exports.checkTaprootInputFields = exports.isTaprootOutput = exports.isTaprootInput = exports.serializeTaprootSignature = exports.tapScriptFinalizer = exports.toXOnly = void 0;\nconst types_1 = require('../types');\nconst transaction_1 = require('../transaction');\nconst psbtutils_1 = require('./psbtutils');\nconst bip341_1 = require('../payments/bip341');\nconst payments_1 = require('../payments');\nconst psbtutils_2 = require('./psbtutils');\nconst toXOnly = pubKey => pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);\nexports.toXOnly = toXOnly;\n/**\n * Default tapscript finalizer. It searches for the `tapLeafHashToFinalize` if provided.\n * Otherwise it will search for the tapleaf that has at least one signature and has the shortest path.\n * @param inputIndex the position of the PSBT input.\n * @param input the PSBT input.\n * @param tapLeafHashToFinalize optional, if provided the finalizer will search for a tapleaf that has this hash\n *                              and will try to build the finalScriptWitness.\n * @returns the finalScriptWitness or throws an exception if no tapleaf found.\n */\nfunction tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {\n  const tapLeaf = findTapLeafToFinalize(input, inputIndex, tapLeafHashToFinalize);\n  try {\n    const sigs = sortSignatures(input, tapLeaf);\n    const witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);\n    return {\n      finalScriptWitness: (0, psbtutils_1.witnessStackToScriptWitness)(witness)\n    };\n  } catch (err) {\n    throw new Error(\"Can not finalize taproot input #\".concat(inputIndex, \": \").concat(err));\n  }\n}\nexports.tapScriptFinalizer = tapScriptFinalizer;\nfunction serializeTaprootSignature(sig, sighashType) {\n  const sighashTypeByte = sighashType ? Buffer.from([sighashType]) : Buffer.from([]);\n  return Buffer.concat([sig, sighashTypeByte]);\n}\nexports.serializeTaprootSignature = serializeTaprootSignature;\nfunction isTaprootInput(input) {\n  return input && !!(input.tapInternalKey || input.tapMerkleRoot || input.tapLeafScript && input.tapLeafScript.length || input.tapBip32Derivation && input.tapBip32Derivation.length || input.witnessUtxo && (0, psbtutils_1.isP2TR)(input.witnessUtxo.script));\n}\nexports.isTaprootInput = isTaprootInput;\nfunction isTaprootOutput(output, script) {\n  return output && !!(output.tapInternalKey || output.tapTree || output.tapBip32Derivation && output.tapBip32Derivation.length || script && (0, psbtutils_1.isP2TR)(script));\n}\nexports.isTaprootOutput = isTaprootOutput;\nfunction checkTaprootInputFields(inputData, newInputData, action) {\n  checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);\n  checkIfTapLeafInTree(inputData, newInputData, action);\n}\nexports.checkTaprootInputFields = checkTaprootInputFields;\nfunction checkTaprootOutputFields(outputData, newOutputData, action) {\n  checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);\n  checkTaprootScriptPubkey(outputData, newOutputData);\n}\nexports.checkTaprootOutputFields = checkTaprootOutputFields;\nfunction checkTaprootScriptPubkey(outputData, newOutputData) {\n  if (!newOutputData.tapTree && !newOutputData.tapInternalKey) return;\n  const tapInternalKey = newOutputData.tapInternalKey || outputData.tapInternalKey;\n  const tapTree = newOutputData.tapTree || outputData.tapTree;\n  if (tapInternalKey) {\n    const {\n      script: scriptPubkey\n    } = outputData;\n    const script = getTaprootScripPubkey(tapInternalKey, tapTree);\n    if (scriptPubkey && !scriptPubkey.equals(script)) throw new Error('Error adding output. Script or address missmatch.');\n  }\n}\nfunction getTaprootScripPubkey(tapInternalKey, tapTree) {\n  const scriptTree = tapTree && tapTreeFromList(tapTree.leaves);\n  const {\n    output\n  } = (0, payments_1.p2tr)({\n    internalPubkey: tapInternalKey,\n    scriptTree\n  });\n  return output;\n}\nfunction tweakInternalPubKey(inputIndex, input) {\n  const tapInternalKey = input.tapInternalKey;\n  const outputKey = tapInternalKey && (0, bip341_1.tweakKey)(tapInternalKey, input.tapMerkleRoot);\n  if (!outputKey) throw new Error(\"Cannot tweak tap internal key for input #\".concat(inputIndex, \". Public key: \").concat(tapInternalKey && tapInternalKey.toString('hex')));\n  return outputKey.x;\n}\nexports.tweakInternalPubKey = tweakInternalPubKey;\n/**\n * Convert a binary tree to a BIP371 type list. Each element of the list is (according to BIP371):\n * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,\n * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that\n * the tree is correctly reconstructed.\n * @param tree the binary tap tree\n * @returns a list of BIP 371 tapleaves\n */\nfunction tapTreeToList(tree) {\n  if (!(0, types_1.isTaptree)(tree)) throw new Error('Cannot convert taptree to tapleaf list. Expecting a tapree structure.');\n  return _tapTreeToList(tree);\n}\nexports.tapTreeToList = tapTreeToList;\n/**\n * Convert a BIP371 TapLeaf list to a TapTree (binary).\n * @param leaves a list of tapleaves where each element of the list is (according to BIP371):\n * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,\n * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that\n * the tree is correctly reconstructed.\n * @returns the corresponding taptree, or throws an exception if the tree cannot be reconstructed\n */\nfunction tapTreeFromList() {\n  let leaves = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  if (leaves.length === 1 && leaves[0].depth === 0) return {\n    output: leaves[0].script,\n    version: leaves[0].leafVersion\n  };\n  return instertLeavesInTree(leaves);\n}\nexports.tapTreeFromList = tapTreeFromList;\nfunction checkTaprootInputForSigs(input, action) {\n  const sigs = extractTaprootSigs(input);\n  return sigs.some(sig => (0, psbtutils_2.signatureBlocksAction)(sig, decodeSchnorrSignature, action));\n}\nexports.checkTaprootInputForSigs = checkTaprootInputForSigs;\nfunction decodeSchnorrSignature(signature) {\n  return {\n    signature: signature.slice(0, 64),\n    hashType: signature.slice(64)[0] || transaction_1.Transaction.SIGHASH_DEFAULT\n  };\n}\nfunction extractTaprootSigs(input) {\n  const sigs = [];\n  if (input.tapKeySig) sigs.push(input.tapKeySig);\n  if (input.tapScriptSig) sigs.push(...input.tapScriptSig.map(s => s.signature));\n  if (!sigs.length) {\n    const finalTapKeySig = getTapKeySigFromWithness(input.finalScriptWitness);\n    if (finalTapKeySig) sigs.push(finalTapKeySig);\n  }\n  return sigs;\n}\nfunction getTapKeySigFromWithness(finalScriptWitness) {\n  if (!finalScriptWitness) return;\n  const witness = finalScriptWitness.slice(2);\n  // todo: add schnorr signature validation\n  if (witness.length === 64 || witness.length === 65) return witness;\n}\nfunction _tapTreeToList(tree) {\n  let leaves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  if (depth > bip341_1.MAX_TAPTREE_DEPTH) throw new Error('Max taptree depth exceeded.');\n  if (!tree) return [];\n  if ((0, types_1.isTapleaf)(tree)) {\n    leaves.push({\n      depth,\n      leafVersion: tree.version || bip341_1.LEAF_VERSION_TAPSCRIPT,\n      script: tree.output\n    });\n    return leaves;\n  }\n  if (tree[0]) _tapTreeToList(tree[0], leaves, depth + 1);\n  if (tree[1]) _tapTreeToList(tree[1], leaves, depth + 1);\n  return leaves;\n}\nfunction instertLeavesInTree(leaves) {\n  let tree;\n  for (const leaf of leaves) {\n    tree = instertLeafInTree(leaf, tree);\n    if (!tree) throw new Error(\"No room left to insert tapleaf in tree\");\n  }\n  return tree;\n}\nfunction instertLeafInTree(leaf, tree) {\n  let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  if (depth > bip341_1.MAX_TAPTREE_DEPTH) throw new Error('Max taptree depth exceeded.');\n  if (leaf.depth === depth) {\n    if (!tree) return {\n      output: leaf.script,\n      version: leaf.leafVersion\n    };\n    return;\n  }\n  if ((0, types_1.isTapleaf)(tree)) return;\n  const leftSide = instertLeafInTree(leaf, tree && tree[0], depth + 1);\n  if (leftSide) return [leftSide, tree && tree[1]];\n  const rightSide = instertLeafInTree(leaf, tree && tree[1], depth + 1);\n  if (rightSide) return [tree && tree[0], rightSide];\n}\nfunction checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action) {\n  const isBadTaprootUpdate = isTaprootInput(inputData) && hasNonTaprootFields(newInputData);\n  const isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootInput(newInputData);\n  const hasMixedFields = inputData === newInputData && isTaprootInput(newInputData) && hasNonTaprootFields(newInputData); // todo: bad? use !===\n  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields) throw new Error(\"Invalid arguments for Psbt.\".concat(action, \". \") + \"Cannot use both taproot and non-taproot fields.\");\n}\nfunction checkMixedTaprootAndNonTaprootOutputFields(inputData, newInputData, action) {\n  const isBadTaprootUpdate = isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);\n  const isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);\n  const hasMixedFields = inputData === newInputData && isTaprootOutput(newInputData) && hasNonTaprootFields(newInputData);\n  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields) throw new Error(\"Invalid arguments for Psbt.\".concat(action, \". \") + \"Cannot use both taproot and non-taproot fields.\");\n}\nfunction checkIfTapLeafInTree(inputData, newInputData, action) {\n  if (newInputData.tapMerkleRoot) {\n    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l => isTapLeafInTree(l, newInputData.tapMerkleRoot));\n    const oldLeafsInTree = (inputData.tapLeafScript || []).every(l => isTapLeafInTree(l, newInputData.tapMerkleRoot));\n    if (!newLeafsInTree || !oldLeafsInTree) throw new Error(\"Invalid arguments for Psbt.\".concat(action, \". Tapleaf not part of taptree.\"));\n  } else if (inputData.tapMerkleRoot) {\n    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l => isTapLeafInTree(l, inputData.tapMerkleRoot));\n    if (!newLeafsInTree) throw new Error(\"Invalid arguments for Psbt.\".concat(action, \". Tapleaf not part of taptree.\"));\n  }\n}\nfunction isTapLeafInTree(tapLeaf, merkleRoot) {\n  if (!merkleRoot) return true;\n  const leafHash = (0, bip341_1.tapleafHash)({\n    output: tapLeaf.script,\n    version: tapLeaf.leafVersion\n  });\n  const rootHash = (0, bip341_1.rootHashFromPath)(tapLeaf.controlBlock, leafHash);\n  return rootHash.equals(merkleRoot);\n}\nfunction sortSignatures(input, tapLeaf) {\n  const leafHash = (0, bip341_1.tapleafHash)({\n    output: tapLeaf.script,\n    version: tapLeaf.leafVersion\n  });\n  return (input.tapScriptSig || []).filter(tss => tss.leafHash.equals(leafHash)).map(tss => addPubkeyPositionInScript(tapLeaf.script, tss)).sort((t1, t2) => t2.positionInScript - t1.positionInScript).map(t => t.signature);\n}\nfunction addPubkeyPositionInScript(script, tss) {\n  return Object.assign({\n    positionInScript: (0, psbtutils_1.pubkeyPositionInScript)(tss.pubkey, script)\n  }, tss);\n}\n/**\n * Find tapleaf by hash, or get the signed tapleaf with the shortest path.\n */\nfunction findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {\n  if (!input.tapScriptSig || !input.tapScriptSig.length) throw new Error(\"Can not finalize taproot input #\".concat(inputIndex, \". No tapleaf script signature provided.\"));\n  const tapLeaf = (input.tapLeafScript || []).sort((a, b) => a.controlBlock.length - b.controlBlock.length).find(leaf => canFinalizeLeaf(leaf, input.tapScriptSig, leafHashToFinalize));\n  if (!tapLeaf) throw new Error(\"Can not finalize taproot input #\".concat(inputIndex, \". Signature for tapleaf script not found.\"));\n  return tapLeaf;\n}\nfunction canFinalizeLeaf(leaf, tapScriptSig, hash) {\n  const leafHash = (0, bip341_1.tapleafHash)({\n    output: leaf.script,\n    version: leaf.leafVersion\n  });\n  const whiteListedHash = !hash || hash.equals(leafHash);\n  return whiteListedHash && tapScriptSig.find(tss => tss.leafHash.equals(leafHash)) !== undefined;\n}\nfunction hasNonTaprootFields(io) {\n  return io && !!(io.redeemScript || io.witnessScript || io.bip32Derivation && io.bip32Derivation.length);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","checkTaprootInputForSigs","tapTreeFromList","tapTreeToList","tweakInternalPubKey","checkTaprootOutputFields","checkTaprootInputFields","isTaprootOutput","isTaprootInput","serializeTaprootSignature","tapScriptFinalizer","toXOnly","types_1","require","transaction_1","psbtutils_1","bip341_1","payments_1","psbtutils_2","pubKey","length","slice","inputIndex","input","tapLeafHashToFinalize","tapLeaf","findTapLeafToFinalize","sigs","sortSignatures","witness","concat","script","controlBlock","finalScriptWitness","witnessStackToScriptWitness","err","Error","sig","sighashType","sighashTypeByte","Buffer","from","tapInternalKey","tapMerkleRoot","tapLeafScript","tapBip32Derivation","witnessUtxo","isP2TR","output","tapTree","inputData","newInputData","action","checkMixedTaprootAndNonTaprootInputFields","checkIfTapLeafInTree","outputData","newOutputData","checkMixedTaprootAndNonTaprootOutputFields","checkTaprootScriptPubkey","scriptPubkey","getTaprootScripPubkey","equals","scriptTree","leaves","p2tr","internalPubkey","outputKey","tweakKey","toString","x","tree","isTaptree","_tapTreeToList","arguments","undefined","depth","version","leafVersion","instertLeavesInTree","extractTaprootSigs","some","signatureBlocksAction","decodeSchnorrSignature","signature","hashType","Transaction","SIGHASH_DEFAULT","tapKeySig","push","tapScriptSig","map","s","finalTapKeySig","getTapKeySigFromWithness","MAX_TAPTREE_DEPTH","isTapleaf","LEAF_VERSION_TAPSCRIPT","leaf","instertLeafInTree","leftSide","rightSide","isBadTaprootUpdate","hasNonTaprootFields","isBadNonTaprootUpdate","hasMixedFields","newLeafsInTree","every","l","isTapLeafInTree","oldLeafsInTree","merkleRoot","leafHash","tapleafHash","rootHash","rootHashFromPath","filter","tss","addPubkeyPositionInScript","sort","t1","t2","positionInScript","t","assign","pubkeyPositionInScript","pubkey","leafHashToFinalize","a","b","find","canFinalizeLeaf","hash","whiteListedHash","io","redeemScript","witnessScript","bip32Derivation"],"sources":["/workspace/Planq-Dapps/vesting-portal/node_modules/bitcoinjs-lib/src/psbt/bip371.js"],"sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.checkTaprootInputForSigs =\n  exports.tapTreeFromList =\n  exports.tapTreeToList =\n  exports.tweakInternalPubKey =\n  exports.checkTaprootOutputFields =\n  exports.checkTaprootInputFields =\n  exports.isTaprootOutput =\n  exports.isTaprootInput =\n  exports.serializeTaprootSignature =\n  exports.tapScriptFinalizer =\n  exports.toXOnly =\n    void 0;\nconst types_1 = require('../types');\nconst transaction_1 = require('../transaction');\nconst psbtutils_1 = require('./psbtutils');\nconst bip341_1 = require('../payments/bip341');\nconst payments_1 = require('../payments');\nconst psbtutils_2 = require('./psbtutils');\nconst toXOnly = pubKey => (pubKey.length === 32 ? pubKey : pubKey.slice(1, 33));\nexports.toXOnly = toXOnly;\n/**\n * Default tapscript finalizer. It searches for the `tapLeafHashToFinalize` if provided.\n * Otherwise it will search for the tapleaf that has at least one signature and has the shortest path.\n * @param inputIndex the position of the PSBT input.\n * @param input the PSBT input.\n * @param tapLeafHashToFinalize optional, if provided the finalizer will search for a tapleaf that has this hash\n *                              and will try to build the finalScriptWitness.\n * @returns the finalScriptWitness or throws an exception if no tapleaf found.\n */\nfunction tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {\n  const tapLeaf = findTapLeafToFinalize(\n    input,\n    inputIndex,\n    tapLeafHashToFinalize,\n  );\n  try {\n    const sigs = sortSignatures(input, tapLeaf);\n    const witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);\n    return {\n      finalScriptWitness: (0, psbtutils_1.witnessStackToScriptWitness)(witness),\n    };\n  } catch (err) {\n    throw new Error(`Can not finalize taproot input #${inputIndex}: ${err}`);\n  }\n}\nexports.tapScriptFinalizer = tapScriptFinalizer;\nfunction serializeTaprootSignature(sig, sighashType) {\n  const sighashTypeByte = sighashType\n    ? Buffer.from([sighashType])\n    : Buffer.from([]);\n  return Buffer.concat([sig, sighashTypeByte]);\n}\nexports.serializeTaprootSignature = serializeTaprootSignature;\nfunction isTaprootInput(input) {\n  return (\n    input &&\n    !!(\n      input.tapInternalKey ||\n      input.tapMerkleRoot ||\n      (input.tapLeafScript && input.tapLeafScript.length) ||\n      (input.tapBip32Derivation && input.tapBip32Derivation.length) ||\n      (input.witnessUtxo && (0, psbtutils_1.isP2TR)(input.witnessUtxo.script))\n    )\n  );\n}\nexports.isTaprootInput = isTaprootInput;\nfunction isTaprootOutput(output, script) {\n  return (\n    output &&\n    !!(\n      output.tapInternalKey ||\n      output.tapTree ||\n      (output.tapBip32Derivation && output.tapBip32Derivation.length) ||\n      (script && (0, psbtutils_1.isP2TR)(script))\n    )\n  );\n}\nexports.isTaprootOutput = isTaprootOutput;\nfunction checkTaprootInputFields(inputData, newInputData, action) {\n  checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);\n  checkIfTapLeafInTree(inputData, newInputData, action);\n}\nexports.checkTaprootInputFields = checkTaprootInputFields;\nfunction checkTaprootOutputFields(outputData, newOutputData, action) {\n  checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);\n  checkTaprootScriptPubkey(outputData, newOutputData);\n}\nexports.checkTaprootOutputFields = checkTaprootOutputFields;\nfunction checkTaprootScriptPubkey(outputData, newOutputData) {\n  if (!newOutputData.tapTree && !newOutputData.tapInternalKey) return;\n  const tapInternalKey =\n    newOutputData.tapInternalKey || outputData.tapInternalKey;\n  const tapTree = newOutputData.tapTree || outputData.tapTree;\n  if (tapInternalKey) {\n    const { script: scriptPubkey } = outputData;\n    const script = getTaprootScripPubkey(tapInternalKey, tapTree);\n    if (scriptPubkey && !scriptPubkey.equals(script))\n      throw new Error('Error adding output. Script or address missmatch.');\n  }\n}\nfunction getTaprootScripPubkey(tapInternalKey, tapTree) {\n  const scriptTree = tapTree && tapTreeFromList(tapTree.leaves);\n  const { output } = (0, payments_1.p2tr)({\n    internalPubkey: tapInternalKey,\n    scriptTree,\n  });\n  return output;\n}\nfunction tweakInternalPubKey(inputIndex, input) {\n  const tapInternalKey = input.tapInternalKey;\n  const outputKey =\n    tapInternalKey &&\n    (0, bip341_1.tweakKey)(tapInternalKey, input.tapMerkleRoot);\n  if (!outputKey)\n    throw new Error(\n      `Cannot tweak tap internal key for input #${inputIndex}. Public key: ${\n        tapInternalKey && tapInternalKey.toString('hex')\n      }`,\n    );\n  return outputKey.x;\n}\nexports.tweakInternalPubKey = tweakInternalPubKey;\n/**\n * Convert a binary tree to a BIP371 type list. Each element of the list is (according to BIP371):\n * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,\n * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that\n * the tree is correctly reconstructed.\n * @param tree the binary tap tree\n * @returns a list of BIP 371 tapleaves\n */\nfunction tapTreeToList(tree) {\n  if (!(0, types_1.isTaptree)(tree))\n    throw new Error(\n      'Cannot convert taptree to tapleaf list. Expecting a tapree structure.',\n    );\n  return _tapTreeToList(tree);\n}\nexports.tapTreeToList = tapTreeToList;\n/**\n * Convert a BIP371 TapLeaf list to a TapTree (binary).\n * @param leaves a list of tapleaves where each element of the list is (according to BIP371):\n * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,\n * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that\n * the tree is correctly reconstructed.\n * @returns the corresponding taptree, or throws an exception if the tree cannot be reconstructed\n */\nfunction tapTreeFromList(leaves = []) {\n  if (leaves.length === 1 && leaves[0].depth === 0)\n    return {\n      output: leaves[0].script,\n      version: leaves[0].leafVersion,\n    };\n  return instertLeavesInTree(leaves);\n}\nexports.tapTreeFromList = tapTreeFromList;\nfunction checkTaprootInputForSigs(input, action) {\n  const sigs = extractTaprootSigs(input);\n  return sigs.some(sig =>\n    (0, psbtutils_2.signatureBlocksAction)(sig, decodeSchnorrSignature, action),\n  );\n}\nexports.checkTaprootInputForSigs = checkTaprootInputForSigs;\nfunction decodeSchnorrSignature(signature) {\n  return {\n    signature: signature.slice(0, 64),\n    hashType:\n      signature.slice(64)[0] || transaction_1.Transaction.SIGHASH_DEFAULT,\n  };\n}\nfunction extractTaprootSigs(input) {\n  const sigs = [];\n  if (input.tapKeySig) sigs.push(input.tapKeySig);\n  if (input.tapScriptSig)\n    sigs.push(...input.tapScriptSig.map(s => s.signature));\n  if (!sigs.length) {\n    const finalTapKeySig = getTapKeySigFromWithness(input.finalScriptWitness);\n    if (finalTapKeySig) sigs.push(finalTapKeySig);\n  }\n  return sigs;\n}\nfunction getTapKeySigFromWithness(finalScriptWitness) {\n  if (!finalScriptWitness) return;\n  const witness = finalScriptWitness.slice(2);\n  // todo: add schnorr signature validation\n  if (witness.length === 64 || witness.length === 65) return witness;\n}\nfunction _tapTreeToList(tree, leaves = [], depth = 0) {\n  if (depth > bip341_1.MAX_TAPTREE_DEPTH)\n    throw new Error('Max taptree depth exceeded.');\n  if (!tree) return [];\n  if ((0, types_1.isTapleaf)(tree)) {\n    leaves.push({\n      depth,\n      leafVersion: tree.version || bip341_1.LEAF_VERSION_TAPSCRIPT,\n      script: tree.output,\n    });\n    return leaves;\n  }\n  if (tree[0]) _tapTreeToList(tree[0], leaves, depth + 1);\n  if (tree[1]) _tapTreeToList(tree[1], leaves, depth + 1);\n  return leaves;\n}\nfunction instertLeavesInTree(leaves) {\n  let tree;\n  for (const leaf of leaves) {\n    tree = instertLeafInTree(leaf, tree);\n    if (!tree) throw new Error(`No room left to insert tapleaf in tree`);\n  }\n  return tree;\n}\nfunction instertLeafInTree(leaf, tree, depth = 0) {\n  if (depth > bip341_1.MAX_TAPTREE_DEPTH)\n    throw new Error('Max taptree depth exceeded.');\n  if (leaf.depth === depth) {\n    if (!tree)\n      return {\n        output: leaf.script,\n        version: leaf.leafVersion,\n      };\n    return;\n  }\n  if ((0, types_1.isTapleaf)(tree)) return;\n  const leftSide = instertLeafInTree(leaf, tree && tree[0], depth + 1);\n  if (leftSide) return [leftSide, tree && tree[1]];\n  const rightSide = instertLeafInTree(leaf, tree && tree[1], depth + 1);\n  if (rightSide) return [tree && tree[0], rightSide];\n}\nfunction checkMixedTaprootAndNonTaprootInputFields(\n  inputData,\n  newInputData,\n  action,\n) {\n  const isBadTaprootUpdate =\n    isTaprootInput(inputData) && hasNonTaprootFields(newInputData);\n  const isBadNonTaprootUpdate =\n    hasNonTaprootFields(inputData) && isTaprootInput(newInputData);\n  const hasMixedFields =\n    inputData === newInputData &&\n    isTaprootInput(newInputData) &&\n    hasNonTaprootFields(newInputData); // todo: bad? use !===\n  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)\n    throw new Error(\n      `Invalid arguments for Psbt.${action}. ` +\n        `Cannot use both taproot and non-taproot fields.`,\n    );\n}\nfunction checkMixedTaprootAndNonTaprootOutputFields(\n  inputData,\n  newInputData,\n  action,\n) {\n  const isBadTaprootUpdate =\n    isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);\n  const isBadNonTaprootUpdate =\n    hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);\n  const hasMixedFields =\n    inputData === newInputData &&\n    isTaprootOutput(newInputData) &&\n    hasNonTaprootFields(newInputData);\n  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)\n    throw new Error(\n      `Invalid arguments for Psbt.${action}. ` +\n        `Cannot use both taproot and non-taproot fields.`,\n    );\n}\nfunction checkIfTapLeafInTree(inputData, newInputData, action) {\n  if (newInputData.tapMerkleRoot) {\n    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, newInputData.tapMerkleRoot),\n    );\n    const oldLeafsInTree = (inputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, newInputData.tapMerkleRoot),\n    );\n    if (!newLeafsInTree || !oldLeafsInTree)\n      throw new Error(\n        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,\n      );\n  } else if (inputData.tapMerkleRoot) {\n    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, inputData.tapMerkleRoot),\n    );\n    if (!newLeafsInTree)\n      throw new Error(\n        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,\n      );\n  }\n}\nfunction isTapLeafInTree(tapLeaf, merkleRoot) {\n  if (!merkleRoot) return true;\n  const leafHash = (0, bip341_1.tapleafHash)({\n    output: tapLeaf.script,\n    version: tapLeaf.leafVersion,\n  });\n  const rootHash = (0, bip341_1.rootHashFromPath)(\n    tapLeaf.controlBlock,\n    leafHash,\n  );\n  return rootHash.equals(merkleRoot);\n}\nfunction sortSignatures(input, tapLeaf) {\n  const leafHash = (0, bip341_1.tapleafHash)({\n    output: tapLeaf.script,\n    version: tapLeaf.leafVersion,\n  });\n  return (input.tapScriptSig || [])\n    .filter(tss => tss.leafHash.equals(leafHash))\n    .map(tss => addPubkeyPositionInScript(tapLeaf.script, tss))\n    .sort((t1, t2) => t2.positionInScript - t1.positionInScript)\n    .map(t => t.signature);\n}\nfunction addPubkeyPositionInScript(script, tss) {\n  return Object.assign(\n    {\n      positionInScript: (0, psbtutils_1.pubkeyPositionInScript)(\n        tss.pubkey,\n        script,\n      ),\n    },\n    tss,\n  );\n}\n/**\n * Find tapleaf by hash, or get the signed tapleaf with the shortest path.\n */\nfunction findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {\n  if (!input.tapScriptSig || !input.tapScriptSig.length)\n    throw new Error(\n      `Can not finalize taproot input #${inputIndex}. No tapleaf script signature provided.`,\n    );\n  const tapLeaf = (input.tapLeafScript || [])\n    .sort((a, b) => a.controlBlock.length - b.controlBlock.length)\n    .find(leaf =>\n      canFinalizeLeaf(leaf, input.tapScriptSig, leafHashToFinalize),\n    );\n  if (!tapLeaf)\n    throw new Error(\n      `Can not finalize taproot input #${inputIndex}. Signature for tapleaf script not found.`,\n    );\n  return tapLeaf;\n}\nfunction canFinalizeLeaf(leaf, tapScriptSig, hash) {\n  const leafHash = (0, bip341_1.tapleafHash)({\n    output: leaf.script,\n    version: leaf.leafVersion,\n  });\n  const whiteListedHash = !hash || hash.equals(leafHash);\n  return (\n    whiteListedHash &&\n    tapScriptSig.find(tss => tss.leafHash.equals(leafHash)) !== undefined\n  );\n}\nfunction hasNonTaprootFields(io) {\n  return (\n    io &&\n    !!(\n      io.redeemScript ||\n      io.witnessScript ||\n      (io.bip32Derivation && io.bip32Derivation.length)\n    )\n  );\n}\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,wBAAwB,GAC9BF,OAAO,CAACG,eAAe,GACvBH,OAAO,CAACI,aAAa,GACrBJ,OAAO,CAACK,mBAAmB,GAC3BL,OAAO,CAACM,wBAAwB,GAChCN,OAAO,CAACO,uBAAuB,GAC/BP,OAAO,CAACQ,eAAe,GACvBR,OAAO,CAACS,cAAc,GACtBT,OAAO,CAACU,yBAAyB,GACjCV,OAAO,CAACW,kBAAkB,GAC1BX,OAAO,CAACY,OAAO,GACb,KAAK,CAAC;AACV,MAAMC,OAAO,GAAGC,OAAO,CAAC,UAAU,CAAC;AACnC,MAAMC,aAAa,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AAC/C,MAAME,WAAW,GAAGF,OAAO,CAAC,aAAa,CAAC;AAC1C,MAAMG,QAAQ,GAAGH,OAAO,CAAC,oBAAoB,CAAC;AAC9C,MAAMI,UAAU,GAAGJ,OAAO,CAAC,aAAa,CAAC;AACzC,MAAMK,WAAW,GAAGL,OAAO,CAAC,aAAa,CAAC;AAC1C,MAAMF,OAAO,GAAGQ,MAAM,IAAKA,MAAM,CAACC,MAAM,KAAK,EAAE,GAAGD,MAAM,GAAGA,MAAM,CAACE,KAAK,CAAC,CAAC,EAAE,EAAE,CAAE;AAC/EtB,OAAO,CAACY,OAAO,GAAGA,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,kBAAkBA,CAACY,UAAU,EAAEC,KAAK,EAAEC,qBAAqB,EAAE;EACpE,MAAMC,OAAO,GAAGC,qBAAqB,CACnCH,KAAK,EACLD,UAAU,EACVE,qBACF,CAAC;EACD,IAAI;IACF,MAAMG,IAAI,GAAGC,cAAc,CAACL,KAAK,EAAEE,OAAO,CAAC;IAC3C,MAAMI,OAAO,GAAGF,IAAI,CAACG,MAAM,CAACL,OAAO,CAACM,MAAM,CAAC,CAACD,MAAM,CAACL,OAAO,CAACO,YAAY,CAAC;IACxE,OAAO;MACLC,kBAAkB,EAAE,CAAC,CAAC,EAAElB,WAAW,CAACmB,2BAA2B,EAAEL,OAAO;IAC1E,CAAC;EACH,CAAC,CAAC,OAAOM,GAAG,EAAE;IACZ,MAAM,IAAIC,KAAK,oCAAAN,MAAA,CAAoCR,UAAU,QAAAQ,MAAA,CAAKK,GAAG,CAAE,CAAC;EAC1E;AACF;AACApC,OAAO,CAACW,kBAAkB,GAAGA,kBAAkB;AAC/C,SAASD,yBAAyBA,CAAC4B,GAAG,EAAEC,WAAW,EAAE;EACnD,MAAMC,eAAe,GAAGD,WAAW,GAC/BE,MAAM,CAACC,IAAI,CAAC,CAACH,WAAW,CAAC,CAAC,GAC1BE,MAAM,CAACC,IAAI,CAAC,EAAE,CAAC;EACnB,OAAOD,MAAM,CAACV,MAAM,CAAC,CAACO,GAAG,EAAEE,eAAe,CAAC,CAAC;AAC9C;AACAxC,OAAO,CAACU,yBAAyB,GAAGA,yBAAyB;AAC7D,SAASD,cAAcA,CAACe,KAAK,EAAE;EAC7B,OACEA,KAAK,IACL,CAAC,EACCA,KAAK,CAACmB,cAAc,IACpBnB,KAAK,CAACoB,aAAa,IAClBpB,KAAK,CAACqB,aAAa,IAAIrB,KAAK,CAACqB,aAAa,CAACxB,MAAO,IAClDG,KAAK,CAACsB,kBAAkB,IAAItB,KAAK,CAACsB,kBAAkB,CAACzB,MAAO,IAC5DG,KAAK,CAACuB,WAAW,IAAI,CAAC,CAAC,EAAE/B,WAAW,CAACgC,MAAM,EAAExB,KAAK,CAACuB,WAAW,CAACf,MAAM,CAAE,CACzE;AAEL;AACAhC,OAAO,CAACS,cAAc,GAAGA,cAAc;AACvC,SAASD,eAAeA,CAACyC,MAAM,EAAEjB,MAAM,EAAE;EACvC,OACEiB,MAAM,IACN,CAAC,EACCA,MAAM,CAACN,cAAc,IACrBM,MAAM,CAACC,OAAO,IACbD,MAAM,CAACH,kBAAkB,IAAIG,MAAM,CAACH,kBAAkB,CAACzB,MAAO,IAC9DW,MAAM,IAAI,CAAC,CAAC,EAAEhB,WAAW,CAACgC,MAAM,EAAEhB,MAAM,CAAE,CAC5C;AAEL;AACAhC,OAAO,CAACQ,eAAe,GAAGA,eAAe;AACzC,SAASD,uBAAuBA,CAAC4C,SAAS,EAAEC,YAAY,EAAEC,MAAM,EAAE;EAChEC,yCAAyC,CAACH,SAAS,EAAEC,YAAY,EAAEC,MAAM,CAAC;EAC1EE,oBAAoB,CAACJ,SAAS,EAAEC,YAAY,EAAEC,MAAM,CAAC;AACvD;AACArD,OAAO,CAACO,uBAAuB,GAAGA,uBAAuB;AACzD,SAASD,wBAAwBA,CAACkD,UAAU,EAAEC,aAAa,EAAEJ,MAAM,EAAE;EACnEK,0CAA0C,CAACF,UAAU,EAAEC,aAAa,EAAEJ,MAAM,CAAC;EAC7EM,wBAAwB,CAACH,UAAU,EAAEC,aAAa,CAAC;AACrD;AACAzD,OAAO,CAACM,wBAAwB,GAAGA,wBAAwB;AAC3D,SAASqD,wBAAwBA,CAACH,UAAU,EAAEC,aAAa,EAAE;EAC3D,IAAI,CAACA,aAAa,CAACP,OAAO,IAAI,CAACO,aAAa,CAACd,cAAc,EAAE;EAC7D,MAAMA,cAAc,GAClBc,aAAa,CAACd,cAAc,IAAIa,UAAU,CAACb,cAAc;EAC3D,MAAMO,OAAO,GAAGO,aAAa,CAACP,OAAO,IAAIM,UAAU,CAACN,OAAO;EAC3D,IAAIP,cAAc,EAAE;IAClB,MAAM;MAAEX,MAAM,EAAE4B;IAAa,CAAC,GAAGJ,UAAU;IAC3C,MAAMxB,MAAM,GAAG6B,qBAAqB,CAAClB,cAAc,EAAEO,OAAO,CAAC;IAC7D,IAAIU,YAAY,IAAI,CAACA,YAAY,CAACE,MAAM,CAAC9B,MAAM,CAAC,EAC9C,MAAM,IAAIK,KAAK,CAAC,mDAAmD,CAAC;EACxE;AACF;AACA,SAASwB,qBAAqBA,CAAClB,cAAc,EAAEO,OAAO,EAAE;EACtD,MAAMa,UAAU,GAAGb,OAAO,IAAI/C,eAAe,CAAC+C,OAAO,CAACc,MAAM,CAAC;EAC7D,MAAM;IAAEf;EAAO,CAAC,GAAG,CAAC,CAAC,EAAE/B,UAAU,CAAC+C,IAAI,EAAE;IACtCC,cAAc,EAAEvB,cAAc;IAC9BoB;EACF,CAAC,CAAC;EACF,OAAOd,MAAM;AACf;AACA,SAAS5C,mBAAmBA,CAACkB,UAAU,EAAEC,KAAK,EAAE;EAC9C,MAAMmB,cAAc,GAAGnB,KAAK,CAACmB,cAAc;EAC3C,MAAMwB,SAAS,GACbxB,cAAc,IACd,CAAC,CAAC,EAAE1B,QAAQ,CAACmD,QAAQ,EAAEzB,cAAc,EAAEnB,KAAK,CAACoB,aAAa,CAAC;EAC7D,IAAI,CAACuB,SAAS,EACZ,MAAM,IAAI9B,KAAK,6CAAAN,MAAA,CAC+BR,UAAU,oBAAAQ,MAAA,CACpDY,cAAc,IAAIA,cAAc,CAAC0B,QAAQ,CAAC,KAAK,CAAC,CAEpD,CAAC;EACH,OAAOF,SAAS,CAACG,CAAC;AACpB;AACAtE,OAAO,CAACK,mBAAmB,GAAGA,mBAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,aAAaA,CAACmE,IAAI,EAAE;EAC3B,IAAI,CAAC,CAAC,CAAC,EAAE1D,OAAO,CAAC2D,SAAS,EAAED,IAAI,CAAC,EAC/B,MAAM,IAAIlC,KAAK,CACb,uEACF,CAAC;EACH,OAAOoC,cAAc,CAACF,IAAI,CAAC;AAC7B;AACAvE,OAAO,CAACI,aAAa,GAAGA,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,eAAeA,CAAA,EAAc;EAAA,IAAb6D,MAAM,GAAAU,SAAA,CAAArD,MAAA,QAAAqD,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,EAAE;EAClC,IAAIV,MAAM,CAAC3C,MAAM,KAAK,CAAC,IAAI2C,MAAM,CAAC,CAAC,CAAC,CAACY,KAAK,KAAK,CAAC,EAC9C,OAAO;IACL3B,MAAM,EAAEe,MAAM,CAAC,CAAC,CAAC,CAAChC,MAAM;IACxB6C,OAAO,EAAEb,MAAM,CAAC,CAAC,CAAC,CAACc;EACrB,CAAC;EACH,OAAOC,mBAAmB,CAACf,MAAM,CAAC;AACpC;AACAhE,OAAO,CAACG,eAAe,GAAGA,eAAe;AACzC,SAASD,wBAAwBA,CAACsB,KAAK,EAAE6B,MAAM,EAAE;EAC/C,MAAMzB,IAAI,GAAGoD,kBAAkB,CAACxD,KAAK,CAAC;EACtC,OAAOI,IAAI,CAACqD,IAAI,CAAC3C,GAAG,IAClB,CAAC,CAAC,EAAEnB,WAAW,CAAC+D,qBAAqB,EAAE5C,GAAG,EAAE6C,sBAAsB,EAAE9B,MAAM,CAC5E,CAAC;AACH;AACArD,OAAO,CAACE,wBAAwB,GAAGA,wBAAwB;AAC3D,SAASiF,sBAAsBA,CAACC,SAAS,EAAE;EACzC,OAAO;IACLA,SAAS,EAAEA,SAAS,CAAC9D,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;IACjC+D,QAAQ,EACND,SAAS,CAAC9D,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAIP,aAAa,CAACuE,WAAW,CAACC;EACxD,CAAC;AACH;AACA,SAASP,kBAAkBA,CAACxD,KAAK,EAAE;EACjC,MAAMI,IAAI,GAAG,EAAE;EACf,IAAIJ,KAAK,CAACgE,SAAS,EAAE5D,IAAI,CAAC6D,IAAI,CAACjE,KAAK,CAACgE,SAAS,CAAC;EAC/C,IAAIhE,KAAK,CAACkE,YAAY,EACpB9D,IAAI,CAAC6D,IAAI,CAAC,GAAGjE,KAAK,CAACkE,YAAY,CAACC,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACR,SAAS,CAAC,CAAC;EACxD,IAAI,CAACxD,IAAI,CAACP,MAAM,EAAE;IAChB,MAAMwE,cAAc,GAAGC,wBAAwB,CAACtE,KAAK,CAACU,kBAAkB,CAAC;IACzE,IAAI2D,cAAc,EAAEjE,IAAI,CAAC6D,IAAI,CAACI,cAAc,CAAC;EAC/C;EACA,OAAOjE,IAAI;AACb;AACA,SAASkE,wBAAwBA,CAAC5D,kBAAkB,EAAE;EACpD,IAAI,CAACA,kBAAkB,EAAE;EACzB,MAAMJ,OAAO,GAAGI,kBAAkB,CAACZ,KAAK,CAAC,CAAC,CAAC;EAC3C;EACA,IAAIQ,OAAO,CAACT,MAAM,KAAK,EAAE,IAAIS,OAAO,CAACT,MAAM,KAAK,EAAE,EAAE,OAAOS,OAAO;AACpE;AACA,SAAS2C,cAAcA,CAACF,IAAI,EAA0B;EAAA,IAAxBP,MAAM,GAAAU,SAAA,CAAArD,MAAA,QAAAqD,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,EAAE;EAAA,IAAEE,KAAK,GAAAF,SAAA,CAAArD,MAAA,QAAAqD,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,CAAC;EAClD,IAAIE,KAAK,GAAG3D,QAAQ,CAAC8E,iBAAiB,EACpC,MAAM,IAAI1D,KAAK,CAAC,6BAA6B,CAAC;EAChD,IAAI,CAACkC,IAAI,EAAE,OAAO,EAAE;EACpB,IAAI,CAAC,CAAC,EAAE1D,OAAO,CAACmF,SAAS,EAAEzB,IAAI,CAAC,EAAE;IAChCP,MAAM,CAACyB,IAAI,CAAC;MACVb,KAAK;MACLE,WAAW,EAAEP,IAAI,CAACM,OAAO,IAAI5D,QAAQ,CAACgF,sBAAsB;MAC5DjE,MAAM,EAAEuC,IAAI,CAACtB;IACf,CAAC,CAAC;IACF,OAAOe,MAAM;EACf;EACA,IAAIO,IAAI,CAAC,CAAC,CAAC,EAAEE,cAAc,CAACF,IAAI,CAAC,CAAC,CAAC,EAAEP,MAAM,EAAEY,KAAK,GAAG,CAAC,CAAC;EACvD,IAAIL,IAAI,CAAC,CAAC,CAAC,EAAEE,cAAc,CAACF,IAAI,CAAC,CAAC,CAAC,EAAEP,MAAM,EAAEY,KAAK,GAAG,CAAC,CAAC;EACvD,OAAOZ,MAAM;AACf;AACA,SAASe,mBAAmBA,CAACf,MAAM,EAAE;EACnC,IAAIO,IAAI;EACR,KAAK,MAAM2B,IAAI,IAAIlC,MAAM,EAAE;IACzBO,IAAI,GAAG4B,iBAAiB,CAACD,IAAI,EAAE3B,IAAI,CAAC;IACpC,IAAI,CAACA,IAAI,EAAE,MAAM,IAAIlC,KAAK,yCAAyC,CAAC;EACtE;EACA,OAAOkC,IAAI;AACb;AACA,SAAS4B,iBAAiBA,CAACD,IAAI,EAAE3B,IAAI,EAAa;EAAA,IAAXK,KAAK,GAAAF,SAAA,CAAArD,MAAA,QAAAqD,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,CAAC;EAC9C,IAAIE,KAAK,GAAG3D,QAAQ,CAAC8E,iBAAiB,EACpC,MAAM,IAAI1D,KAAK,CAAC,6BAA6B,CAAC;EAChD,IAAI6D,IAAI,CAACtB,KAAK,KAAKA,KAAK,EAAE;IACxB,IAAI,CAACL,IAAI,EACP,OAAO;MACLtB,MAAM,EAAEiD,IAAI,CAAClE,MAAM;MACnB6C,OAAO,EAAEqB,IAAI,CAACpB;IAChB,CAAC;IACH;EACF;EACA,IAAI,CAAC,CAAC,EAAEjE,OAAO,CAACmF,SAAS,EAAEzB,IAAI,CAAC,EAAE;EAClC,MAAM6B,QAAQ,GAAGD,iBAAiB,CAACD,IAAI,EAAE3B,IAAI,IAAIA,IAAI,CAAC,CAAC,CAAC,EAAEK,KAAK,GAAG,CAAC,CAAC;EACpE,IAAIwB,QAAQ,EAAE,OAAO,CAACA,QAAQ,EAAE7B,IAAI,IAAIA,IAAI,CAAC,CAAC,CAAC,CAAC;EAChD,MAAM8B,SAAS,GAAGF,iBAAiB,CAACD,IAAI,EAAE3B,IAAI,IAAIA,IAAI,CAAC,CAAC,CAAC,EAAEK,KAAK,GAAG,CAAC,CAAC;EACrE,IAAIyB,SAAS,EAAE,OAAO,CAAC9B,IAAI,IAAIA,IAAI,CAAC,CAAC,CAAC,EAAE8B,SAAS,CAAC;AACpD;AACA,SAAS/C,yCAAyCA,CAChDH,SAAS,EACTC,YAAY,EACZC,MAAM,EACN;EACA,MAAMiD,kBAAkB,GACtB7F,cAAc,CAAC0C,SAAS,CAAC,IAAIoD,mBAAmB,CAACnD,YAAY,CAAC;EAChE,MAAMoD,qBAAqB,GACzBD,mBAAmB,CAACpD,SAAS,CAAC,IAAI1C,cAAc,CAAC2C,YAAY,CAAC;EAChE,MAAMqD,cAAc,GAClBtD,SAAS,KAAKC,YAAY,IAC1B3C,cAAc,CAAC2C,YAAY,CAAC,IAC5BmD,mBAAmB,CAACnD,YAAY,CAAC,CAAC,CAAC;EACrC,IAAIkD,kBAAkB,IAAIE,qBAAqB,IAAIC,cAAc,EAC/D,MAAM,IAAIpE,KAAK,CACb,8BAAAN,MAAA,CAA8BsB,MAAM,2DAEtC,CAAC;AACL;AACA,SAASK,0CAA0CA,CACjDP,SAAS,EACTC,YAAY,EACZC,MAAM,EACN;EACA,MAAMiD,kBAAkB,GACtB9F,eAAe,CAAC2C,SAAS,CAAC,IAAIoD,mBAAmB,CAACnD,YAAY,CAAC;EACjE,MAAMoD,qBAAqB,GACzBD,mBAAmB,CAACpD,SAAS,CAAC,IAAI3C,eAAe,CAAC4C,YAAY,CAAC;EACjE,MAAMqD,cAAc,GAClBtD,SAAS,KAAKC,YAAY,IAC1B5C,eAAe,CAAC4C,YAAY,CAAC,IAC7BmD,mBAAmB,CAACnD,YAAY,CAAC;EACnC,IAAIkD,kBAAkB,IAAIE,qBAAqB,IAAIC,cAAc,EAC/D,MAAM,IAAIpE,KAAK,CACb,8BAAAN,MAAA,CAA8BsB,MAAM,2DAEtC,CAAC;AACL;AACA,SAASE,oBAAoBA,CAACJ,SAAS,EAAEC,YAAY,EAAEC,MAAM,EAAE;EAC7D,IAAID,YAAY,CAACR,aAAa,EAAE;IAC9B,MAAM8D,cAAc,GAAG,CAACtD,YAAY,CAACP,aAAa,IAAI,EAAE,EAAE8D,KAAK,CAACC,CAAC,IAC/DC,eAAe,CAACD,CAAC,EAAExD,YAAY,CAACR,aAAa,CAC/C,CAAC;IACD,MAAMkE,cAAc,GAAG,CAAC3D,SAAS,CAACN,aAAa,IAAI,EAAE,EAAE8D,KAAK,CAACC,CAAC,IAC5DC,eAAe,CAACD,CAAC,EAAExD,YAAY,CAACR,aAAa,CAC/C,CAAC;IACD,IAAI,CAAC8D,cAAc,IAAI,CAACI,cAAc,EACpC,MAAM,IAAIzE,KAAK,+BAAAN,MAAA,CACiBsB,MAAM,mCACtC,CAAC;EACL,CAAC,MAAM,IAAIF,SAAS,CAACP,aAAa,EAAE;IAClC,MAAM8D,cAAc,GAAG,CAACtD,YAAY,CAACP,aAAa,IAAI,EAAE,EAAE8D,KAAK,CAACC,CAAC,IAC/DC,eAAe,CAACD,CAAC,EAAEzD,SAAS,CAACP,aAAa,CAC5C,CAAC;IACD,IAAI,CAAC8D,cAAc,EACjB,MAAM,IAAIrE,KAAK,+BAAAN,MAAA,CACiBsB,MAAM,mCACtC,CAAC;EACL;AACF;AACA,SAASwD,eAAeA,CAACnF,OAAO,EAAEqF,UAAU,EAAE;EAC5C,IAAI,CAACA,UAAU,EAAE,OAAO,IAAI;EAC5B,MAAMC,QAAQ,GAAG,CAAC,CAAC,EAAE/F,QAAQ,CAACgG,WAAW,EAAE;IACzChE,MAAM,EAAEvB,OAAO,CAACM,MAAM;IACtB6C,OAAO,EAAEnD,OAAO,CAACoD;EACnB,CAAC,CAAC;EACF,MAAMoC,QAAQ,GAAG,CAAC,CAAC,EAAEjG,QAAQ,CAACkG,gBAAgB,EAC5CzF,OAAO,CAACO,YAAY,EACpB+E,QACF,CAAC;EACD,OAAOE,QAAQ,CAACpD,MAAM,CAACiD,UAAU,CAAC;AACpC;AACA,SAASlF,cAAcA,CAACL,KAAK,EAAEE,OAAO,EAAE;EACtC,MAAMsF,QAAQ,GAAG,CAAC,CAAC,EAAE/F,QAAQ,CAACgG,WAAW,EAAE;IACzChE,MAAM,EAAEvB,OAAO,CAACM,MAAM;IACtB6C,OAAO,EAAEnD,OAAO,CAACoD;EACnB,CAAC,CAAC;EACF,OAAO,CAACtD,KAAK,CAACkE,YAAY,IAAI,EAAE,EAC7B0B,MAAM,CAACC,GAAG,IAAIA,GAAG,CAACL,QAAQ,CAAClD,MAAM,CAACkD,QAAQ,CAAC,CAAC,CAC5CrB,GAAG,CAAC0B,GAAG,IAAIC,yBAAyB,CAAC5F,OAAO,CAACM,MAAM,EAAEqF,GAAG,CAAC,CAAC,CAC1DE,IAAI,CAAC,CAACC,EAAE,EAAEC,EAAE,KAAKA,EAAE,CAACC,gBAAgB,GAAGF,EAAE,CAACE,gBAAgB,CAAC,CAC3D/B,GAAG,CAACgC,CAAC,IAAIA,CAAC,CAACvC,SAAS,CAAC;AAC1B;AACA,SAASkC,yBAAyBA,CAACtF,MAAM,EAAEqF,GAAG,EAAE;EAC9C,OAAOvH,MAAM,CAAC8H,MAAM,CAClB;IACEF,gBAAgB,EAAE,CAAC,CAAC,EAAE1G,WAAW,CAAC6G,sBAAsB,EACtDR,GAAG,CAACS,MAAM,EACV9F,MACF;EACF,CAAC,EACDqF,GACF,CAAC;AACH;AACA;AACA;AACA;AACA,SAAS1F,qBAAqBA,CAACH,KAAK,EAAED,UAAU,EAAEwG,kBAAkB,EAAE;EACpE,IAAI,CAACvG,KAAK,CAACkE,YAAY,IAAI,CAAClE,KAAK,CAACkE,YAAY,CAACrE,MAAM,EACnD,MAAM,IAAIgB,KAAK,oCAAAN,MAAA,CACsBR,UAAU,4CAC/C,CAAC;EACH,MAAMG,OAAO,GAAG,CAACF,KAAK,CAACqB,aAAa,IAAI,EAAE,EACvC0E,IAAI,CAAC,CAACS,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAAC/F,YAAY,CAACZ,MAAM,GAAG4G,CAAC,CAAChG,YAAY,CAACZ,MAAM,CAAC,CAC7D6G,IAAI,CAAChC,IAAI,IACRiC,eAAe,CAACjC,IAAI,EAAE1E,KAAK,CAACkE,YAAY,EAAEqC,kBAAkB,CAC9D,CAAC;EACH,IAAI,CAACrG,OAAO,EACV,MAAM,IAAIW,KAAK,oCAAAN,MAAA,CACsBR,UAAU,8CAC/C,CAAC;EACH,OAAOG,OAAO;AAChB;AACA,SAASyG,eAAeA,CAACjC,IAAI,EAAER,YAAY,EAAE0C,IAAI,EAAE;EACjD,MAAMpB,QAAQ,GAAG,CAAC,CAAC,EAAE/F,QAAQ,CAACgG,WAAW,EAAE;IACzChE,MAAM,EAAEiD,IAAI,CAAClE,MAAM;IACnB6C,OAAO,EAAEqB,IAAI,CAACpB;EAChB,CAAC,CAAC;EACF,MAAMuD,eAAe,GAAG,CAACD,IAAI,IAAIA,IAAI,CAACtE,MAAM,CAACkD,QAAQ,CAAC;EACtD,OACEqB,eAAe,IACf3C,YAAY,CAACwC,IAAI,CAACb,GAAG,IAAIA,GAAG,CAACL,QAAQ,CAAClD,MAAM,CAACkD,QAAQ,CAAC,CAAC,KAAKrC,SAAS;AAEzE;AACA,SAAS4B,mBAAmBA,CAAC+B,EAAE,EAAE;EAC/B,OACEA,EAAE,IACF,CAAC,EACCA,EAAE,CAACC,YAAY,IACfD,EAAE,CAACE,aAAa,IACfF,EAAE,CAACG,eAAe,IAAIH,EAAE,CAACG,eAAe,CAACpH,MAAO,CAClD;AAEL"},"metadata":{},"sourceType":"script","externalDependencies":[]}