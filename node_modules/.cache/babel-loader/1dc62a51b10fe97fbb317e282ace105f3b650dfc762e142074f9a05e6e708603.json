{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeAddressToMuxedAccount = decodeAddressToMuxedAccount;\nexports.encodeMuxedAccountToAddress = encodeMuxedAccountToAddress;\nexports.encodeMuxedAccount = encodeMuxedAccount;\nexports.extractBaseAddress = extractBaseAddress;\nvar _isString = require('lodash/isString');\nvar _isString2 = _interopRequireDefault(_isString);\nvar _xdr = require('../xdr');\nvar _xdr2 = _interopRequireDefault(_xdr);\nvar _strkey = require('../strkey');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n * Converts a Stellar address (in G... or M... form) to an `xdr.MuxedAccount`\n * structure, using the ed25519 representation when possible.\n *\n * This supports full muxed accounts, where an `M...` address will resolve to\n * both its underlying `G...` address and an integer ID.\n *\n * @param   {string}  address   G... or M... address to encode into XDR\n * @returns {xdr.MuxedAccount}  a muxed account object for this address string\n */\nfunction decodeAddressToMuxedAccount(address) {\n  if (_strkey.StrKey.isValidMed25519PublicKey(address)) {\n    return _decodeAddressFullyToMuxedAccount(address);\n  }\n  return _xdr2.default.MuxedAccount.keyTypeEd25519(_strkey.StrKey.decodeEd25519PublicKey(address));\n}\n\n/**\n * Converts an xdr.MuxedAccount to its StrKey representation.\n *\n * This returns its \"M...\" string representation if there is a muxing ID within\n * the object and returns the \"G...\" representation otherwise.\n *\n * @param   {xdr.MuxedAccount} muxedAccount   Raw account to stringify\n * @returns {string} Stringified G... (corresponding to the underlying pubkey)\n *     or M... address (corresponding to both the key and the muxed ID)\n *\n * @see https://stellar.org/protocol/sep-23\n */\nfunction encodeMuxedAccountToAddress(muxedAccount) {\n  if (muxedAccount.switch().value === _xdr2.default.CryptoKeyType.keyTypeMuxedEd25519().value) {\n    return _encodeMuxedAccountFullyToAddress(muxedAccount);\n  }\n  return _strkey.StrKey.encodeEd25519PublicKey(muxedAccount.ed25519());\n}\n\n/**\n * Transform a Stellar address (G...) and an ID into its XDR representation.\n *\n * @param  {string} address   - a Stellar G... address\n * @param  {string} id        - a Uint64 ID represented as a string\n *\n * @return {xdr.MuxedAccount} - XDR representation of the above muxed account\n */\nfunction encodeMuxedAccount(address, id) {\n  if (!_strkey.StrKey.isValidEd25519PublicKey(address)) {\n    throw new Error('address should be a Stellar account ID (G...)');\n  }\n  if (!(0, _isString2.default)(id)) {\n    throw new Error('id should be a string representing a number (uint64)');\n  }\n  return _xdr2.default.MuxedAccount.keyTypeMuxedEd25519(new _xdr2.default.MuxedAccountMed25519({\n    id: _xdr2.default.Uint64.fromString(id),\n    ed25519: _strkey.StrKey.decodeEd25519PublicKey(address)\n  }));\n}\n\n/**\n * Extracts the underlying base (G...) address from an M-address.\n * @param  {string} address   an account address (either M... or G...)\n * @return {string} a Stellar public key address (G...)\n */\nfunction extractBaseAddress(address) {\n  if (_strkey.StrKey.isValidEd25519PublicKey(address)) {\n    return address;\n  }\n  if (!_strkey.StrKey.isValidMed25519PublicKey(address)) {\n    throw new TypeError('expected muxed account (M...), got ' + address);\n  }\n  var muxedAccount = decodeAddressToMuxedAccount(address);\n  return _strkey.StrKey.encodeEd25519PublicKey(muxedAccount.med25519().ed25519());\n}\n\n// Decodes an \"M...\" account ID into its MuxedAccount object representation.\nfunction _decodeAddressFullyToMuxedAccount(address) {\n  var rawBytes = _strkey.StrKey.decodeMed25519PublicKey(address);\n\n  // Decoding M... addresses cannot be done through a simple\n  // MuxedAccountMed25519.fromXDR() call, because the definition is:\n  //\n  //    constructor(attributes: { id: Uint64; ed25519: Buffer });\n  //\n  // Note the ID is the first attribute. However, the ID comes *last* in the\n  // stringified (base32-encoded) address itself (it's the last 8-byte suffix).\n  // The `fromXDR()` method interprets bytes in order, so we need to parse out\n  // the raw binary into its requisite parts, i.e. use the MuxedAccountMed25519\n  // constructor directly.\n  //\n  // Refer to https://github.com/stellar/go/blob/master/xdr/muxed_account.go#L26\n  // for the Golang implementation of the M... parsing.\n  return _xdr2.default.MuxedAccount.keyTypeMuxedEd25519(new _xdr2.default.MuxedAccountMed25519({\n    id: _xdr2.default.Uint64.fromXDR(rawBytes.slice(-8)),\n    ed25519: rawBytes.slice(0, -8)\n  }));\n}\n\n// Converts an xdr.MuxedAccount into its *true* \"M...\" string representation.\nfunction _encodeMuxedAccountFullyToAddress(muxedAccount) {\n  if (muxedAccount.switch() === _xdr2.default.CryptoKeyType.keyTypeEd25519()) {\n    return encodeMuxedAccountToAddress(muxedAccount);\n  }\n  var muxed = muxedAccount.med25519();\n  return _strkey.StrKey.encodeMed25519PublicKey(Buffer.concat([muxed.ed25519(), muxed.id().toXDR('raw')]));\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","decodeAddressToMuxedAccount","encodeMuxedAccountToAddress","encodeMuxedAccount","extractBaseAddress","_isString","require","_isString2","_interopRequireDefault","_xdr","_xdr2","_strkey","obj","__esModule","default","address","StrKey","isValidMed25519PublicKey","_decodeAddressFullyToMuxedAccount","MuxedAccount","keyTypeEd25519","decodeEd25519PublicKey","muxedAccount","switch","CryptoKeyType","keyTypeMuxedEd25519","_encodeMuxedAccountFullyToAddress","encodeEd25519PublicKey","ed25519","id","isValidEd25519PublicKey","Error","MuxedAccountMed25519","Uint64","fromString","TypeError","med25519","rawBytes","decodeMed25519PublicKey","fromXDR","slice","muxed","encodeMed25519PublicKey","Buffer","concat","toXDR"],"sources":["/workspace/Planq-Dapps/vesting-portal/node_modules/stellar-base/lib/util/decode_encode_muxed_account.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeAddressToMuxedAccount = decodeAddressToMuxedAccount;\nexports.encodeMuxedAccountToAddress = encodeMuxedAccountToAddress;\nexports.encodeMuxedAccount = encodeMuxedAccount;\nexports.extractBaseAddress = extractBaseAddress;\n\nvar _isString = require('lodash/isString');\n\nvar _isString2 = _interopRequireDefault(_isString);\n\nvar _xdr = require('../xdr');\n\nvar _xdr2 = _interopRequireDefault(_xdr);\n\nvar _strkey = require('../strkey');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Converts a Stellar address (in G... or M... form) to an `xdr.MuxedAccount`\n * structure, using the ed25519 representation when possible.\n *\n * This supports full muxed accounts, where an `M...` address will resolve to\n * both its underlying `G...` address and an integer ID.\n *\n * @param   {string}  address   G... or M... address to encode into XDR\n * @returns {xdr.MuxedAccount}  a muxed account object for this address string\n */\nfunction decodeAddressToMuxedAccount(address) {\n  if (_strkey.StrKey.isValidMed25519PublicKey(address)) {\n    return _decodeAddressFullyToMuxedAccount(address);\n  }\n\n  return _xdr2.default.MuxedAccount.keyTypeEd25519(_strkey.StrKey.decodeEd25519PublicKey(address));\n}\n\n/**\n * Converts an xdr.MuxedAccount to its StrKey representation.\n *\n * This returns its \"M...\" string representation if there is a muxing ID within\n * the object and returns the \"G...\" representation otherwise.\n *\n * @param   {xdr.MuxedAccount} muxedAccount   Raw account to stringify\n * @returns {string} Stringified G... (corresponding to the underlying pubkey)\n *     or M... address (corresponding to both the key and the muxed ID)\n *\n * @see https://stellar.org/protocol/sep-23\n */\nfunction encodeMuxedAccountToAddress(muxedAccount) {\n  if (muxedAccount.switch().value === _xdr2.default.CryptoKeyType.keyTypeMuxedEd25519().value) {\n    return _encodeMuxedAccountFullyToAddress(muxedAccount);\n  }\n\n  return _strkey.StrKey.encodeEd25519PublicKey(muxedAccount.ed25519());\n}\n\n/**\n * Transform a Stellar address (G...) and an ID into its XDR representation.\n *\n * @param  {string} address   - a Stellar G... address\n * @param  {string} id        - a Uint64 ID represented as a string\n *\n * @return {xdr.MuxedAccount} - XDR representation of the above muxed account\n */\nfunction encodeMuxedAccount(address, id) {\n  if (!_strkey.StrKey.isValidEd25519PublicKey(address)) {\n    throw new Error('address should be a Stellar account ID (G...)');\n  }\n  if (!(0, _isString2.default)(id)) {\n    throw new Error('id should be a string representing a number (uint64)');\n  }\n\n  return _xdr2.default.MuxedAccount.keyTypeMuxedEd25519(new _xdr2.default.MuxedAccountMed25519({\n    id: _xdr2.default.Uint64.fromString(id),\n    ed25519: _strkey.StrKey.decodeEd25519PublicKey(address)\n  }));\n}\n\n/**\n * Extracts the underlying base (G...) address from an M-address.\n * @param  {string} address   an account address (either M... or G...)\n * @return {string} a Stellar public key address (G...)\n */\nfunction extractBaseAddress(address) {\n  if (_strkey.StrKey.isValidEd25519PublicKey(address)) {\n    return address;\n  }\n\n  if (!_strkey.StrKey.isValidMed25519PublicKey(address)) {\n    throw new TypeError('expected muxed account (M...), got ' + address);\n  }\n\n  var muxedAccount = decodeAddressToMuxedAccount(address);\n  return _strkey.StrKey.encodeEd25519PublicKey(muxedAccount.med25519().ed25519());\n}\n\n// Decodes an \"M...\" account ID into its MuxedAccount object representation.\nfunction _decodeAddressFullyToMuxedAccount(address) {\n  var rawBytes = _strkey.StrKey.decodeMed25519PublicKey(address);\n\n  // Decoding M... addresses cannot be done through a simple\n  // MuxedAccountMed25519.fromXDR() call, because the definition is:\n  //\n  //    constructor(attributes: { id: Uint64; ed25519: Buffer });\n  //\n  // Note the ID is the first attribute. However, the ID comes *last* in the\n  // stringified (base32-encoded) address itself (it's the last 8-byte suffix).\n  // The `fromXDR()` method interprets bytes in order, so we need to parse out\n  // the raw binary into its requisite parts, i.e. use the MuxedAccountMed25519\n  // constructor directly.\n  //\n  // Refer to https://github.com/stellar/go/blob/master/xdr/muxed_account.go#L26\n  // for the Golang implementation of the M... parsing.\n  return _xdr2.default.MuxedAccount.keyTypeMuxedEd25519(new _xdr2.default.MuxedAccountMed25519({\n    id: _xdr2.default.Uint64.fromXDR(rawBytes.slice(-8)),\n    ed25519: rawBytes.slice(0, -8)\n  }));\n}\n\n// Converts an xdr.MuxedAccount into its *true* \"M...\" string representation.\nfunction _encodeMuxedAccountFullyToAddress(muxedAccount) {\n  if (muxedAccount.switch() === _xdr2.default.CryptoKeyType.keyTypeEd25519()) {\n    return encodeMuxedAccountToAddress(muxedAccount);\n  }\n\n  var muxed = muxedAccount.med25519();\n  return _strkey.StrKey.encodeMed25519PublicKey(Buffer.concat([muxed.ed25519(), muxed.id().toXDR('raw')]));\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}