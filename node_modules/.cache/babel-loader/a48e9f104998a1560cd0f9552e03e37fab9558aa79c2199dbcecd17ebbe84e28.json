{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nconst convert = require('../converter');\nconst tools_1 = require('../converter/tools');\nconst varuint = require('../converter/varint');\nconst typeFields_1 = require('../typeFields');\nfunction psbtFromBuffer(buffer, txGetter) {\n  let offset = 0;\n  function varSlice() {\n    const keyLen = varuint.decode(buffer, offset);\n    offset += varuint.encodingLength(keyLen);\n    const key = buffer.slice(offset, offset + keyLen);\n    offset += keyLen;\n    return key;\n  }\n  function readUInt32BE() {\n    const num = buffer.readUInt32BE(offset);\n    offset += 4;\n    return num;\n  }\n  function readUInt8() {\n    const num = buffer.readUInt8(offset);\n    offset += 1;\n    return num;\n  }\n  function getKeyValue() {\n    const key = varSlice();\n    const value = varSlice();\n    return {\n      key,\n      value\n    };\n  }\n  function checkEndOfKeyValPairs() {\n    if (offset >= buffer.length) {\n      throw new Error('Format Error: Unexpected End of PSBT');\n    }\n    const isEnd = buffer.readUInt8(offset) === 0;\n    if (isEnd) {\n      offset++;\n    }\n    return isEnd;\n  }\n  if (readUInt32BE() !== 0x70736274) {\n    throw new Error('Format Error: Invalid Magic Number');\n  }\n  if (readUInt8() !== 0xff) {\n    throw new Error('Format Error: Magic Number must be followed by 0xff separator');\n  }\n  const globalMapKeyVals = [];\n  const globalKeyIndex = {};\n  while (!checkEndOfKeyValPairs()) {\n    const keyVal = getKeyValue();\n    const hexKey = keyVal.key.toString('hex');\n    if (globalKeyIndex[hexKey]) {\n      throw new Error('Format Error: Keys must be unique for global keymap: key ' + hexKey);\n    }\n    globalKeyIndex[hexKey] = 1;\n    globalMapKeyVals.push(keyVal);\n  }\n  const unsignedTxMaps = globalMapKeyVals.filter(keyVal => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX);\n  if (unsignedTxMaps.length !== 1) {\n    throw new Error('Format Error: Only one UNSIGNED_TX allowed');\n  }\n  const unsignedTx = txGetter(unsignedTxMaps[0].value);\n  // Get input and output counts to loop the respective fields\n  const {\n    inputCount,\n    outputCount\n  } = unsignedTx.getInputOutputCounts();\n  const inputKeyVals = [];\n  const outputKeyVals = [];\n  // Get input fields\n  for (const index of tools_1.range(inputCount)) {\n    const inputKeyIndex = {};\n    const input = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n      if (inputKeyIndex[hexKey]) {\n        throw new Error('Format Error: Keys must be unique for each input: ' + 'input index ' + index + ' key ' + hexKey);\n      }\n      inputKeyIndex[hexKey] = 1;\n      input.push(keyVal);\n    }\n    inputKeyVals.push(input);\n  }\n  for (const index of tools_1.range(outputCount)) {\n    const outputKeyIndex = {};\n    const output = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n      if (outputKeyIndex[hexKey]) {\n        throw new Error('Format Error: Keys must be unique for each output: ' + 'output index ' + index + ' key ' + hexKey);\n      }\n      outputKeyIndex[hexKey] = 1;\n      output.push(keyVal);\n    }\n    outputKeyVals.push(output);\n  }\n  return psbtFromKeyVals(unsignedTx, {\n    globalMapKeyVals,\n    inputKeyVals,\n    outputKeyVals\n  });\n}\nexports.psbtFromBuffer = psbtFromBuffer;\nfunction checkKeyBuffer(type, keyBuf, keyNum) {\n  if (!keyBuf.equals(Buffer.from([keyNum]))) {\n    throw new Error(\"Format Error: Invalid \".concat(type, \" key: \").concat(keyBuf.toString('hex')));\n  }\n}\nexports.checkKeyBuffer = checkKeyBuffer;\nfunction psbtFromKeyVals(unsignedTx, _ref) {\n  let {\n    globalMapKeyVals,\n    inputKeyVals,\n    outputKeyVals\n  } = _ref;\n  // That was easy :-)\n  const globalMap = {\n    unsignedTx\n  };\n  let txCount = 0;\n  for (const keyVal of globalMapKeyVals) {\n    // If a globalMap item needs pubkey, uncomment\n    // const pubkey = convert.globals.checkPubkey(keyVal);\n    switch (keyVal.key[0]) {\n      case typeFields_1.GlobalTypes.UNSIGNED_TX:\n        checkKeyBuffer('global', keyVal.key, typeFields_1.GlobalTypes.UNSIGNED_TX);\n        if (txCount > 0) {\n          throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');\n        }\n        txCount++;\n        break;\n      case typeFields_1.GlobalTypes.GLOBAL_XPUB:\n        if (globalMap.globalXpub === undefined) {\n          globalMap.globalXpub = [];\n        }\n        globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));\n        break;\n      default:\n        // This will allow inclusion during serialization.\n        if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];\n        globalMap.unknownKeyVals.push(keyVal);\n    }\n  }\n  // Get input and output counts to loop the respective fields\n  const inputCount = inputKeyVals.length;\n  const outputCount = outputKeyVals.length;\n  const inputs = [];\n  const outputs = [];\n  // Get input fields\n  for (const index of tools_1.range(inputCount)) {\n    const input = {};\n    for (const keyVal of inputKeyVals[index]) {\n      convert.inputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case typeFields_1.InputTypes.NON_WITNESS_UTXO:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.NON_WITNESS_UTXO);\n          if (input.nonWitnessUtxo !== undefined) {\n            throw new Error('Format Error: Input has multiple NON_WITNESS_UTXO');\n          }\n          input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.WITNESS_UTXO:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.WITNESS_UTXO);\n          if (input.witnessUtxo !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_UTXO');\n          }\n          input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.PARTIAL_SIG:\n          if (input.partialSig === undefined) {\n            input.partialSig = [];\n          }\n          input.partialSig.push(convert.inputs.partialSig.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.SIGHASH_TYPE:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.SIGHASH_TYPE);\n          if (input.sighashType !== undefined) {\n            throw new Error('Format Error: Input has multiple SIGHASH_TYPE');\n          }\n          input.sighashType = convert.inputs.sighashType.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.REDEEM_SCRIPT);\n          if (input.redeemScript !== undefined) {\n            throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');\n          }\n          input.redeemScript = convert.inputs.redeemScript.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.WITNESS_SCRIPT);\n          if (input.witnessScript !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');\n          }\n          input.witnessScript = convert.inputs.witnessScript.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.BIP32_DERIVATION:\n          if (input.bip32Derivation === undefined) {\n            input.bip32Derivation = [];\n          }\n          input.bip32Derivation.push(convert.inputs.bip32Derivation.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.FINAL_SCRIPTSIG:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.FINAL_SCRIPTSIG);\n          input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.FINAL_SCRIPTWITNESS);\n          input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.POR_COMMITMENT:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.POR_COMMITMENT);\n          input.porCommitment = convert.inputs.porCommitment.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_KEY_SIG:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.TAP_KEY_SIG);\n          input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_SCRIPT_SIG:\n          if (input.tapScriptSig === undefined) {\n            input.tapScriptSig = [];\n          }\n          input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.TAP_LEAF_SCRIPT:\n          if (input.tapLeafScript === undefined) {\n            input.tapLeafScript = [];\n          }\n          input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.TAP_BIP32_DERIVATION:\n          if (input.tapBip32Derivation === undefined) {\n            input.tapBip32Derivation = [];\n          }\n          input.tapBip32Derivation.push(convert.inputs.tapBip32Derivation.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.TAP_INTERNAL_KEY);\n          input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_MERKLE_ROOT:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.TAP_MERKLE_ROOT);\n          input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);\n          break;\n        default:\n          // This will allow inclusion during serialization.\n          if (!input.unknownKeyVals) input.unknownKeyVals = [];\n          input.unknownKeyVals.push(keyVal);\n      }\n    }\n    inputs.push(input);\n  }\n  for (const index of tools_1.range(outputCount)) {\n    const output = {};\n    for (const keyVal of outputKeyVals[index]) {\n      convert.outputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case typeFields_1.OutputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer('output', keyVal.key, typeFields_1.OutputTypes.REDEEM_SCRIPT);\n          if (output.redeemScript !== undefined) {\n            throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');\n          }\n          output.redeemScript = convert.outputs.redeemScript.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer('output', keyVal.key, typeFields_1.OutputTypes.WITNESS_SCRIPT);\n          if (output.witnessScript !== undefined) {\n            throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');\n          }\n          output.witnessScript = convert.outputs.witnessScript.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.BIP32_DERIVATION:\n          if (output.bip32Derivation === undefined) {\n            output.bip32Derivation = [];\n          }\n          output.bip32Derivation.push(convert.outputs.bip32Derivation.decode(keyVal));\n          break;\n        case typeFields_1.OutputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer('output', keyVal.key, typeFields_1.OutputTypes.TAP_INTERNAL_KEY);\n          output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.TAP_TREE:\n          checkKeyBuffer('output', keyVal.key, typeFields_1.OutputTypes.TAP_TREE);\n          output.tapTree = convert.outputs.tapTree.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.TAP_BIP32_DERIVATION:\n          if (output.tapBip32Derivation === undefined) {\n            output.tapBip32Derivation = [];\n          }\n          output.tapBip32Derivation.push(convert.outputs.tapBip32Derivation.decode(keyVal));\n          break;\n        default:\n          if (!output.unknownKeyVals) output.unknownKeyVals = [];\n          output.unknownKeyVals.push(keyVal);\n      }\n    }\n    outputs.push(output);\n  }\n  return {\n    globalMap,\n    inputs,\n    outputs\n  };\n}\nexports.psbtFromKeyVals = psbtFromKeyVals;","map":{"version":3,"names":["Object","defineProperty","exports","value","convert","require","tools_1","varuint","typeFields_1","psbtFromBuffer","buffer","txGetter","offset","varSlice","keyLen","decode","encodingLength","key","slice","readUInt32BE","num","readUInt8","getKeyValue","checkEndOfKeyValPairs","length","Error","isEnd","globalMapKeyVals","globalKeyIndex","keyVal","hexKey","toString","push","unsignedTxMaps","filter","GlobalTypes","UNSIGNED_TX","unsignedTx","inputCount","outputCount","getInputOutputCounts","inputKeyVals","outputKeyVals","index","range","inputKeyIndex","input","outputKeyIndex","output","psbtFromKeyVals","checkKeyBuffer","type","keyBuf","keyNum","equals","Buffer","from","concat","_ref","globalMap","txCount","GLOBAL_XPUB","globalXpub","undefined","globals","unknownKeyVals","inputs","outputs","checkPubkey","InputTypes","NON_WITNESS_UTXO","nonWitnessUtxo","WITNESS_UTXO","witnessUtxo","PARTIAL_SIG","partialSig","SIGHASH_TYPE","sighashType","REDEEM_SCRIPT","redeemScript","WITNESS_SCRIPT","witnessScript","BIP32_DERIVATION","bip32Derivation","FINAL_SCRIPTSIG","finalScriptSig","FINAL_SCRIPTWITNESS","finalScriptWitness","POR_COMMITMENT","porCommitment","TAP_KEY_SIG","tapKeySig","TAP_SCRIPT_SIG","tapScriptSig","TAP_LEAF_SCRIPT","tapLeafScript","TAP_BIP32_DERIVATION","tapBip32Derivation","TAP_INTERNAL_KEY","tapInternalKey","TAP_MERKLE_ROOT","tapMerkleRoot","OutputTypes","TAP_TREE","tapTree"],"sources":["/workspace/Planq-Dapps/vesting-portal/node_modules/bip174/src/lib/parser/fromBuffer.js"],"sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst convert = require('../converter');\nconst tools_1 = require('../converter/tools');\nconst varuint = require('../converter/varint');\nconst typeFields_1 = require('../typeFields');\nfunction psbtFromBuffer(buffer, txGetter) {\n  let offset = 0;\n  function varSlice() {\n    const keyLen = varuint.decode(buffer, offset);\n    offset += varuint.encodingLength(keyLen);\n    const key = buffer.slice(offset, offset + keyLen);\n    offset += keyLen;\n    return key;\n  }\n  function readUInt32BE() {\n    const num = buffer.readUInt32BE(offset);\n    offset += 4;\n    return num;\n  }\n  function readUInt8() {\n    const num = buffer.readUInt8(offset);\n    offset += 1;\n    return num;\n  }\n  function getKeyValue() {\n    const key = varSlice();\n    const value = varSlice();\n    return {\n      key,\n      value,\n    };\n  }\n  function checkEndOfKeyValPairs() {\n    if (offset >= buffer.length) {\n      throw new Error('Format Error: Unexpected End of PSBT');\n    }\n    const isEnd = buffer.readUInt8(offset) === 0;\n    if (isEnd) {\n      offset++;\n    }\n    return isEnd;\n  }\n  if (readUInt32BE() !== 0x70736274) {\n    throw new Error('Format Error: Invalid Magic Number');\n  }\n  if (readUInt8() !== 0xff) {\n    throw new Error(\n      'Format Error: Magic Number must be followed by 0xff separator',\n    );\n  }\n  const globalMapKeyVals = [];\n  const globalKeyIndex = {};\n  while (!checkEndOfKeyValPairs()) {\n    const keyVal = getKeyValue();\n    const hexKey = keyVal.key.toString('hex');\n    if (globalKeyIndex[hexKey]) {\n      throw new Error(\n        'Format Error: Keys must be unique for global keymap: key ' + hexKey,\n      );\n    }\n    globalKeyIndex[hexKey] = 1;\n    globalMapKeyVals.push(keyVal);\n  }\n  const unsignedTxMaps = globalMapKeyVals.filter(\n    keyVal => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX,\n  );\n  if (unsignedTxMaps.length !== 1) {\n    throw new Error('Format Error: Only one UNSIGNED_TX allowed');\n  }\n  const unsignedTx = txGetter(unsignedTxMaps[0].value);\n  // Get input and output counts to loop the respective fields\n  const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();\n  const inputKeyVals = [];\n  const outputKeyVals = [];\n  // Get input fields\n  for (const index of tools_1.range(inputCount)) {\n    const inputKeyIndex = {};\n    const input = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n      if (inputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each input: ' +\n            'input index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      inputKeyIndex[hexKey] = 1;\n      input.push(keyVal);\n    }\n    inputKeyVals.push(input);\n  }\n  for (const index of tools_1.range(outputCount)) {\n    const outputKeyIndex = {};\n    const output = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n      if (outputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each output: ' +\n            'output index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      outputKeyIndex[hexKey] = 1;\n      output.push(keyVal);\n    }\n    outputKeyVals.push(output);\n  }\n  return psbtFromKeyVals(unsignedTx, {\n    globalMapKeyVals,\n    inputKeyVals,\n    outputKeyVals,\n  });\n}\nexports.psbtFromBuffer = psbtFromBuffer;\nfunction checkKeyBuffer(type, keyBuf, keyNum) {\n  if (!keyBuf.equals(Buffer.from([keyNum]))) {\n    throw new Error(\n      `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,\n    );\n  }\n}\nexports.checkKeyBuffer = checkKeyBuffer;\nfunction psbtFromKeyVals(\n  unsignedTx,\n  { globalMapKeyVals, inputKeyVals, outputKeyVals },\n) {\n  // That was easy :-)\n  const globalMap = {\n    unsignedTx,\n  };\n  let txCount = 0;\n  for (const keyVal of globalMapKeyVals) {\n    // If a globalMap item needs pubkey, uncomment\n    // const pubkey = convert.globals.checkPubkey(keyVal);\n    switch (keyVal.key[0]) {\n      case typeFields_1.GlobalTypes.UNSIGNED_TX:\n        checkKeyBuffer(\n          'global',\n          keyVal.key,\n          typeFields_1.GlobalTypes.UNSIGNED_TX,\n        );\n        if (txCount > 0) {\n          throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');\n        }\n        txCount++;\n        break;\n      case typeFields_1.GlobalTypes.GLOBAL_XPUB:\n        if (globalMap.globalXpub === undefined) {\n          globalMap.globalXpub = [];\n        }\n        globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));\n        break;\n      default:\n        // This will allow inclusion during serialization.\n        if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];\n        globalMap.unknownKeyVals.push(keyVal);\n    }\n  }\n  // Get input and output counts to loop the respective fields\n  const inputCount = inputKeyVals.length;\n  const outputCount = outputKeyVals.length;\n  const inputs = [];\n  const outputs = [];\n  // Get input fields\n  for (const index of tools_1.range(inputCount)) {\n    const input = {};\n    for (const keyVal of inputKeyVals[index]) {\n      convert.inputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case typeFields_1.InputTypes.NON_WITNESS_UTXO:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.NON_WITNESS_UTXO,\n          );\n          if (input.nonWitnessUtxo !== undefined) {\n            throw new Error(\n              'Format Error: Input has multiple NON_WITNESS_UTXO',\n            );\n          }\n          input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.WITNESS_UTXO:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.WITNESS_UTXO,\n          );\n          if (input.witnessUtxo !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_UTXO');\n          }\n          input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.PARTIAL_SIG:\n          if (input.partialSig === undefined) {\n            input.partialSig = [];\n          }\n          input.partialSig.push(convert.inputs.partialSig.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.SIGHASH_TYPE:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.SIGHASH_TYPE,\n          );\n          if (input.sighashType !== undefined) {\n            throw new Error('Format Error: Input has multiple SIGHASH_TYPE');\n          }\n          input.sighashType = convert.inputs.sighashType.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.REDEEM_SCRIPT,\n          );\n          if (input.redeemScript !== undefined) {\n            throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');\n          }\n          input.redeemScript = convert.inputs.redeemScript.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.WITNESS_SCRIPT,\n          );\n          if (input.witnessScript !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');\n          }\n          input.witnessScript = convert.inputs.witnessScript.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.BIP32_DERIVATION:\n          if (input.bip32Derivation === undefined) {\n            input.bip32Derivation = [];\n          }\n          input.bip32Derivation.push(\n            convert.inputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.InputTypes.FINAL_SCRIPTSIG:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.FINAL_SCRIPTSIG,\n          );\n          input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.FINAL_SCRIPTWITNESS,\n          );\n          input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(\n            keyVal,\n          );\n          break;\n        case typeFields_1.InputTypes.POR_COMMITMENT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.POR_COMMITMENT,\n          );\n          input.porCommitment = convert.inputs.porCommitment.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_KEY_SIG:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_KEY_SIG,\n          );\n          input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_SCRIPT_SIG:\n          if (input.tapScriptSig === undefined) {\n            input.tapScriptSig = [];\n          }\n          input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.TAP_LEAF_SCRIPT:\n          if (input.tapLeafScript === undefined) {\n            input.tapLeafScript = [];\n          }\n          input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.TAP_BIP32_DERIVATION:\n          if (input.tapBip32Derivation === undefined) {\n            input.tapBip32Derivation = [];\n          }\n          input.tapBip32Derivation.push(\n            convert.inputs.tapBip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.InputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_INTERNAL_KEY,\n          );\n          input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_MERKLE_ROOT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_MERKLE_ROOT,\n          );\n          input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);\n          break;\n        default:\n          // This will allow inclusion during serialization.\n          if (!input.unknownKeyVals) input.unknownKeyVals = [];\n          input.unknownKeyVals.push(keyVal);\n      }\n    }\n    inputs.push(input);\n  }\n  for (const index of tools_1.range(outputCount)) {\n    const output = {};\n    for (const keyVal of outputKeyVals[index]) {\n      convert.outputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case typeFields_1.OutputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.REDEEM_SCRIPT,\n          );\n          if (output.redeemScript !== undefined) {\n            throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');\n          }\n          output.redeemScript = convert.outputs.redeemScript.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.WITNESS_SCRIPT,\n          );\n          if (output.witnessScript !== undefined) {\n            throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');\n          }\n          output.witnessScript = convert.outputs.witnessScript.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.BIP32_DERIVATION:\n          if (output.bip32Derivation === undefined) {\n            output.bip32Derivation = [];\n          }\n          output.bip32Derivation.push(\n            convert.outputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.OutputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.TAP_INTERNAL_KEY,\n          );\n          output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.TAP_TREE:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.TAP_TREE,\n          );\n          output.tapTree = convert.outputs.tapTree.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.TAP_BIP32_DERIVATION:\n          if (output.tapBip32Derivation === undefined) {\n            output.tapBip32Derivation = [];\n          }\n          output.tapBip32Derivation.push(\n            convert.outputs.tapBip32Derivation.decode(keyVal),\n          );\n          break;\n        default:\n          if (!output.unknownKeyVals) output.unknownKeyVals = [];\n          output.unknownKeyVals.push(keyVal);\n      }\n    }\n    outputs.push(output);\n  }\n  return { globalMap, inputs, outputs };\n}\nexports.psbtFromKeyVals = psbtFromKeyVals;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}