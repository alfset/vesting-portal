{"ast":null,"code":"import { useEffect, useMemo, useCallback } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useActiveWeb3React } from '../../hooks';\nimport { useBlockNumber } from '../application/hooks';\nimport { addMulticallListeners, addUseChainId, removeMulticallListeners, parseCallKey, toCallKey } from './actions';\nfunction isMethodArg(x) {\n  return ['string', 'number'].indexOf(typeof x) !== -1;\n}\nfunction isValidMethodArgs(x) {\n  return x === undefined || Array.isArray(x) && x.every(xi => isMethodArg(xi) || Array.isArray(xi) && xi.every(isMethodArg));\n}\nconst INVALID_RESULT = {\n  valid: false,\n  blockNumber: undefined,\n  data: undefined\n};\n\n// use this options object\nexport const NEVER_RELOAD = {\n  blocksPerFetch: Infinity\n};\nexport function useAddDestChainId() {\n  const dispatch = useDispatch();\n  const onSelectChainId = useCallback(chainId => {\n    // console.log(field)\n    // console.log(typedValue)\n    // console.log(typeInput({ field, typedValue }))\n    dispatch(addUseChainId({\n      chainId\n    }));\n  }, [dispatch]);\n  return {\n    onSelectChainId\n  };\n}\n\n// the lowest level call for subscribing to contract data\nfunction useCallsData(calls, options, initChainId) {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const {\n    onSelectChainId\n  } = useAddDestChainId();\n  const useChainId = initChainId ? initChainId : chainId;\n  const callResults = useSelector(state => state.multicall.callResults);\n  const dispatch = useDispatch();\n  const serializedCallKeys = useMemo(() => {\n    var _calls$filter$map$sor, _calls$filter, _calls$filter$map;\n    return JSON.stringify((_calls$filter$map$sor = calls === null || calls === void 0 ? void 0 : (_calls$filter = calls.filter(c => Boolean(c))) === null || _calls$filter === void 0 ? void 0 : (_calls$filter$map = _calls$filter.map(toCallKey)) === null || _calls$filter$map === void 0 ? void 0 : _calls$filter$map.sort()) !== null && _calls$filter$map$sor !== void 0 ? _calls$filter$map$sor : []);\n  }, [calls]);\n  useEffect(() => {\n    onSelectChainId(useChainId);\n  }, [useChainId]);\n  // 当实际更改持续至少100毫秒时更新侦听器\n  useEffect(() => {\n    // console.log(chainId)\n    const callKeys = JSON.parse(serializedCallKeys);\n    if (!useChainId || callKeys.length === 0) return undefined;\n    const calls = callKeys.map(key => parseCallKey(key));\n    // console.log(calls)\n    // console.log(callKeys)\n    // console.log(serializedCallKeys)\n    dispatch(addMulticallListeners({\n      chainId: useChainId,\n      calls,\n      options\n    }));\n    return () => {\n      dispatch(removeMulticallListeners({\n        chainId: useChainId,\n        calls,\n        options\n      }));\n    };\n  }, [chainId, dispatch, options, serializedCallKeys]);\n  return useMemo(() => calls.map(call => {\n    var _callResults$useChain;\n    if (!useChainId || !call) return INVALID_RESULT;\n    const result = (_callResults$useChain = callResults[useChainId]) === null || _callResults$useChain === void 0 ? void 0 : _callResults$useChain[toCallKey(call)];\n    let data;\n    if ((result === null || result === void 0 ? void 0 : result.data) && (result === null || result === void 0 ? void 0 : result.data) !== '0x') {\n      data = result.data;\n    }\n    return {\n      valid: true,\n      data,\n      blockNumber: result === null || result === void 0 ? void 0 : result.blockNumber\n    };\n  }), [callResults, calls, useChainId]);\n}\nconst INVALID_CALL_STATE = {\n  valid: false,\n  result: undefined,\n  loading: false,\n  syncing: false,\n  error: false\n};\nconst LOADING_CALL_STATE = {\n  valid: true,\n  result: undefined,\n  loading: true,\n  syncing: true,\n  error: false\n};\nfunction toCallState(callResult, contractInterface, fragment, latestBlockNumber) {\n  if (!callResult) return INVALID_CALL_STATE;\n  const {\n    valid,\n    data,\n    blockNumber\n  } = callResult;\n  if (!valid) return INVALID_CALL_STATE;\n  if (valid && !blockNumber) return LOADING_CALL_STATE;\n  if (!contractInterface || !fragment || !latestBlockNumber) return LOADING_CALL_STATE;\n  const success = data && data.length > 2;\n  const syncing = (blockNumber !== null && blockNumber !== void 0 ? blockNumber : 0) < latestBlockNumber;\n  let result = undefined;\n  if (success && data) {\n    try {\n      result = contractInterface.decodeFunctionResult(fragment, data);\n    } catch (error) {\n      console.debug('Result data parsing failed', fragment, data);\n      return {\n        valid: true,\n        loading: false,\n        error: true,\n        syncing,\n        result\n      };\n    }\n  }\n  return {\n    valid: true,\n    loading: false,\n    syncing,\n    result: result,\n    error: !success\n  };\n}\nexport function useSingleContractMultipleData(contract, methodName, callInputs, options, chainId) {\n  const fragment = useMemo(() => {\n    var _contract$interface;\n    return contract === null || contract === void 0 ? void 0 : (_contract$interface = contract.interface) === null || _contract$interface === void 0 ? void 0 : _contract$interface.getFunction(methodName);\n  }, [contract, methodName]);\n  const calls = useMemo(() => contract && fragment && callInputs && callInputs.length > 0 ? callInputs.map(inputs => {\n    return {\n      address: contract.address,\n      callData: contract.interface.encodeFunctionData(fragment, inputs)\n    };\n  }) : [], [callInputs, contract, fragment]);\n  const results = useCallsData(calls, options, chainId);\n  // console.log(results)\n  const latestBlockNumber = useBlockNumber();\n  return useMemo(() => {\n    return results.map(result => toCallState(result, contract === null || contract === void 0 ? void 0 : contract.interface, fragment, latestBlockNumber));\n  }, [fragment, contract, results, latestBlockNumber]);\n}\nexport function useMultipleContractSingleData(addresses, contractInterface, methodName, callInputs, options, chainId) {\n  const fragment = useMemo(() => contractInterface.getFunction(methodName), [contractInterface, methodName]);\n  // console.log(callInputs)\n  const callData = useMemo(() => fragment && isValidMethodArgs(callInputs) ? contractInterface.encodeFunctionData(fragment, callInputs) : undefined, [callInputs, contractInterface, fragment]);\n  // console.log(fragment)\n  // console.log(callInputs)\n  // console.log(contractInterface)\n  // console.log(callData)\n  // console.log(contractInterface.encodeFunctionData(fragment, callInputs))\n  const calls = useMemo(() => fragment && addresses && addresses.length > 0 && callData ? addresses.map(address => {\n    return address && callData ? {\n      address,\n      callData\n    } : undefined;\n  }) : [], [addresses, callData, fragment]);\n  // console.log(calls)\n  const results = useCallsData(calls, options, chainId);\n  // if (methodName === 'balanceOf') {\n  // if (methodName === 'getReserves') {\n  //   console.log(methodName)\n  //   console.log(addresses)\n  // }\n  const latestBlockNumber = useBlockNumber();\n  return useMemo(() => {\n    return results.map(result => toCallState(result, contractInterface, fragment, latestBlockNumber));\n  }, [fragment, results, contractInterface, latestBlockNumber]);\n}\nexport function useSingleCallResult(contract, methodName, inputs, options, chainId) {\n  const fragment = useMemo(() => {\n    var _contract$interface2;\n    return contract === null || contract === void 0 ? void 0 : (_contract$interface2 = contract.interface) === null || _contract$interface2 === void 0 ? void 0 : _contract$interface2.getFunction(methodName);\n  }, [contract, methodName]);\n  const calls = useMemo(() => {\n    return contract && fragment && isValidMethodArgs(inputs) ? [{\n      address: contract.address,\n      callData: contract.interface.encodeFunctionData(fragment, inputs)\n    }] : [];\n  }, [contract, fragment, inputs]);\n  const result = useCallsData(calls, options, chainId)[0];\n  const latestBlockNumber = useBlockNumber();\n  return useMemo(() => {\n    return toCallState(result, contract === null || contract === void 0 ? void 0 : contract.interface, fragment, latestBlockNumber);\n  }, [result, contract, fragment, latestBlockNumber]);\n}","map":{"version":3,"names":["useEffect","useMemo","useCallback","useDispatch","useSelector","useActiveWeb3React","useBlockNumber","addMulticallListeners","addUseChainId","removeMulticallListeners","parseCallKey","toCallKey","isMethodArg","x","indexOf","isValidMethodArgs","undefined","Array","isArray","every","xi","INVALID_RESULT","valid","blockNumber","data","NEVER_RELOAD","blocksPerFetch","Infinity","useAddDestChainId","dispatch","onSelectChainId","chainId","useCallsData","calls","options","initChainId","useChainId","callResults","state","multicall","serializedCallKeys","_calls$filter$map$sor","_calls$filter","_calls$filter$map","JSON","stringify","filter","c","Boolean","map","sort","callKeys","parse","length","key","call","_callResults$useChain","result","INVALID_CALL_STATE","loading","syncing","error","LOADING_CALL_STATE","toCallState","callResult","contractInterface","fragment","latestBlockNumber","success","decodeFunctionResult","console","debug","useSingleContractMultipleData","contract","methodName","callInputs","_contract$interface","interface","getFunction","inputs","address","callData","encodeFunctionData","results","useMultipleContractSingleData","addresses","useSingleCallResult","_contract$interface2"],"sources":["/workspace/Planq-Dapps/vesting-portal/src/state/multicall/hooks.ts"],"sourcesContent":["import { Interface, FunctionFragment } from '@ethersproject/abi'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { Contract } from '@ethersproject/contracts'\nimport { useEffect, useMemo, useCallback } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { useActiveWeb3React } from '../../hooks'\nimport { useBlockNumber } from '../application/hooks'\nimport { AppDispatch, AppState } from '../index'\nimport {\n  addMulticallListeners,\n  addUseChainId,\n  Call,\n  removeMulticallListeners,\n  parseCallKey,\n  toCallKey,\n  ListenerOptions\n} from './actions'\n\nexport interface Result extends ReadonlyArray<any> {\n  readonly [key: string]: any\n}\n\ntype MethodArg = string | number | BigNumber\ntype MethodArgs = Array<MethodArg | MethodArg[]>\n\ntype OptionalMethodInputs = Array<MethodArg | MethodArg[] | undefined> | undefined\n\nfunction isMethodArg(x: unknown): x is MethodArg {\n  return ['string', 'number'].indexOf(typeof x) !== -1\n}\n\nfunction isValidMethodArgs(x: unknown): x is MethodArgs | undefined {\n  return (\n    x === undefined ||\n    (Array.isArray(x) && x.every(xi => isMethodArg(xi) || (Array.isArray(xi) && xi.every(isMethodArg))))\n  )\n}\n\ninterface CallResult {\n  readonly valid: boolean\n  readonly data: string | undefined\n  readonly blockNumber: number | undefined\n}\n\nconst INVALID_RESULT: CallResult = { valid: false, blockNumber: undefined, data: undefined }\n\n// use this options object\nexport const NEVER_RELOAD: ListenerOptions = {\n  blocksPerFetch: Infinity\n}\n\nexport function useAddDestChainId (): {\n  onSelectChainId: (chainId:any) => void\n} {\n  const dispatch = useDispatch<AppDispatch>()\n  const onSelectChainId = useCallback(\n    (chainId:any) => {\n      // console.log(field)\n      // console.log(typedValue)\n      // console.log(typeInput({ field, typedValue }))\n      dispatch(addUseChainId({ chainId }))\n    },\n    [dispatch]\n  )\n\n  return {\n    onSelectChainId\n  }\n}\n\n// the lowest level call for subscribing to contract data\nfunction useCallsData(calls: (Call | undefined)[], options?: ListenerOptions, initChainId?:any): CallResult[] {\n  const { chainId } = useActiveWeb3React()\n  const {onSelectChainId} = useAddDestChainId()\n  const useChainId = initChainId ? initChainId : chainId\n  const callResults = useSelector<AppState, AppState['multicall']['callResults']>(state => state.multicall.callResults)\n  const dispatch = useDispatch<AppDispatch>()\n\n  const serializedCallKeys: string = useMemo(\n    () =>\n      JSON.stringify(\n        calls\n          ?.filter((c): c is Call => Boolean(c))\n          ?.map(toCallKey)\n          ?.sort() ?? []\n      ),\n    [calls]\n  )\n\n  useEffect(() => {\n    onSelectChainId(useChainId)\n  }, [useChainId])\n  // 当实际更改持续至少100毫秒时更新侦听器\n  useEffect(() => {\n    // console.log(chainId)\n    const callKeys: string[] = JSON.parse(serializedCallKeys)\n    if (!useChainId || callKeys.length === 0) return undefined\n    const calls = callKeys.map(key => parseCallKey(key))\n    // console.log(calls)\n    // console.log(callKeys)\n    // console.log(serializedCallKeys)\n    dispatch(\n      addMulticallListeners({\n        chainId: useChainId,\n        calls,\n        options\n      })\n    )\n\n    return () => {\n      dispatch(\n        removeMulticallListeners({\n          chainId: useChainId,\n          calls,\n          options\n        })\n      )\n    }\n  }, [chainId, dispatch, options, serializedCallKeys])\n\n  return useMemo(\n    () =>\n      calls.map<CallResult>(call => {\n        if (!useChainId || !call) return INVALID_RESULT\n\n        const result = callResults[useChainId]?.[toCallKey(call)]\n        let data\n        if (result?.data && result?.data !== '0x') {\n          data = result.data\n        }\n\n        return { valid: true, data, blockNumber: result?.blockNumber }\n      }),\n    [callResults, calls, useChainId]\n  )\n}\n\ninterface CallState {\n  readonly valid: boolean\n  // the result, or undefined if loading or errored/no data\n  readonly result: Result | undefined\n  // true if the result has never been fetched\n  readonly loading: boolean\n  // true if the result is not for the latest block\n  readonly syncing: boolean\n  // true if the call was made and is synced, but the return data is invalid\n  readonly error: boolean\n}\n\nconst INVALID_CALL_STATE: CallState = { valid: false, result: undefined, loading: false, syncing: false, error: false }\nconst LOADING_CALL_STATE: CallState = { valid: true, result: undefined, loading: true, syncing: true, error: false }\n\nfunction toCallState(\n  callResult: CallResult | undefined,\n  contractInterface: Interface | undefined,\n  fragment: FunctionFragment | undefined,\n  latestBlockNumber: number | undefined\n): CallState {\n  if (!callResult) return INVALID_CALL_STATE\n  const { valid, data, blockNumber } = callResult\n  if (!valid) return INVALID_CALL_STATE\n  if (valid && !blockNumber) return LOADING_CALL_STATE\n  if (!contractInterface || !fragment || !latestBlockNumber) return LOADING_CALL_STATE\n  const success = data && data.length > 2\n  const syncing = (blockNumber ?? 0) < latestBlockNumber\n  let result: Result | undefined = undefined\n  if (success && data) {\n    try {\n      result = contractInterface.decodeFunctionResult(fragment, data)\n    } catch (error) {\n      console.debug('Result data parsing failed', fragment, data)\n      return {\n        valid: true,\n        loading: false,\n        error: true,\n        syncing,\n        result\n      }\n    }\n  }\n  return {\n    valid: true,\n    loading: false,\n    syncing,\n    result: result,\n    error: !success\n  }\n}\n\nexport function useSingleContractMultipleData(\n  contract: Contract | null | undefined,\n  methodName: string,\n  callInputs: OptionalMethodInputs[],\n  options?: ListenerOptions,\n  chainId?: any\n): CallState[] {\n  const fragment = useMemo(() => contract?.interface?.getFunction(methodName), [contract, methodName])\n\n  const calls = useMemo(\n    () =>\n      contract && fragment && callInputs && callInputs.length > 0\n        ? callInputs.map<Call>(inputs => {\n            return {\n              address: contract.address,\n              callData: contract.interface.encodeFunctionData(fragment, inputs)\n            }\n          })\n        : [],\n    [callInputs, contract, fragment]\n  )\n  const results = useCallsData(calls, options, chainId)\n          // console.log(results)\n  const latestBlockNumber = useBlockNumber()\n\n  return useMemo(() => {\n    return results.map(result => toCallState(result, contract?.interface, fragment, latestBlockNumber))\n  }, [fragment, contract, results, latestBlockNumber])\n}\n\nexport function useMultipleContractSingleData(\n  addresses: (string | undefined)[],\n  contractInterface: Interface,\n  methodName: string,\n  callInputs?: OptionalMethodInputs,\n  options?: ListenerOptions,\n  chainId?: any\n): CallState[] {\n  const fragment = useMemo(() => contractInterface.getFunction(methodName), [contractInterface, methodName])\n  // console.log(callInputs)\n  const callData: string | undefined = useMemo(\n    () =>\n      fragment && isValidMethodArgs(callInputs)\n        ? contractInterface.encodeFunctionData(fragment, callInputs)\n        : undefined,\n    [callInputs, contractInterface, fragment]\n  )\n    // console.log(fragment)\n    // console.log(callInputs)\n    // console.log(contractInterface)\n    // console.log(callData)\n    // console.log(contractInterface.encodeFunctionData(fragment, callInputs))\n  const calls = useMemo(\n    () =>\n      fragment && addresses && addresses.length > 0 && callData\n        ? addresses.map<Call | undefined>(address => {\n            return address && callData\n              ? {\n                  address,\n                  callData\n                }\n              : undefined\n          })\n        : [],\n    [addresses, callData, fragment]\n  )\n          // console.log(calls)\n  const results = useCallsData(calls, options, chainId)\n  // if (methodName === 'balanceOf') {\n  // if (methodName === 'getReserves') {\n  //   console.log(methodName)\n  //   console.log(addresses)\n  // }\n  const latestBlockNumber = useBlockNumber()\n\n  return useMemo(() => {\n    return results.map(result => toCallState(result, contractInterface, fragment, latestBlockNumber))\n  }, [fragment, results, contractInterface, latestBlockNumber])\n}\n\nexport function useSingleCallResult(\n  contract: Contract | null | undefined,\n  methodName: string,\n  inputs?: OptionalMethodInputs,\n  options?: ListenerOptions,\n  chainId?: any\n): CallState {\n  const fragment = useMemo(() => contract?.interface?.getFunction(methodName), [contract, methodName])\n\n  const calls = useMemo<Call[]>(() => {\n    return contract && fragment && isValidMethodArgs(inputs)\n      ? [\n          {\n            address: contract.address,\n            callData: contract.interface.encodeFunctionData(fragment, inputs)\n          }\n        ]\n      : []\n  }, [contract, fragment, inputs])\n\n  const result = useCallsData(calls, options, chainId)[0]\n  const latestBlockNumber = useBlockNumber()\n\n  return useMemo(() => {\n    return toCallState(result, contract?.interface, fragment, latestBlockNumber)\n  }, [result, contract, fragment, latestBlockNumber])\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}