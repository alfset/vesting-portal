{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.p2tr = void 0;\nconst buffer_1 = require('buffer');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst ecc_lib_1 = require('../ecc_lib');\nconst bip341_1 = require('./bip341');\nconst lazy = require('./lazy');\nconst bech32_1 = require('bech32');\nconst OPS = bscript.OPS;\nconst TAPROOT_WITNESS_VERSION = 0x01;\nconst ANNEX_PREFIX = 0x50;\nfunction p2tr(a, opts) {\n  if (!a.address && !a.output && !a.pubkey && !a.internalPubkey && !(a.witness && a.witness.length > 1)) throw new TypeError('Not enough data');\n  opts = Object.assign({\n    validate: true\n  }, opts || {});\n  (0, types_1.typeforce)({\n    address: types_1.typeforce.maybe(types_1.typeforce.String),\n    input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),\n    network: types_1.typeforce.maybe(types_1.typeforce.Object),\n    output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),\n    internalPubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n    hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n    pubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n    signature: types_1.typeforce.maybe(types_1.typeforce.anyOf(types_1.typeforce.BufferN(64), types_1.typeforce.BufferN(65))),\n    witness: types_1.typeforce.maybe(types_1.typeforce.arrayOf(types_1.typeforce.Buffer)),\n    scriptTree: types_1.typeforce.maybe(types_1.isTaptree),\n    redeem: types_1.typeforce.maybe({\n      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n      redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),\n      witness: types_1.typeforce.maybe(types_1.typeforce.arrayOf(types_1.typeforce.Buffer))\n    }),\n    redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number)\n  }, a);\n  const _address = lazy.value(() => {\n    const result = bech32_1.bech32m.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32_1.bech32m.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: buffer_1.Buffer.from(data)\n    };\n  });\n  // remove annex if present, ignored by taproot\n  const _witness = lazy.value(() => {\n    if (!a.witness || !a.witness.length) return;\n    if (a.witness.length >= 2 && a.witness[a.witness.length - 1][0] === ANNEX_PREFIX) {\n      return a.witness.slice(0, -1);\n    }\n    return a.witness.slice();\n  });\n  const _hashTree = lazy.value(() => {\n    if (a.scriptTree) return (0, bip341_1.toHashTree)(a.scriptTree);\n    if (a.hash) return {\n      hash: a.hash\n    };\n    return;\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = {\n    name: 'p2tr',\n    network\n  };\n  lazy.prop(o, 'address', () => {\n    if (!o.pubkey) return;\n    const words = bech32_1.bech32m.toWords(o.pubkey);\n    words.unshift(TAPROOT_WITNESS_VERSION);\n    return bech32_1.bech32m.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    const hashTree = _hashTree();\n    if (hashTree) return hashTree.hash;\n    const w = _witness();\n    if (w && w.length > 1) {\n      const controlBlock = w[w.length - 1];\n      const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;\n      const script = w[w.length - 2];\n      const leafHash = (0, bip341_1.tapleafHash)({\n        output: script,\n        version: leafVersion\n      });\n      return (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);\n    }\n    return null;\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.pubkey) return;\n    return bscript.compile([OPS.OP_1, o.pubkey]);\n  });\n  lazy.prop(o, 'redeemVersion', () => {\n    if (a.redeemVersion) return a.redeemVersion;\n    if (a.redeem && a.redeem.redeemVersion !== undefined && a.redeem.redeemVersion !== null) {\n      return a.redeem.redeemVersion;\n    }\n    return bip341_1.LEAF_VERSION_TAPSCRIPT;\n  });\n  lazy.prop(o, 'redeem', () => {\n    const witness = _witness(); // witness without annex\n    if (!witness || witness.length < 2) return;\n    return {\n      output: witness[witness.length - 2],\n      witness: witness.slice(0, -2),\n      redeemVersion: witness[witness.length - 1][0] & types_1.TAPLEAF_VERSION_MASK\n    };\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (a.output) return a.output.slice(2);\n    if (a.address) return _address().data;\n    if (o.internalPubkey) {\n      const tweakedKey = (0, bip341_1.tweakKey)(o.internalPubkey, o.hash);\n      if (tweakedKey) return tweakedKey.x;\n    }\n  });\n  lazy.prop(o, 'internalPubkey', () => {\n    if (a.internalPubkey) return a.internalPubkey;\n    const witness = _witness();\n    if (witness && witness.length > 1) return witness[witness.length - 1].slice(1, 33);\n  });\n  lazy.prop(o, 'signature', () => {\n    if (a.signature) return a.signature;\n    const witness = _witness(); // witness without annex\n    if (!witness || witness.length !== 1) return;\n    return witness[0];\n  });\n  lazy.prop(o, 'witness', () => {\n    if (a.witness) return a.witness;\n    const hashTree = _hashTree();\n    if (hashTree && a.redeem && a.redeem.output && a.internalPubkey) {\n      const leafHash = (0, bip341_1.tapleafHash)({\n        output: a.redeem.output,\n        version: o.redeemVersion\n      });\n      const path = (0, bip341_1.findScriptPath)(hashTree, leafHash);\n      if (!path) return;\n      const outputKey = (0, bip341_1.tweakKey)(a.internalPubkey, hashTree.hash);\n      if (!outputKey) return;\n      const controlBock = buffer_1.Buffer.concat([buffer_1.Buffer.from([o.redeemVersion | outputKey.parity]), a.internalPubkey].concat(path));\n      return [a.redeem.output, controlBock];\n    }\n    if (a.signature) return [a.signature];\n  });\n  // extended validation\n  if (opts.validate) {\n    let pubkey = buffer_1.Buffer.from([]);\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix) throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== TAPROOT_WITNESS_VERSION) throw new TypeError('Invalid address version');\n      if (_address().data.length !== 32) throw new TypeError('Invalid address data');\n      pubkey = _address().data;\n    }\n    if (a.pubkey) {\n      if (pubkey.length > 0 && !pubkey.equals(a.pubkey)) throw new TypeError('Pubkey mismatch');else pubkey = a.pubkey;\n    }\n    if (a.output) {\n      if (a.output.length !== 34 || a.output[0] !== OPS.OP_1 || a.output[1] !== 0x20) throw new TypeError('Output is invalid');\n      if (pubkey.length > 0 && !pubkey.equals(a.output.slice(2))) throw new TypeError('Pubkey mismatch');else pubkey = a.output.slice(2);\n    }\n    if (a.internalPubkey) {\n      const tweakedKey = (0, bip341_1.tweakKey)(a.internalPubkey, o.hash);\n      if (pubkey.length > 0 && !pubkey.equals(tweakedKey.x)) throw new TypeError('Pubkey mismatch');else pubkey = tweakedKey.x;\n    }\n    if (pubkey && pubkey.length) {\n      if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(pubkey)) throw new TypeError('Invalid pubkey for p2tr');\n    }\n    const hashTree = _hashTree();\n    if (a.hash && hashTree) {\n      if (!a.hash.equals(hashTree.hash)) throw new TypeError('Hash mismatch');\n    }\n    if (a.redeem && a.redeem.output && hashTree) {\n      const leafHash = (0, bip341_1.tapleafHash)({\n        output: a.redeem.output,\n        version: o.redeemVersion\n      });\n      if (!(0, bip341_1.findScriptPath)(hashTree, leafHash)) throw new TypeError('Redeem script not in tree');\n    }\n    const witness = _witness();\n    // compare the provided redeem data with the one computed from witness\n    if (a.redeem && o.redeem) {\n      if (a.redeem.redeemVersion) {\n        if (a.redeem.redeemVersion !== o.redeem.redeemVersion) throw new TypeError('Redeem.redeemVersion and witness mismatch');\n      }\n      if (a.redeem.output) {\n        if (bscript.decompile(a.redeem.output).length === 0) throw new TypeError('Redeem.output is invalid');\n        // output redeem is constructed from the witness\n        if (o.redeem.output && !a.redeem.output.equals(o.redeem.output)) throw new TypeError('Redeem.output and witness mismatch');\n      }\n      if (a.redeem.witness) {\n        if (o.redeem.witness && !stacksEqual(a.redeem.witness, o.redeem.witness)) throw new TypeError('Redeem.witness and witness mismatch');\n      }\n    }\n    if (witness && witness.length) {\n      if (witness.length === 1) {\n        // key spending\n        if (a.signature && !a.signature.equals(witness[0])) throw new TypeError('Signature mismatch');\n      } else {\n        // script path spending\n        const controlBlock = witness[witness.length - 1];\n        if (controlBlock.length < 33) throw new TypeError(\"The control-block length is too small. Got \".concat(controlBlock.length, \", expected min 33.\"));\n        if ((controlBlock.length - 33) % 32 !== 0) throw new TypeError(\"The control-block length of \".concat(controlBlock.length, \" is incorrect!\"));\n        const m = (controlBlock.length - 33) / 32;\n        if (m > 128) throw new TypeError(\"The script path is too long. Got \".concat(m, \", expected max 128.\"));\n        const internalPubkey = controlBlock.slice(1, 33);\n        if (a.internalPubkey && !a.internalPubkey.equals(internalPubkey)) throw new TypeError('Internal pubkey mismatch');\n        if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(internalPubkey)) throw new TypeError('Invalid internalPubkey for p2tr witness');\n        const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;\n        const script = witness[witness.length - 2];\n        const leafHash = (0, bip341_1.tapleafHash)({\n          output: script,\n          version: leafVersion\n        });\n        const hash = (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);\n        const outputKey = (0, bip341_1.tweakKey)(internalPubkey, hash);\n        if (!outputKey)\n          // todo: needs test data\n          throw new TypeError('Invalid outputKey for p2tr witness');\n        if (pubkey.length && !pubkey.equals(outputKey.x)) throw new TypeError('Pubkey mismatch for p2tr witness');\n        if (outputKey.parity !== (controlBlock[0] & 1)) throw new Error('Incorrect parity');\n      }\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2tr = p2tr;\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","p2tr","buffer_1","require","networks_1","bscript","types_1","ecc_lib_1","bip341_1","lazy","bech32_1","OPS","TAPROOT_WITNESS_VERSION","ANNEX_PREFIX","a","opts","address","output","pubkey","internalPubkey","witness","length","TypeError","assign","validate","typeforce","maybe","String","input","BufferN","network","hash","signature","anyOf","arrayOf","Buffer","scriptTree","isTaptree","redeem","redeemVersion","Number","_address","result","bech32m","decode","version","words","shift","data","fromWords","prefix","from","_witness","slice","_hashTree","toHashTree","bitcoin","o","name","prop","toWords","unshift","encode","bech32","hashTree","w","controlBlock","leafVersion","TAPLEAF_VERSION_MASK","script","leafHash","tapleafHash","rootHashFromPath","compile","OP_1","undefined","LEAF_VERSION_TAPSCRIPT","tweakedKey","tweakKey","x","path","findScriptPath","outputKey","controlBock","concat","parity","equals","getEccLib","isXOnlyPoint","decompile","stacksEqual","m","Error","b","every","i"],"sources":["/workspace/Planq-Dapps/vesting-portal/node_modules/bitcoinjs-lib/src/payments/p2tr.js"],"sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2tr = void 0;\nconst buffer_1 = require('buffer');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst ecc_lib_1 = require('../ecc_lib');\nconst bip341_1 = require('./bip341');\nconst lazy = require('./lazy');\nconst bech32_1 = require('bech32');\nconst OPS = bscript.OPS;\nconst TAPROOT_WITNESS_VERSION = 0x01;\nconst ANNEX_PREFIX = 0x50;\nfunction p2tr(a, opts) {\n  if (\n    !a.address &&\n    !a.output &&\n    !a.pubkey &&\n    !a.internalPubkey &&\n    !(a.witness && a.witness.length > 1)\n  )\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),\n      internalPubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n      pubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n      signature: types_1.typeforce.maybe(\n        types_1.typeforce.anyOf(\n          types_1.typeforce.BufferN(64),\n          types_1.typeforce.BufferN(65),\n        ),\n      ),\n      witness: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n      scriptTree: types_1.typeforce.maybe(types_1.isTaptree),\n      redeem: types_1.typeforce.maybe({\n        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),\n        witness: types_1.typeforce.maybe(\n          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n        ),\n      }),\n      redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32_1.bech32m.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32_1.bech32m.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: buffer_1.Buffer.from(data),\n    };\n  });\n  // remove annex if present, ignored by taproot\n  const _witness = lazy.value(() => {\n    if (!a.witness || !a.witness.length) return;\n    if (\n      a.witness.length >= 2 &&\n      a.witness[a.witness.length - 1][0] === ANNEX_PREFIX\n    ) {\n      return a.witness.slice(0, -1);\n    }\n    return a.witness.slice();\n  });\n  const _hashTree = lazy.value(() => {\n    if (a.scriptTree) return (0, bip341_1.toHashTree)(a.scriptTree);\n    if (a.hash) return { hash: a.hash };\n    return;\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2tr', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.pubkey) return;\n    const words = bech32_1.bech32m.toWords(o.pubkey);\n    words.unshift(TAPROOT_WITNESS_VERSION);\n    return bech32_1.bech32m.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    const hashTree = _hashTree();\n    if (hashTree) return hashTree.hash;\n    const w = _witness();\n    if (w && w.length > 1) {\n      const controlBlock = w[w.length - 1];\n      const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;\n      const script = w[w.length - 2];\n      const leafHash = (0, bip341_1.tapleafHash)({\n        output: script,\n        version: leafVersion,\n      });\n      return (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);\n    }\n    return null;\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.pubkey) return;\n    return bscript.compile([OPS.OP_1, o.pubkey]);\n  });\n  lazy.prop(o, 'redeemVersion', () => {\n    if (a.redeemVersion) return a.redeemVersion;\n    if (\n      a.redeem &&\n      a.redeem.redeemVersion !== undefined &&\n      a.redeem.redeemVersion !== null\n    ) {\n      return a.redeem.redeemVersion;\n    }\n    return bip341_1.LEAF_VERSION_TAPSCRIPT;\n  });\n  lazy.prop(o, 'redeem', () => {\n    const witness = _witness(); // witness without annex\n    if (!witness || witness.length < 2) return;\n    return {\n      output: witness[witness.length - 2],\n      witness: witness.slice(0, -2),\n      redeemVersion:\n        witness[witness.length - 1][0] & types_1.TAPLEAF_VERSION_MASK,\n    };\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (a.output) return a.output.slice(2);\n    if (a.address) return _address().data;\n    if (o.internalPubkey) {\n      const tweakedKey = (0, bip341_1.tweakKey)(o.internalPubkey, o.hash);\n      if (tweakedKey) return tweakedKey.x;\n    }\n  });\n  lazy.prop(o, 'internalPubkey', () => {\n    if (a.internalPubkey) return a.internalPubkey;\n    const witness = _witness();\n    if (witness && witness.length > 1)\n      return witness[witness.length - 1].slice(1, 33);\n  });\n  lazy.prop(o, 'signature', () => {\n    if (a.signature) return a.signature;\n    const witness = _witness(); // witness without annex\n    if (!witness || witness.length !== 1) return;\n    return witness[0];\n  });\n  lazy.prop(o, 'witness', () => {\n    if (a.witness) return a.witness;\n    const hashTree = _hashTree();\n    if (hashTree && a.redeem && a.redeem.output && a.internalPubkey) {\n      const leafHash = (0, bip341_1.tapleafHash)({\n        output: a.redeem.output,\n        version: o.redeemVersion,\n      });\n      const path = (0, bip341_1.findScriptPath)(hashTree, leafHash);\n      if (!path) return;\n      const outputKey = (0, bip341_1.tweakKey)(a.internalPubkey, hashTree.hash);\n      if (!outputKey) return;\n      const controlBock = buffer_1.Buffer.concat(\n        [\n          buffer_1.Buffer.from([o.redeemVersion | outputKey.parity]),\n          a.internalPubkey,\n        ].concat(path),\n      );\n      return [a.redeem.output, controlBock];\n    }\n    if (a.signature) return [a.signature];\n  });\n  // extended validation\n  if (opts.validate) {\n    let pubkey = buffer_1.Buffer.from([]);\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== TAPROOT_WITNESS_VERSION)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 32)\n        throw new TypeError('Invalid address data');\n      pubkey = _address().data;\n    }\n    if (a.pubkey) {\n      if (pubkey.length > 0 && !pubkey.equals(a.pubkey))\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = a.pubkey;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 34 ||\n        a.output[0] !== OPS.OP_1 ||\n        a.output[1] !== 0x20\n      )\n        throw new TypeError('Output is invalid');\n      if (pubkey.length > 0 && !pubkey.equals(a.output.slice(2)))\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = a.output.slice(2);\n    }\n    if (a.internalPubkey) {\n      const tweakedKey = (0, bip341_1.tweakKey)(a.internalPubkey, o.hash);\n      if (pubkey.length > 0 && !pubkey.equals(tweakedKey.x))\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = tweakedKey.x;\n    }\n    if (pubkey && pubkey.length) {\n      if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(pubkey))\n        throw new TypeError('Invalid pubkey for p2tr');\n    }\n    const hashTree = _hashTree();\n    if (a.hash && hashTree) {\n      if (!a.hash.equals(hashTree.hash)) throw new TypeError('Hash mismatch');\n    }\n    if (a.redeem && a.redeem.output && hashTree) {\n      const leafHash = (0, bip341_1.tapleafHash)({\n        output: a.redeem.output,\n        version: o.redeemVersion,\n      });\n      if (!(0, bip341_1.findScriptPath)(hashTree, leafHash))\n        throw new TypeError('Redeem script not in tree');\n    }\n    const witness = _witness();\n    // compare the provided redeem data with the one computed from witness\n    if (a.redeem && o.redeem) {\n      if (a.redeem.redeemVersion) {\n        if (a.redeem.redeemVersion !== o.redeem.redeemVersion)\n          throw new TypeError('Redeem.redeemVersion and witness mismatch');\n      }\n      if (a.redeem.output) {\n        if (bscript.decompile(a.redeem.output).length === 0)\n          throw new TypeError('Redeem.output is invalid');\n        // output redeem is constructed from the witness\n        if (o.redeem.output && !a.redeem.output.equals(o.redeem.output))\n          throw new TypeError('Redeem.output and witness mismatch');\n      }\n      if (a.redeem.witness) {\n        if (\n          o.redeem.witness &&\n          !stacksEqual(a.redeem.witness, o.redeem.witness)\n        )\n          throw new TypeError('Redeem.witness and witness mismatch');\n      }\n    }\n    if (witness && witness.length) {\n      if (witness.length === 1) {\n        // key spending\n        if (a.signature && !a.signature.equals(witness[0]))\n          throw new TypeError('Signature mismatch');\n      } else {\n        // script path spending\n        const controlBlock = witness[witness.length - 1];\n        if (controlBlock.length < 33)\n          throw new TypeError(\n            `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,\n          );\n        if ((controlBlock.length - 33) % 32 !== 0)\n          throw new TypeError(\n            `The control-block length of ${controlBlock.length} is incorrect!`,\n          );\n        const m = (controlBlock.length - 33) / 32;\n        if (m > 128)\n          throw new TypeError(\n            `The script path is too long. Got ${m}, expected max 128.`,\n          );\n        const internalPubkey = controlBlock.slice(1, 33);\n        if (a.internalPubkey && !a.internalPubkey.equals(internalPubkey))\n          throw new TypeError('Internal pubkey mismatch');\n        if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(internalPubkey))\n          throw new TypeError('Invalid internalPubkey for p2tr witness');\n        const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;\n        const script = witness[witness.length - 2];\n        const leafHash = (0, bip341_1.tapleafHash)({\n          output: script,\n          version: leafVersion,\n        });\n        const hash = (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);\n        const outputKey = (0, bip341_1.tweakKey)(internalPubkey, hash);\n        if (!outputKey)\n          // todo: needs test data\n          throw new TypeError('Invalid outputKey for p2tr witness');\n        if (pubkey.length && !pubkey.equals(outputKey.x))\n          throw new TypeError('Pubkey mismatch for p2tr witness');\n        if (outputKey.parity !== (controlBlock[0] & 1))\n          throw new Error('Incorrect parity');\n      }\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2tr = p2tr;\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}