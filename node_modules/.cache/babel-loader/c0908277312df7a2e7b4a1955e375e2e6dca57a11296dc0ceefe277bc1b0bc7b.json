{"ast":null,"code":"import { Buffer } from 'buffer';\nexport { Buffer } from 'buffer';\n\n/**\n * Built on top of rlp library, removing the BN dependency for the flow.\n * Package : https://github.com/ethereumjs/rlp\n * RLP License : https://github.com/ethereumjs/rlp/blob/master/LICENSE\n *\n * ethereumjs/rlp is licensed under the\n * Mozilla Public License 2.0\n * Permissions of this weak copyleft license are conditioned on making available source code of licensed files and modifications of those files under the same license (or in certain cases, one of the GNU licenses). Copyright and license notices must be preserved. Contributors provide an express grant of patent rights. However, a larger work using the licensed work may be distributed under different terms and without source code for files added in the larger work.\n */\n/**\n * @param input - will be converted to buffer\n * @returns returns buffer of encoded data\n */\nfunction encode(input) {\n  if (Array.isArray(input)) {\n    const output = [];\n    for (let i = 0; i < input.length; i++) {\n      output.push(encode(input[i]));\n    }\n    const buf = Buffer.concat(output);\n    return Buffer.concat([encodeLength(buf.length, 192), buf]);\n  } else {\n    const inputBuf = toBuffer(input);\n    return inputBuf.length === 1 && inputBuf[0] < 128 ? inputBuf : Buffer.concat([encodeLength(inputBuf.length, 128), inputBuf]);\n  }\n}\n\n/**\n * Parse integers. Check if there is no leading zeros\n * @param v The value to parse\n * @param base The base to parse the integer into\n */\nfunction safeParseInt(v, base) {\n  if (v.slice(0, 2) === \"00\") {\n    throw new Error(\"invalid RLP: extra zeros\");\n  }\n  return parseInt(v, base);\n}\nfunction encodeLength(len, offset) {\n  if (len < 56) {\n    return Buffer.from([len + offset]);\n  } else {\n    const hexLength = intToHex(len);\n    const lLength = hexLength.length / 2;\n    const firstByte = intToHex(offset + 55 + lLength);\n    return Buffer.from(firstByte + hexLength, \"hex\");\n  }\n}\n\n/**\n * Built on top of rlp library, removing the BN dependency for the flow.\n * Package : https://github.com/ethereumjs/rlp\n * RLP License : https://github.com/ethereumjs/rlp/blob/master/LICENSE\n *\n * ethereumjs/rlp is licensed under the\n * Mozilla Public License 2.0\n * Permissions of this weak copyleft license are conditioned on making available source code of licensed files and modifications of those files under the same license (or in certain cases, one of the GNU licenses). Copyright and license notices must be preserved. Contributors provide an express grant of patent rights. However, a larger work using the licensed work may be distributed under different terms and without source code for files added in the larger work.\n */\n\n/**\n * @param input - will be converted to buffer\n * @param stream Is the input a stream (false by default)\n * @returns returns buffer of encoded data\n */\nfunction decode(input, stream) {\n  if (stream === void 0) {\n    stream = false;\n  }\n  if (!input || input.length === 0) {\n    return Buffer.from([]);\n  }\n  const inputBuffer = toBuffer(input);\n  const decoded = _decode(inputBuffer);\n  if (stream) {\n    return decoded;\n  }\n  if (decoded.remainder.length !== 0) {\n    throw new Error(\"invalid remainder\");\n  }\n  return decoded.data;\n}\n\n/**\n * Get the length of the RLP input\n * @param input\n * @returns The length of the input or an empty Buffer if no input\n */\nfunction getLength(input) {\n  const inputBuffer = toBuffer(input);\n  if (inputBuffer.length === 0) {\n    return 0;\n  }\n  const firstByte = inputBuffer[0];\n  if (firstByte <= 0x7f) {\n    return inputBuffer.length;\n  } else if (firstByte <= 0xb7) {\n    return firstByte - 0x7f;\n  } else if (firstByte <= 0xbf) {\n    return firstByte - 0xb6;\n  } else if (firstByte <= 0xf7) {\n    // a list between  0-55 bytes long\n    return firstByte - 0xbf;\n  } else {\n    // a list  over 55 bytes long\n    const llength = firstByte - 0xf6;\n    const length = safeParseInt(inputBuffer.slice(1, llength).toString(\"hex\"), 16);\n    return llength + length;\n  }\n}\n\n/** Decode an input with RLP */\nfunction _decode(input) {\n  let length, llength, data, innerRemainder, d;\n  const decoded = [];\n  const firstByte = input[0];\n  if (firstByte <= 0x7f) {\n    // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.\n    return {\n      data: input.slice(0, 1),\n      remainder: input.slice(1)\n    };\n  } else if (firstByte <= 0xb7) {\n    // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string\n    // The range of the first byte is [0x80, 0xb7]\n    length = firstByte - 0x7f;\n    // set 0x80 null to 0\n    if (firstByte === 0x80) {\n      data = Buffer.from([]);\n    } else {\n      data = input.slice(1, length);\n    }\n    if (length === 2 && data[0] < 0x80) {\n      throw new Error(\"invalid rlp encoding: byte must be less 0x80\");\n    }\n    return {\n      data: data,\n      remainder: input.slice(length)\n    };\n  } else if (firstByte <= 0xbf) {\n    llength = firstByte - 0xb6;\n    length = safeParseInt(input.slice(1, llength).toString(\"hex\"), 16);\n    data = input.slice(llength, length + llength);\n    if (data.length < length) {\n      throw new Error(\"invalid RLP\");\n    }\n    return {\n      data: data,\n      remainder: input.slice(length + llength)\n    };\n  } else if (firstByte <= 0xf7) {\n    // a list between  0-55 bytes long\n    length = firstByte - 0xbf;\n    innerRemainder = input.slice(1, length);\n    while (innerRemainder.length) {\n      d = _decode(innerRemainder);\n      decoded.push(d.data);\n      innerRemainder = d.remainder;\n    }\n    return {\n      data: decoded,\n      remainder: input.slice(length)\n    };\n  } else {\n    // a list  over 55 bytes long\n    llength = firstByte - 0xf6;\n    length = safeParseInt(input.slice(1, llength).toString(\"hex\"), 16);\n    const totalLength = llength + length;\n    if (totalLength > input.length) {\n      throw new Error(\"invalid rlp: total length is larger than the data\");\n    }\n    innerRemainder = input.slice(llength, totalLength);\n    if (innerRemainder.length === 0) {\n      throw new Error(\"invalid rlp, List has a invalid length\");\n    }\n    while (innerRemainder.length) {\n      d = _decode(innerRemainder);\n      decoded.push(d.data);\n      innerRemainder = d.remainder;\n    }\n    return {\n      data: decoded,\n      remainder: input.slice(totalLength)\n    };\n  }\n}\n/** Check if a string is prefixed by 0x */\nfunction isHexPrefixed(str) {\n  return str.slice(0, 2) === \"0x\";\n}\n/** Removes 0x from a given String */\nfunction stripHexPrefix(str) {\n  if (typeof str !== \"string\") {\n    return str;\n  }\n  return isHexPrefixed(str) ? str.slice(2) : str;\n}\n/** Transform an integer into its hexadecimal value */\nfunction intToHex(integer) {\n  if (integer < 0) {\n    throw new Error(\"Invalid integer as argument, must be unsigned!\");\n  }\n  const hex = integer.toString(16);\n  return hex.length % 2 ? \"0\" + hex : hex;\n}\n/** Pad a string to be even */\nfunction padToEven(a) {\n  return a.length % 2 ? \"0\" + a : a;\n}\n/** Transform an integer into a Buffer */\nfunction intToBuffer(integer) {\n  const hex = intToHex(integer);\n  return Buffer.from(hex, \"hex\");\n}\n\n/** Transform anything into a Buffer */\nfunction toBuffer(v) {\n  if (!Buffer.isBuffer(v)) {\n    if (typeof v === \"string\") {\n      if (isHexPrefixed(v)) {\n        return Buffer.from(padToEven(stripHexPrefix(v)), \"hex\");\n      } else {\n        return Buffer.from(v);\n      }\n    } else if (typeof v === \"number\") {\n      if (!v) {\n        return Buffer.from([]);\n      } else {\n        return intToBuffer(v);\n      }\n    } else if (v === null || v === undefined) {\n      return Buffer.from([]);\n    } else if (v instanceof Uint8Array) {\n      return Buffer.from(v);\n    } else {\n      throw new Error(\"invalid type\");\n    }\n  }\n  return v;\n}\nexport { decode, encode, getLength, toBuffer };","map":{"version":3,"names":["encode","input","Array","isArray","output","i","length","push","buf","Buffer","concat","encodeLength","inputBuf","toBuffer","safeParseInt","v","base","slice","Error","parseInt","len","offset","from","hexLength","intToHex","lLength","firstByte","decode","stream","inputBuffer","decoded","_decode","remainder","data","getLength","llength","toString","innerRemainder","d","totalLength","isHexPrefixed","str","stripHexPrefix","integer","hex","padToEven","a","intToBuffer","isBuffer","undefined","Uint8Array"],"sources":["../src/index.ts"],"sourcesContent":["import {Buffer} from \"buffer\"\n\nexport {Buffer}\n\ntype EncodeInput =\n  | Buffer\n  | string\n  | number\n  | Uint8Array\n  | null\n  | undefined\n  | EncodeInput[]\n\n/**\n * Built on top of rlp library, removing the BN dependency for the flow.\n * Package : https://github.com/ethereumjs/rlp\n * RLP License : https://github.com/ethereumjs/rlp/blob/master/LICENSE\n *\n * ethereumjs/rlp is licensed under the\n * Mozilla Public License 2.0\n * Permissions of this weak copyleft license are conditioned on making available source code of licensed files and modifications of those files under the same license (or in certain cases, one of the GNU licenses). Copyright and license notices must be preserved. Contributors provide an express grant of patent rights. However, a larger work using the licensed work may be distributed under different terms and without source code for files added in the larger work.\n */\n\n/**\n * @param input - will be converted to buffer\n * @returns returns buffer of encoded data\n */\nexport function encode(input: EncodeInput): Buffer {\n  if (Array.isArray(input)) {\n    const output = []\n    for (let i = 0; i < input.length; i++) {\n      output.push(encode(input[i]))\n    }\n    const buf = Buffer.concat(output)\n    return Buffer.concat([encodeLength(buf.length, 192), buf])\n  } else {\n    const inputBuf = toBuffer(input)\n    return inputBuf.length === 1 && inputBuf[0] < 128\n      ? inputBuf\n      : Buffer.concat([encodeLength(inputBuf.length, 128), inputBuf])\n  }\n}\n\n/**\n * Parse integers. Check if there is no leading zeros\n * @param v The value to parse\n * @param base The base to parse the integer into\n */\nfunction safeParseInt(v: string, base: number): number {\n  if (v.slice(0, 2) === \"00\") {\n    throw new Error(\"invalid RLP: extra zeros\")\n  }\n  return parseInt(v, base)\n}\nfunction encodeLength(len: number, offset: number): Buffer {\n  if (len < 56) {\n    return Buffer.from([len + offset])\n  } else {\n    const hexLength = intToHex(len)\n    const lLength = hexLength.length / 2\n    const firstByte = intToHex(offset + 55 + lLength)\n    return Buffer.from(firstByte + hexLength, \"hex\")\n  }\n}\n\n/**\n * Built on top of rlp library, removing the BN dependency for the flow.\n * Package : https://github.com/ethereumjs/rlp\n * RLP License : https://github.com/ethereumjs/rlp/blob/master/LICENSE\n *\n * ethereumjs/rlp is licensed under the\n * Mozilla Public License 2.0\n * Permissions of this weak copyleft license are conditioned on making available source code of licensed files and modifications of those files under the same license (or in certain cases, one of the GNU licenses). Copyright and license notices must be preserved. Contributors provide an express grant of patent rights. However, a larger work using the licensed work may be distributed under different terms and without source code for files added in the larger work.\n */\n\n/**\n * @param input - will be converted to buffer\n * @param stream Is the input a stream (false by default)\n * @returns returns buffer of encoded data\n */\nexport function decode(input: Buffer | Uint8Array, stream?: boolean): Buffer {\n  if (stream === void 0) {\n    stream = false\n  }\n  if (!input || input.length === 0) {\n    return Buffer.from([])\n  }\n  const inputBuffer = toBuffer(input)\n  const decoded = _decode(inputBuffer)\n  if (stream) {\n    return decoded\n  }\n  if (decoded.remainder.length !== 0) {\n    throw new Error(\"invalid remainder\")\n  }\n  return decoded.data\n}\n\n/**\n * Get the length of the RLP input\n * @param input\n * @returns The length of the input or an empty Buffer if no input\n */\nexport function getLength(\n  input: Buffer | Uint8Array | null | undefined | string | number\n): number {\n  const inputBuffer = toBuffer(input)\n  if (inputBuffer.length === 0) {\n    return 0\n  }\n\n  const firstByte = inputBuffer[0]\n  if (firstByte <= 0x7f) {\n    return inputBuffer.length\n  } else if (firstByte <= 0xb7) {\n    return firstByte - 0x7f\n  } else if (firstByte <= 0xbf) {\n    return firstByte - 0xb6\n  } else if (firstByte <= 0xf7) {\n    // a list between  0-55 bytes long\n    return firstByte - 0xbf\n  } else {\n    // a list  over 55 bytes long\n    const llength = firstByte - 0xf6\n    const length = safeParseInt(\n      inputBuffer.slice(1, llength).toString(\"hex\"),\n      16\n    )\n    return llength + length\n  }\n}\n\n/** Decode an input with RLP */\nfunction _decode(input: Buffer | Uint8Array): any {\n  let length, llength, data, innerRemainder, d\n  const decoded = []\n  const firstByte = input[0]\n  if (firstByte <= 0x7f) {\n    // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.\n    return {\n      data: input.slice(0, 1),\n      remainder: input.slice(1),\n    }\n  } else if (firstByte <= 0xb7) {\n    // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string\n    // The range of the first byte is [0x80, 0xb7]\n    length = firstByte - 0x7f\n    // set 0x80 null to 0\n    if (firstByte === 0x80) {\n      data = Buffer.from([])\n    } else {\n      data = input.slice(1, length)\n    }\n    if (length === 2 && data[0] < 0x80) {\n      throw new Error(\"invalid rlp encoding: byte must be less 0x80\")\n    }\n    return {\n      data: data,\n      remainder: input.slice(length),\n    }\n  } else if (firstByte <= 0xbf) {\n    llength = firstByte - 0xb6\n    length = safeParseInt(input.slice(1, llength).toString(\"hex\"), 16)\n    data = input.slice(llength, length + llength)\n    if (data.length < length) {\n      throw new Error(\"invalid RLP\")\n    }\n    return {\n      data: data,\n      remainder: input.slice(length + llength),\n    }\n  } else if (firstByte <= 0xf7) {\n    // a list between  0-55 bytes long\n    length = firstByte - 0xbf\n    innerRemainder = input.slice(1, length)\n    while (innerRemainder.length) {\n      d = _decode(innerRemainder)\n      decoded.push(d.data)\n      innerRemainder = d.remainder\n    }\n    return {\n      data: decoded,\n      remainder: input.slice(length),\n    }\n  } else {\n    // a list  over 55 bytes long\n    llength = firstByte - 0xf6\n    length = safeParseInt(input.slice(1, llength).toString(\"hex\"), 16)\n    const totalLength = llength + length\n    if (totalLength > input.length) {\n      throw new Error(\"invalid rlp: total length is larger than the data\")\n    }\n    innerRemainder = input.slice(llength, totalLength)\n    if (innerRemainder.length === 0) {\n      throw new Error(\"invalid rlp, List has a invalid length\")\n    }\n    while (innerRemainder.length) {\n      d = _decode(innerRemainder)\n      decoded.push(d.data)\n      innerRemainder = d.remainder\n    }\n    return {\n      data: decoded,\n      remainder: input.slice(totalLength),\n    }\n  }\n}\n/** Check if a string is prefixed by 0x */\nfunction isHexPrefixed(str: string) {\n  return str.slice(0, 2) === \"0x\"\n}\n/** Removes 0x from a given String */\nfunction stripHexPrefix(str: string) {\n  if (typeof str !== \"string\") {\n    return str\n  }\n  return isHexPrefixed(str) ? str.slice(2) : str\n}\n/** Transform an integer into its hexadecimal value */\nfunction intToHex(integer: number) {\n  if (integer < 0) {\n    throw new Error(\"Invalid integer as argument, must be unsigned!\")\n  }\n  const hex = integer.toString(16)\n  return hex.length % 2 ? \"0\" + hex : hex\n}\n/** Pad a string to be even */\nfunction padToEven(a: string) {\n  return a.length % 2 ? \"0\" + a : a\n}\n/** Transform an integer into a Buffer */\nfunction intToBuffer(integer: number) {\n  const hex = intToHex(integer)\n  return Buffer.from(hex, \"hex\")\n}\n\n/** Transform anything into a Buffer */\nexport function toBuffer(\n  v: Buffer | string | number | Uint8Array | null | undefined\n) {\n  if (!Buffer.isBuffer(v)) {\n    if (typeof v === \"string\") {\n      if (isHexPrefixed(v)) {\n        return Buffer.from(padToEven(stripHexPrefix(v)), \"hex\")\n      } else {\n        return Buffer.from(v)\n      }\n    } else if (typeof v === \"number\") {\n      if (!v) {\n        return Buffer.from([])\n      } else {\n        return intToBuffer(v)\n      }\n    } else if (v === null || v === undefined) {\n      return Buffer.from([])\n    } else if (v instanceof Uint8Array) {\n      return Buffer.from(v)\n    } else {\n      throw new Error(\"invalid type\")\n    }\n  }\n  return v\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}