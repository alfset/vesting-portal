{"ast":null,"code":"import { isMobile } from '@terra-dev/browser-check';\nimport { TerraWalletconnectQrcodeModal } from '@terra-dev/walletconnect-qrcode-modal';\nimport Connector from '@walletconnect/core';\nimport * as cryptoLib from '@walletconnect/iso-crypto';\nimport { uuid } from '@walletconnect/utils';\nimport { BehaviorSubject } from 'rxjs';\nimport { WalletConnectCreateTxFailed, WalletConnectTimeout, WalletConnectTxFailed, WalletConnectTxUnspecifiedError, WalletConnectUserDenied } from './errors';\nimport SocketTransport from './impl/socket-transport';\nimport { WalletConnectSessionStatus } from './types';\nconst WALLETCONNECT_STORAGE_KEY = 'walletconnect';\nexport function connectIfSessionExists() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const storedSession = localStorage.getItem(WALLETCONNECT_STORAGE_KEY);\n  if (typeof storedSession === 'string') {\n    return connect(options, true);\n  }\n  return null;\n}\nexport function connect() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let useCachedSession = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var _a, _b;\n  let connector = null;\n  let sessionSubject = new BehaviorSubject({\n    status: WalletConnectSessionStatus.DISCONNECTED\n  });\n  const qrcodeModal = (_b = (_a = options.connectorOpts) === null || _a === void 0 ? void 0 : _a.qrcodeModal) !== null && _b !== void 0 ? _b : new TerraWalletconnectQrcodeModal();\n  const connectorOpts = {\n    bridge: 'https://walletconnect.terra.dev/',\n    qrcodeModal,\n    ...options.connectorOpts\n  };\n  const pushServerOpts = options.pushServerOpts;\n  // ---------------------------------------------\n  // event listeners\n  // ---------------------------------------------\n  function initEvents() {\n    if (!connector) {\n      throw new Error(\"WalletConnect is not defined!\");\n    }\n    connector.on('session_update', async (error, payload) => {\n      if (error) throw error;\n      sessionSubject.next({\n        status: WalletConnectSessionStatus.CONNECTED,\n        peerMeta: payload.params[0],\n        terraAddress: payload.params[0].accounts[0],\n        chainId: payload.params[0].chainId\n      });\n      console.log('WALLETCONNECT SESSION UPDATED:', payload.params[0]);\n    });\n    connector.on('connect', (error, payload) => {\n      if (error) throw error;\n      sessionSubject.next({\n        status: WalletConnectSessionStatus.CONNECTED,\n        peerMeta: payload.params[0],\n        terraAddress: payload.params[0].accounts[0],\n        chainId: payload.params[0].chainId\n      });\n    });\n    connector.on('disconnect', (error, payload) => {\n      if (error) throw error;\n      sessionSubject.next({\n        status: WalletConnectSessionStatus.DISCONNECTED\n      });\n    });\n  }\n  // ---------------------------------------------\n  // initialize\n  // ---------------------------------------------\n  const cachedSession = localStorage.getItem('walletconnect');\n  if (typeof cachedSession === 'string' && useCachedSession) {\n    const cachedSessionObject = JSON.parse(cachedSession);\n    const clientId = cachedSessionObject.clientId;\n    const draftConnector = new Connector({\n      connectorOpts: {\n        ...connectorOpts,\n        session: JSON.parse(cachedSession)\n      },\n      pushServerOpts,\n      cryptoLib,\n      transport: new SocketTransport({\n        protocol: 'wc',\n        version: 1,\n        url: connectorOpts.bridge,\n        subscriptions: [clientId]\n      })\n    });\n    draftConnector.clientId = clientId;\n    connector = draftConnector;\n    initEvents();\n    sessionSubject.next({\n      status: WalletConnectSessionStatus.CONNECTED,\n      peerMeta: draftConnector.peerMeta,\n      terraAddress: draftConnector.accounts[0],\n      chainId: draftConnector.chainId\n    });\n  } else {\n    const clientId = uuid();\n    const draftConnector = new Connector({\n      connectorOpts,\n      pushServerOpts,\n      cryptoLib,\n      transport: new SocketTransport({\n        protocol: 'wc',\n        version: 1,\n        url: connectorOpts.bridge,\n        subscriptions: [clientId]\n      })\n    });\n    draftConnector.clientId = clientId;\n    connector = draftConnector;\n    if (!draftConnector.connected) {\n      draftConnector.createSession().catch(console.error);\n      if (qrcodeModal instanceof TerraWalletconnectQrcodeModal) {\n        qrcodeModal.setCloseCallback(() => {\n          sessionSubject.next({\n            status: WalletConnectSessionStatus.DISCONNECTED\n          });\n        });\n      }\n      initEvents();\n      sessionSubject.next({\n        status: WalletConnectSessionStatus.REQUESTED\n      });\n    }\n  }\n  // ---------------------------------------------\n  // methods\n  // ---------------------------------------------\n  function disconnect() {\n    if (connector && connector.connected) {\n      try {\n        connector.killSession();\n      } catch (_a) {}\n    }\n    sessionSubject.next({\n      status: WalletConnectSessionStatus.DISCONNECTED\n    });\n  }\n  function session() {\n    return sessionSubject.asObservable();\n  }\n  function getLatestSession() {\n    return sessionSubject.getValue();\n  }\n  /**\n   * post transaction\n   *\n   * @param tx transaction data\n   * @throws { WalletConnectUserDenied }\n   * @throws { WalletConnectCreateTxFailed }\n   * @throws { WalletConnectTxFailed }\n   * @throws { WalletConnectTimeout }\n   * @throws { WalletConnectTxUnspecifiedError }\n   */\n  function post(tx) {\n    var _a, _b, _c;\n    if (!connector || !connector.connected) {\n      throw new Error(\"WalletConnect is not connected!\");\n    }\n    const id = Date.now();\n    const serializedTxOptions = {\n      msgs: tx.msgs.map(msg => msg.toJSON()),\n      fee: (_a = tx.fee) === null || _a === void 0 ? void 0 : _a.toJSON(),\n      memo: tx.memo,\n      gasPrices: (_b = tx.gasPrices) === null || _b === void 0 ? void 0 : _b.toString(),\n      gasAdjustment: (_c = tx.gasAdjustment) === null || _c === void 0 ? void 0 : _c.toString(),\n      account_number: tx.account_number,\n      sequence: tx.sequence,\n      feeDenoms: tx.feeDenoms\n    };\n    if (isMobile()) {\n      const payload = btoa(JSON.stringify({\n        id,\n        handshakeTopic: connector.handshakeTopic,\n        params: serializedTxOptions\n      }));\n      // FIXME changed walletconnect confirm schema\n      window.location.href = \"terrastation://walletconnect_confirm/?payload=\".concat(payload);\n      //window.location.href = `terrastation://wallet_connect_confirm?id=${id}&handshakeTopic=${\n      //  connector.handshakeTopic\n      //}&params=${JSON.stringify([serializedTxOptions])}`;\n    }\n\n    return connector.sendCustomRequest({\n      id,\n      method: 'post',\n      params: [serializedTxOptions]\n    }).catch(error => {\n      let throwError = error;\n      try {\n        const {\n          code,\n          txhash,\n          message,\n          raw_message\n        } = JSON.parse(error.message);\n        switch (code) {\n          case 1:\n            throwError = new WalletConnectUserDenied();\n            break;\n          case 2:\n            throwError = new WalletConnectCreateTxFailed(message);\n            break;\n          case 3:\n            throwError = new WalletConnectTxFailed(txhash, message, raw_message);\n            break;\n          case 4:\n            throwError = new WalletConnectTimeout(message);\n            break;\n          case 99:\n            throwError = new WalletConnectTxUnspecifiedError(message);\n            break;\n        }\n      } catch (_a) {\n        throwError = new WalletConnectTxUnspecifiedError(error.message);\n      }\n      throw throwError;\n    });\n  }\n  // ---------------------------------------------\n  // return\n  // ---------------------------------------------\n  return {\n    session,\n    getLatestSession,\n    post,\n    disconnect\n  };\n}","map":{"version":3,"names":["isMobile","TerraWalletconnectQrcodeModal","Connector","cryptoLib","uuid","BehaviorSubject","WalletConnectCreateTxFailed","WalletConnectTimeout","WalletConnectTxFailed","WalletConnectTxUnspecifiedError","WalletConnectUserDenied","SocketTransport","WalletConnectSessionStatus","WALLETCONNECT_STORAGE_KEY","connectIfSessionExists","options","arguments","length","undefined","storedSession","localStorage","getItem","connect","useCachedSession","connector","sessionSubject","status","DISCONNECTED","qrcodeModal","_b","_a","connectorOpts","bridge","pushServerOpts","initEvents","Error","on","error","payload","next","CONNECTED","peerMeta","params","terraAddress","accounts","chainId","console","log","cachedSession","cachedSessionObject","JSON","parse","clientId","draftConnector","session","transport","protocol","version","url","subscriptions","connected","createSession","catch","setCloseCallback","REQUESTED","disconnect","killSession","asObservable","getLatestSession","getValue","post","tx","id","Date","now","serializedTxOptions","msgs","map","msg","toJSON","fee","memo","gasPrices","toString","gasAdjustment","_c","account_number","sequence","feeDenoms","btoa","stringify","handshakeTopic","window","location","href","concat","sendCustomRequest","method","throwError","code","txhash","message","raw_message"],"sources":["../../../src/@terra-dev/walletconnect/connect.ts"],"sourcesContent":["import { isMobile } from '@terra-dev/browser-check';\nimport { TerraWalletconnectQrcodeModal } from '@terra-dev/walletconnect-qrcode-modal';\nimport { CreateTxOptions } from '@terra-money/terra.js';\nimport Connector from '@walletconnect/core';\nimport * as cryptoLib from '@walletconnect/iso-crypto';\nimport {\n  IPushServerOptions,\n  IWalletConnectOptions,\n} from '@walletconnect/types';\nimport { uuid } from '@walletconnect/utils';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport {\n  WalletConnectCreateTxFailed,\n  WalletConnectTimeout,\n  WalletConnectTxFailed,\n  WalletConnectTxUnspecifiedError,\n  WalletConnectUserDenied,\n} from './errors';\nimport SocketTransport from './impl/socket-transport';\nimport {\n  WalletConnectSession,\n  WalletConnectSessionStatus,\n  WalletConnectTxResult,\n} from './types';\n\nexport interface WalletConnectControllerOptions {\n  /**\n   * Configuration parameter that `new WalletConnect(connectorOpts)`\n   *\n   * @default\n   * ```js\n   * {\n   *   bridge: 'https://walletconnect.terra.dev/',\n   *   qrcodeModal: new TerraWalletconnectQrcodeModal(),\n   * }\n   * ```\n   */\n  connectorOpts?: IWalletConnectOptions;\n\n  /**\n   * Configuration parameter that `new WalletConnect(_, pushServerOpts)`\n   *\n   * @default undefined\n   */\n  pushServerOpts?: IPushServerOptions;\n}\n\nexport interface WalletConnectController {\n  session: () => Observable<WalletConnectSession>;\n  getLatestSession: () => WalletConnectSession;\n  post: (tx: CreateTxOptions) => Promise<WalletConnectTxResult>;\n  disconnect: () => void;\n}\n\nconst WALLETCONNECT_STORAGE_KEY = 'walletconnect';\n\nexport function connectIfSessionExists(\n  options: WalletConnectControllerOptions = {},\n): WalletConnectController | null {\n  const storedSession = localStorage.getItem(WALLETCONNECT_STORAGE_KEY);\n\n  if (typeof storedSession === 'string') {\n    return connect(options, true);\n  }\n\n  return null;\n}\n\nexport function connect(\n  options: WalletConnectControllerOptions = {},\n  useCachedSession: boolean = false,\n): WalletConnectController {\n  let connector: Connector | null = null;\n\n  let sessionSubject: BehaviorSubject<WalletConnectSession> =\n    new BehaviorSubject<WalletConnectSession>({\n      status: WalletConnectSessionStatus.DISCONNECTED,\n    });\n\n  const qrcodeModal =\n    options.connectorOpts?.qrcodeModal ?? new TerraWalletconnectQrcodeModal();\n\n  const connectorOpts: IWalletConnectOptions = {\n    bridge: 'https://walletconnect.terra.dev/',\n    qrcodeModal,\n    ...options.connectorOpts,\n  };\n\n  const pushServerOpts: IPushServerOptions | undefined = options.pushServerOpts;\n\n  // ---------------------------------------------\n  // event listeners\n  // ---------------------------------------------\n  function initEvents() {\n    if (!connector) {\n      throw new Error(`WalletConnect is not defined!`);\n    }\n\n    connector.on('session_update', async (error, payload) => {\n      if (error) throw error;\n\n      sessionSubject.next({\n        status: WalletConnectSessionStatus.CONNECTED,\n        peerMeta: payload.params[0],\n        terraAddress: payload.params[0].accounts[0],\n        chainId: payload.params[0].chainId,\n      });\n\n      console.log('WALLETCONNECT SESSION UPDATED:', payload.params[0]);\n    });\n\n    connector.on('connect', (error, payload) => {\n      if (error) throw error;\n\n      sessionSubject.next({\n        status: WalletConnectSessionStatus.CONNECTED,\n        peerMeta: payload.params[0],\n        terraAddress: payload.params[0].accounts[0],\n        chainId: payload.params[0].chainId,\n      });\n    });\n\n    connector.on('disconnect', (error, payload) => {\n      if (error) throw error;\n\n      sessionSubject.next({\n        status: WalletConnectSessionStatus.DISCONNECTED,\n      });\n    });\n  }\n\n  // ---------------------------------------------\n  // initialize\n  // ---------------------------------------------\n  const cachedSession = localStorage.getItem('walletconnect');\n\n  if (typeof cachedSession === 'string' && useCachedSession) {\n    const cachedSessionObject = JSON.parse(cachedSession);\n    const clientId = cachedSessionObject.clientId;\n    const draftConnector = new Connector({\n      connectorOpts: {\n        ...connectorOpts,\n        session: JSON.parse(cachedSession),\n      },\n      pushServerOpts,\n      cryptoLib,\n      transport: new SocketTransport({\n        protocol: 'wc',\n        version: 1,\n        url: connectorOpts.bridge!,\n        subscriptions: [clientId],\n      }),\n    });\n    draftConnector.clientId = clientId;\n\n    connector = draftConnector;\n\n    initEvents();\n\n    sessionSubject.next({\n      status: WalletConnectSessionStatus.CONNECTED,\n      peerMeta: draftConnector.peerMeta!,\n      terraAddress: draftConnector.accounts[0],\n      chainId: draftConnector.chainId,\n    });\n  } else {\n    const clientId = uuid();\n    const draftConnector = new Connector({\n      connectorOpts,\n      pushServerOpts,\n      cryptoLib,\n      transport: new SocketTransport({\n        protocol: 'wc',\n        version: 1,\n        url: connectorOpts.bridge!,\n        subscriptions: [clientId],\n      }),\n    });\n    draftConnector.clientId = clientId;\n\n    connector = draftConnector;\n\n    if (!draftConnector.connected) {\n      draftConnector.createSession().catch(console.error);\n\n      if (qrcodeModal instanceof TerraWalletconnectQrcodeModal) {\n        qrcodeModal.setCloseCallback(() => {\n          sessionSubject.next({\n            status: WalletConnectSessionStatus.DISCONNECTED,\n          });\n        });\n      }\n\n      initEvents();\n\n      sessionSubject.next({\n        status: WalletConnectSessionStatus.REQUESTED,\n      });\n    }\n  }\n\n  // ---------------------------------------------\n  // methods\n  // ---------------------------------------------\n  function disconnect() {\n    if (connector && connector.connected) {\n      try {\n        connector.killSession();\n      } catch {}\n    }\n\n    sessionSubject.next({\n      status: WalletConnectSessionStatus.DISCONNECTED,\n    });\n  }\n\n  function session(): Observable<WalletConnectSession> {\n    return sessionSubject.asObservable();\n  }\n\n  function getLatestSession(): WalletConnectSession {\n    return sessionSubject.getValue();\n  }\n\n  /**\n   * post transaction\n   *\n   * @param tx transaction data\n   * @throws { WalletConnectUserDenied }\n   * @throws { WalletConnectCreateTxFailed }\n   * @throws { WalletConnectTxFailed }\n   * @throws { WalletConnectTimeout }\n   * @throws { WalletConnectTxUnspecifiedError }\n   */\n  function post(tx: CreateTxOptions): Promise<WalletConnectTxResult> {\n    if (!connector || !connector.connected) {\n      throw new Error(`WalletConnect is not connected!`);\n    }\n\n    const id = Date.now();\n\n    const serializedTxOptions = {\n      msgs: tx.msgs.map((msg) => msg.toJSON()),\n      fee: tx.fee?.toJSON(),\n      memo: tx.memo,\n      gasPrices: tx.gasPrices?.toString(),\n      gasAdjustment: tx.gasAdjustment?.toString(),\n      account_number: tx.account_number,\n      sequence: tx.sequence,\n      feeDenoms: tx.feeDenoms,\n    };\n\n    if (isMobile()) {\n      const payload = btoa(\n        JSON.stringify({\n          id,\n          handshakeTopic: connector.handshakeTopic,\n          params: serializedTxOptions,\n        }),\n      );\n\n      // FIXME changed walletconnect confirm schema\n      window.location.href = `terrastation://walletconnect_confirm/?payload=${payload}`;\n      //window.location.href = `terrastation://wallet_connect_confirm?id=${id}&handshakeTopic=${\n      //  connector.handshakeTopic\n      //}&params=${JSON.stringify([serializedTxOptions])}`;\n    }\n\n    return connector\n      .sendCustomRequest({\n        id,\n        method: 'post',\n        params: [serializedTxOptions],\n      })\n      .catch((error) => {\n        let throwError = error;\n\n        try {\n          const { code, txhash, message, raw_message } = JSON.parse(\n            error.message,\n          );\n          switch (code) {\n            case 1:\n              throwError = new WalletConnectUserDenied();\n              break;\n            case 2:\n              throwError = new WalletConnectCreateTxFailed(message);\n              break;\n            case 3:\n              throwError = new WalletConnectTxFailed(\n                txhash,\n                message,\n                raw_message,\n              );\n              break;\n            case 4:\n              throwError = new WalletConnectTimeout(message);\n              break;\n            case 99:\n              throwError = new WalletConnectTxUnspecifiedError(message);\n              break;\n          }\n        } catch {\n          throwError = new WalletConnectTxUnspecifiedError(error.message);\n        }\n\n        throw throwError;\n      });\n  }\n\n  // ---------------------------------------------\n  // return\n  // ---------------------------------------------\n  return {\n    session,\n    getLatestSession,\n    post,\n    disconnect,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}