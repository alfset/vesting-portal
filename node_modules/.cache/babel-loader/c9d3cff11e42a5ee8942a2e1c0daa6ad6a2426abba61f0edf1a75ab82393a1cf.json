{"ast":null,"code":"import { isDesktopChrome } from '@terra-dev/browser-check';\nimport { AccAddress } from '@terra-money/terra.js';\nimport { BehaviorSubject } from 'rxjs';\nimport { defaultSelectModal } from './defaultSelectModal';\nimport { extensionFixer } from './extensionFixer';\nimport { getTerraChromeExtensions } from './multiChannel';\nimport { clearSession, getStoredSession, storeSession } from './storage';\nimport { ChromeExtensionStatus } from './types';\nexport class ChromeExtensionController {\n  constructor(options) {\n    this.options = options;\n    this._extension = null;\n    this.status = () => {\n      return this._status.asObservable();\n    };\n    this.networkInfo = () => {\n      return this._networkInfo.asObservable();\n    };\n    this.terraAddress = () => {\n      return this._terraAddress.asObservable();\n    };\n    this.checkStatus = async () => {\n      // do not check if browser isn't a chrome\n      if (!this.isDesktopChrome) {\n        return;\n      }\n      if (this.extensionInfos.length === 0) {\n        this._status.next(ChromeExtensionStatus.UNAVAILABLE);\n        return;\n      }\n      if (!this._extension) {\n        this._status.next(ChromeExtensionStatus.WALLET_NOT_CONNECTED);\n        return;\n      }\n      // get networkInfo from extension\n      const infoPayload = await this._extension.info();\n      if (infoPayload && this._networkInfo.getValue().chainID !== infoPayload.chainID) {\n        this._networkInfo.next(infoPayload);\n      }\n      if (this.options.enableWalletConnection) {\n        //const storageStoredWalletAddress: string | null = getStoredAddress();\n        const session = getStoredSession();\n        // if the storage has wallet address\n        if (session && AccAddress.validate(session.walletAddress)) {\n          this._status.next(ChromeExtensionStatus.WALLET_CONNECTED);\n          const connectResult = await this._extension.connect();\n          // if address of extension is not same with the address of localStorage\n          if (connectResult.address && AccAddress.validate(connectResult.address)) {\n            storeSession({\n              walletAddress: connectResult.address,\n              identifier: session.identifier\n            });\n          }\n          if (!!connectResult.address) {\n            if (this._terraAddress.getValue() !== connectResult.address) {\n              this._terraAddress.next(connectResult.address);\n            }\n          } else {\n            clearSession();\n            this._status.next(ChromeExtensionStatus.WALLET_NOT_CONNECTED);\n          }\n        } else {\n          if (session) {\n            clearSession();\n          }\n          this._status.next(ChromeExtensionStatus.WALLET_NOT_CONNECTED);\n          this._terraAddress.next(null);\n        }\n      } else {\n        this._status.next(ChromeExtensionStatus.WALLET_NOT_CONNECTED);\n        this._terraAddress.next(null);\n      }\n    };\n    this.connect = async identifier => {\n      var _a;\n      const extensionInfos = getTerraChromeExtensions();\n      if (extensionInfos.length === 0) {\n        return false;\n      }\n      let extensionInfo;\n      if (identifier) {\n        extensionInfo = extensionInfos.find(item => item.identifier === identifier);\n      } else if (extensionInfos.length === 1) {\n        extensionInfo = extensionInfos[0];\n      } else {\n        const select = (_a = this.options.selectExtension) !== null && _a !== void 0 ? _a : defaultSelectModal;\n        const selection = await select(extensionInfos);\n        if (selection) {\n          extensionInfo = selection;\n        }\n      }\n      if (extensionInfo) {\n        this._extension = extensionFixer(extensionInfo.identifier);\n        const result = await this._extension.connect();\n        if (result === null || result === void 0 ? void 0 : result.address) {\n          const walletAddress = result.address;\n          storeSession({\n            identifier: extensionInfo.identifier,\n            walletAddress\n          });\n          await this.checkStatus();\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    };\n    this.disconnect = () => {\n      clearSession();\n      this._status.next(ChromeExtensionStatus.WALLET_NOT_CONNECTED);\n      this._terraAddress.next(null);\n      this._extension = null;\n    };\n    this.recheckStatus = () => {\n      if (this._extension && !this._extension.inTransactionProgress()) {\n        this.checkStatus();\n      }\n    };\n    this.post = data => {\n      if (!this._extension) {\n        throw new Error(\"There is no connected wallet\");\n      }\n      return this._extension.post(data);\n    };\n    this.sign = data => {\n      if (!this._extension) {\n        throw new Error(\"There is no connected wallet\");\n      }\n      return this._extension.sign(data);\n    };\n    this.isDesktopChrome = typeof window !== 'undefined' && isDesktopChrome(options.dangerously__chromeExtensionCompatibleBrowserCheck(navigator.userAgent));\n    this._status = new BehaviorSubject(this.isDesktopChrome ? ChromeExtensionStatus.INITIALIZING : ChromeExtensionStatus.UNAVAILABLE);\n    this._networkInfo = new BehaviorSubject(options.defaultNetwork);\n    this.extensionInfos = getTerraChromeExtensions();\n    if (!this.isDesktopChrome) {\n      this._terraAddress = new BehaviorSubject(null);\n      return;\n    }\n    // ---------------------------------------------\n    // initialize session\n    // ---------------------------------------------\n    if (this.extensionInfos.length === 0) {\n      this._terraAddress = new BehaviorSubject(null);\n      this._status.next(ChromeExtensionStatus.UNAVAILABLE);\n      return;\n    }\n    const session = getStoredSession();\n    if (!session || !this.extensionInfos.some(item => item.identifier === session.identifier)) {\n      this._terraAddress = new BehaviorSubject(null);\n      this._status.next(ChromeExtensionStatus.WALLET_NOT_CONNECTED);\n      return;\n    }\n    this._terraAddress = new BehaviorSubject(session.walletAddress);\n    this._extension = extensionFixer(session.identifier);\n    this.checkStatus();\n  }\n}","map":{"version":3,"names":["isDesktopChrome","AccAddress","BehaviorSubject","defaultSelectModal","extensionFixer","getTerraChromeExtensions","clearSession","getStoredSession","storeSession","ChromeExtensionStatus","ChromeExtensionController","constructor","options","_extension","status","_status","asObservable","networkInfo","_networkInfo","terraAddress","_terraAddress","checkStatus","extensionInfos","length","next","UNAVAILABLE","WALLET_NOT_CONNECTED","infoPayload","info","getValue","chainID","enableWalletConnection","session","validate","walletAddress","WALLET_CONNECTED","connectResult","connect","address","identifier","extensionInfo","find","item","select","_a","selectExtension","selection","result","disconnect","recheckStatus","inTransactionProgress","post","data","Error","sign","window","dangerously__chromeExtensionCompatibleBrowserCheck","navigator","userAgent","INITIALIZING","defaultNetwork","some"],"sources":["../../../src/@terra-dev/chrome-extension/ChromeExtensionController.ts"],"sourcesContent":["import { isDesktopChrome } from '@terra-dev/browser-check';\nimport { NetworkInfo } from '@terra-dev/wallet-types';\nimport { AccAddress } from '@terra-money/terra.js';\nimport { BehaviorSubject } from 'rxjs';\nimport { defaultSelectModal } from './defaultSelectModal';\nimport { extensionFixer, FixedExtension } from './extensionFixer';\nimport { ChromeExtensionInfo, getTerraChromeExtensions } from './multiChannel';\nimport { clearSession, getStoredSession, storeSession } from './storage';\nimport { ChromeExtensionStatus } from './types';\n\nexport interface ChromeExtensionControllerOptions {\n  defaultNetwork: NetworkInfo;\n  enableWalletConnection: boolean;\n  dangerously__chromeExtensionCompatibleBrowserCheck: (\n    userAgent: string,\n  ) => boolean;\n  selectExtension?: (\n    extensionInfos: ChromeExtensionInfo[],\n  ) => Promise<ChromeExtensionInfo | null>;\n}\n\nexport class ChromeExtensionController {\n  readonly _status: BehaviorSubject<ChromeExtensionStatus>;\n  readonly _networkInfo: BehaviorSubject<NetworkInfo>;\n  readonly _terraAddress: BehaviorSubject<string | null>;\n  private _extension: FixedExtension | null = null;\n\n  private readonly extensionInfos: ChromeExtensionInfo[];\n  private readonly isDesktopChrome: boolean;\n\n  constructor(readonly options: ChromeExtensionControllerOptions) {\n    this.isDesktopChrome =\n      typeof window !== 'undefined' &&\n      isDesktopChrome(\n        options.dangerously__chromeExtensionCompatibleBrowserCheck(\n          navigator.userAgent,\n        ),\n      );\n\n    this._status = new BehaviorSubject<ChromeExtensionStatus>(\n      this.isDesktopChrome\n        ? ChromeExtensionStatus.INITIALIZING\n        : ChromeExtensionStatus.UNAVAILABLE,\n    );\n\n    this._networkInfo = new BehaviorSubject<NetworkInfo>(\n      options.defaultNetwork,\n    );\n\n    this.extensionInfos = getTerraChromeExtensions();\n\n    if (!this.isDesktopChrome) {\n      this._terraAddress = new BehaviorSubject<string | null>(null);\n      return;\n    }\n\n    // ---------------------------------------------\n    // initialize session\n    // ---------------------------------------------\n    if (this.extensionInfos.length === 0) {\n      this._terraAddress = new BehaviorSubject<string | null>(null);\n      this._status.next(ChromeExtensionStatus.UNAVAILABLE);\n      return;\n    }\n\n    const session = getStoredSession();\n\n    if (\n      !session ||\n      !this.extensionInfos.some(\n        (item) => item.identifier === session.identifier,\n      )\n    ) {\n      this._terraAddress = new BehaviorSubject<string | null>(null);\n      this._status.next(ChromeExtensionStatus.WALLET_NOT_CONNECTED);\n      return;\n    }\n\n    this._terraAddress = new BehaviorSubject<string | null>(\n      session.walletAddress,\n    );\n\n    this._extension = extensionFixer(session.identifier);\n\n    this.checkStatus();\n  }\n\n  status = () => {\n    return this._status.asObservable();\n  };\n\n  networkInfo = () => {\n    return this._networkInfo.asObservable();\n  };\n\n  terraAddress = () => {\n    return this._terraAddress.asObservable();\n  };\n\n  checkStatus = async () => {\n    // do not check if browser isn't a chrome\n    if (!this.isDesktopChrome) {\n      return;\n    }\n\n    if (this.extensionInfos.length === 0) {\n      this._status.next(ChromeExtensionStatus.UNAVAILABLE);\n      return;\n    }\n\n    if (!this._extension) {\n      this._status.next(ChromeExtensionStatus.WALLET_NOT_CONNECTED);\n      return;\n    }\n\n    // get networkInfo from extension\n    const infoPayload = await this._extension.info();\n\n    if (\n      infoPayload &&\n      this._networkInfo.getValue().chainID !== infoPayload.chainID\n    ) {\n      this._networkInfo.next(infoPayload);\n    }\n\n    if (this.options.enableWalletConnection) {\n      //const storageStoredWalletAddress: string | null = getStoredAddress();\n      const session = getStoredSession();\n\n      // if the storage has wallet address\n      if (session && AccAddress.validate(session.walletAddress)) {\n        this._status.next(ChromeExtensionStatus.WALLET_CONNECTED);\n\n        const connectResult = await this._extension.connect();\n\n        // if address of extension is not same with the address of localStorage\n        if (\n          connectResult.address &&\n          AccAddress.validate(connectResult.address)\n        ) {\n          storeSession({\n            walletAddress: connectResult.address,\n            identifier: session.identifier,\n          });\n        }\n\n        if (!!connectResult.address) {\n          if (this._terraAddress.getValue() !== connectResult.address) {\n            this._terraAddress.next(connectResult.address);\n          }\n        } else {\n          clearSession();\n          this._status.next(ChromeExtensionStatus.WALLET_NOT_CONNECTED);\n        }\n      } else {\n        if (session) {\n          clearSession();\n        }\n\n        this._status.next(ChromeExtensionStatus.WALLET_NOT_CONNECTED);\n        this._terraAddress.next(null);\n      }\n    } else {\n      this._status.next(ChromeExtensionStatus.WALLET_NOT_CONNECTED);\n      this._terraAddress.next(null);\n    }\n  };\n\n  connect = async (identifier?: string) => {\n    const extensionInfos = getTerraChromeExtensions();\n\n    if (extensionInfos.length === 0) {\n      return false;\n    }\n\n    let extensionInfo: ChromeExtensionInfo | undefined;\n\n    if (identifier) {\n      extensionInfo = extensionInfos.find(\n        (item) => item.identifier === identifier,\n      );\n    } else if (extensionInfos.length === 1) {\n      extensionInfo = extensionInfos[0];\n    } else {\n      const select = this.options.selectExtension ?? defaultSelectModal;\n      const selection = await select(extensionInfos);\n\n      if (selection) {\n        extensionInfo = selection;\n      }\n    }\n\n    if (extensionInfo) {\n      this._extension = extensionFixer(extensionInfo.identifier);\n\n      const result = await this._extension.connect();\n\n      if (result?.address) {\n        const walletAddress: string = result.address;\n\n        storeSession({\n          identifier: extensionInfo.identifier,\n          walletAddress,\n        });\n\n        await this.checkStatus();\n\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  };\n\n  disconnect = () => {\n    clearSession();\n\n    this._status.next(ChromeExtensionStatus.WALLET_NOT_CONNECTED);\n    this._terraAddress.next(null);\n    this._extension = null;\n  };\n\n  recheckStatus = () => {\n    if (this._extension && !this._extension.inTransactionProgress()) {\n      this.checkStatus();\n    }\n  };\n\n  post = <SendData extends {}, Payload extends {}>(\n    data: SendData,\n  ): Promise<{ name: string; payload: Payload }> => {\n    if (!this._extension) {\n      throw new Error(`There is no connected wallet`);\n    }\n    return this._extension.post(data);\n  };\n\n  sign = <SendData extends {}, Payload extends {}>(\n    data: SendData,\n  ): Promise<{ name: string; payload: Payload }> => {\n    if (!this._extension) {\n      throw new Error(`There is no connected wallet`);\n    }\n    return this._extension.sign(data);\n  };\n}\n"],"mappings":"AAAA,SAASA,eAAe,QAAQ,0BAA0B;AAE1D,SAASC,UAAU,QAAQ,uBAAuB;AAClD,SAASC,eAAe,QAAQ,MAAM;AACtC,SAASC,kBAAkB,QAAQ,sBAAsB;AACzD,SAASC,cAAc,QAAwB,kBAAkB;AACjE,SAA8BC,wBAAwB,QAAQ,gBAAgB;AAC9E,SAASC,YAAY,EAAEC,gBAAgB,EAAEC,YAAY,QAAQ,WAAW;AACxE,SAASC,qBAAqB,QAAQ,SAAS;AAa/C,OAAM,MAAOC,yBAAyB;EASpCC,YAAqBC,OAAyC;IAAzC,KAAAA,OAAO,GAAPA,OAAO;IALpB,KAAAC,UAAU,GAA0B,IAAI;IA8DhD,KAAAC,MAAM,GAAG,MAAK;MACZ,OAAO,IAAI,CAACC,OAAO,CAACC,YAAY,EAAE;IACpC,CAAC;IAED,KAAAC,WAAW,GAAG,MAAK;MACjB,OAAO,IAAI,CAACC,YAAY,CAACF,YAAY,EAAE;IACzC,CAAC;IAED,KAAAG,YAAY,GAAG,MAAK;MAClB,OAAO,IAAI,CAACC,aAAa,CAACJ,YAAY,EAAE;IAC1C,CAAC;IAED,KAAAK,WAAW,GAAG,YAAW;MACvB;MACA,IAAI,CAAC,IAAI,CAACrB,eAAe,EAAE;QACzB;;MAGF,IAAI,IAAI,CAACsB,cAAc,CAACC,MAAM,KAAK,CAAC,EAAE;QACpC,IAAI,CAACR,OAAO,CAACS,IAAI,CAACf,qBAAqB,CAACgB,WAAW,CAAC;QACpD;;MAGF,IAAI,CAAC,IAAI,CAACZ,UAAU,EAAE;QACpB,IAAI,CAACE,OAAO,CAACS,IAAI,CAACf,qBAAqB,CAACiB,oBAAoB,CAAC;QAC7D;;MAGF;MACA,MAAMC,WAAW,GAAG,MAAM,IAAI,CAACd,UAAU,CAACe,IAAI,EAAE;MAEhD,IACED,WAAW,IACX,IAAI,CAACT,YAAY,CAACW,QAAQ,EAAE,CAACC,OAAO,KAAKH,WAAW,CAACG,OAAO,EAC5D;QACA,IAAI,CAACZ,YAAY,CAACM,IAAI,CAACG,WAAW,CAAC;;MAGrC,IAAI,IAAI,CAACf,OAAO,CAACmB,sBAAsB,EAAE;QACvC;QACA,MAAMC,OAAO,GAAGzB,gBAAgB,EAAE;QAElC;QACA,IAAIyB,OAAO,IAAI/B,UAAU,CAACgC,QAAQ,CAACD,OAAO,CAACE,aAAa,CAAC,EAAE;UACzD,IAAI,CAACnB,OAAO,CAACS,IAAI,CAACf,qBAAqB,CAAC0B,gBAAgB,CAAC;UAEzD,MAAMC,aAAa,GAAG,MAAM,IAAI,CAACvB,UAAU,CAACwB,OAAO,EAAE;UAErD;UACA,IACED,aAAa,CAACE,OAAO,IACrBrC,UAAU,CAACgC,QAAQ,CAACG,aAAa,CAACE,OAAO,CAAC,EAC1C;YACA9B,YAAY,CAAC;cACX0B,aAAa,EAAEE,aAAa,CAACE,OAAO;cACpCC,UAAU,EAAEP,OAAO,CAACO;aACrB,CAAC;;UAGJ,IAAI,CAAC,CAACH,aAAa,CAACE,OAAO,EAAE;YAC3B,IAAI,IAAI,CAAClB,aAAa,CAACS,QAAQ,EAAE,KAAKO,aAAa,CAACE,OAAO,EAAE;cAC3D,IAAI,CAAClB,aAAa,CAACI,IAAI,CAACY,aAAa,CAACE,OAAO,CAAC;;WAEjD,MAAM;YACLhC,YAAY,EAAE;YACd,IAAI,CAACS,OAAO,CAACS,IAAI,CAACf,qBAAqB,CAACiB,oBAAoB,CAAC;;SAEhE,MAAM;UACL,IAAIM,OAAO,EAAE;YACX1B,YAAY,EAAE;;UAGhB,IAAI,CAACS,OAAO,CAACS,IAAI,CAACf,qBAAqB,CAACiB,oBAAoB,CAAC;UAC7D,IAAI,CAACN,aAAa,CAACI,IAAI,CAAC,IAAI,CAAC;;OAEhC,MAAM;QACL,IAAI,CAACT,OAAO,CAACS,IAAI,CAACf,qBAAqB,CAACiB,oBAAoB,CAAC;QAC7D,IAAI,CAACN,aAAa,CAACI,IAAI,CAAC,IAAI,CAAC;;IAEjC,CAAC;IAED,KAAAa,OAAO,GAAG,MAAOE,UAAmB,IAAI;;MACtC,MAAMjB,cAAc,GAAGjB,wBAAwB,EAAE;MAEjD,IAAIiB,cAAc,CAACC,MAAM,KAAK,CAAC,EAAE;QAC/B,OAAO,KAAK;;MAGd,IAAIiB,aAA8C;MAElD,IAAID,UAAU,EAAE;QACdC,aAAa,GAAGlB,cAAc,CAACmB,IAAI,CAChCC,IAAI,IAAKA,IAAI,CAACH,UAAU,KAAKA,UAAU,CACzC;OACF,MAAM,IAAIjB,cAAc,CAACC,MAAM,KAAK,CAAC,EAAE;QACtCiB,aAAa,GAAGlB,cAAc,CAAC,CAAC,CAAC;OAClC,MAAM;QACL,MAAMqB,MAAM,GAAG,CAAAC,EAAA,OAAI,CAAChC,OAAO,CAACiC,eAAe,cAAAD,EAAA,cAAAA,EAAA,GAAIzC,kBAAkB;QACjE,MAAM2C,SAAS,GAAG,MAAMH,MAAM,CAACrB,cAAc,CAAC;QAE9C,IAAIwB,SAAS,EAAE;UACbN,aAAa,GAAGM,SAAS;;;MAI7B,IAAIN,aAAa,EAAE;QACjB,IAAI,CAAC3B,UAAU,GAAGT,cAAc,CAACoC,aAAa,CAACD,UAAU,CAAC;QAE1D,MAAMQ,MAAM,GAAG,MAAM,IAAI,CAAClC,UAAU,CAACwB,OAAO,EAAE;QAE9C,IAAIU,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAET,OAAO,EAAE;UACnB,MAAMJ,aAAa,GAAWa,MAAM,CAACT,OAAO;UAE5C9B,YAAY,CAAC;YACX+B,UAAU,EAAEC,aAAa,CAACD,UAAU;YACpCL;WACD,CAAC;UAEF,MAAM,IAAI,CAACb,WAAW,EAAE;UAExB,OAAO,IAAI;SACZ,MAAM;UACL,OAAO,KAAK;;OAEf,MAAM;QACL,OAAO,KAAK;;IAEhB,CAAC;IAED,KAAA2B,UAAU,GAAG,MAAK;MAChB1C,YAAY,EAAE;MAEd,IAAI,CAACS,OAAO,CAACS,IAAI,CAACf,qBAAqB,CAACiB,oBAAoB,CAAC;MAC7D,IAAI,CAACN,aAAa,CAACI,IAAI,CAAC,IAAI,CAAC;MAC7B,IAAI,CAACX,UAAU,GAAG,IAAI;IACxB,CAAC;IAED,KAAAoC,aAAa,GAAG,MAAK;MACnB,IAAI,IAAI,CAACpC,UAAU,IAAI,CAAC,IAAI,CAACA,UAAU,CAACqC,qBAAqB,EAAE,EAAE;QAC/D,IAAI,CAAC7B,WAAW,EAAE;;IAEtB,CAAC;IAED,KAAA8B,IAAI,GACFC,IAAc,IACiC;MAC/C,IAAI,CAAC,IAAI,CAACvC,UAAU,EAAE;QACpB,MAAM,IAAIwC,KAAK,+BAA+B,CAAC;;MAEjD,OAAO,IAAI,CAACxC,UAAU,CAACsC,IAAI,CAACC,IAAI,CAAC;IACnC,CAAC;IAED,KAAAE,IAAI,GACFF,IAAc,IACiC;MAC/C,IAAI,CAAC,IAAI,CAACvC,UAAU,EAAE;QACpB,MAAM,IAAIwC,KAAK,+BAA+B,CAAC;;MAEjD,OAAO,IAAI,CAACxC,UAAU,CAACyC,IAAI,CAACF,IAAI,CAAC;IACnC,CAAC;IAvNC,IAAI,CAACpD,eAAe,GAClB,OAAOuD,MAAM,KAAK,WAAW,IAC7BvD,eAAe,CACbY,OAAO,CAAC4C,kDAAkD,CACxDC,SAAS,CAACC,SAAS,CACpB,CACF;IAEH,IAAI,CAAC3C,OAAO,GAAG,IAAIb,eAAe,CAChC,IAAI,CAACF,eAAe,GAChBS,qBAAqB,CAACkD,YAAY,GAClClD,qBAAqB,CAACgB,WAAW,CACtC;IAED,IAAI,CAACP,YAAY,GAAG,IAAIhB,eAAe,CACrCU,OAAO,CAACgD,cAAc,CACvB;IAED,IAAI,CAACtC,cAAc,GAAGjB,wBAAwB,EAAE;IAEhD,IAAI,CAAC,IAAI,CAACL,eAAe,EAAE;MACzB,IAAI,CAACoB,aAAa,GAAG,IAAIlB,eAAe,CAAgB,IAAI,CAAC;MAC7D;;IAGF;IACA;IACA;IACA,IAAI,IAAI,CAACoB,cAAc,CAACC,MAAM,KAAK,CAAC,EAAE;MACpC,IAAI,CAACH,aAAa,GAAG,IAAIlB,eAAe,CAAgB,IAAI,CAAC;MAC7D,IAAI,CAACa,OAAO,CAACS,IAAI,CAACf,qBAAqB,CAACgB,WAAW,CAAC;MACpD;;IAGF,MAAMO,OAAO,GAAGzB,gBAAgB,EAAE;IAElC,IACE,CAACyB,OAAO,IACR,CAAC,IAAI,CAACV,cAAc,CAACuC,IAAI,CACtBnB,IAAI,IAAKA,IAAI,CAACH,UAAU,KAAKP,OAAO,CAACO,UAAU,CACjD,EACD;MACA,IAAI,CAACnB,aAAa,GAAG,IAAIlB,eAAe,CAAgB,IAAI,CAAC;MAC7D,IAAI,CAACa,OAAO,CAACS,IAAI,CAACf,qBAAqB,CAACiB,oBAAoB,CAAC;MAC7D;;IAGF,IAAI,CAACN,aAAa,GAAG,IAAIlB,eAAe,CACtC8B,OAAO,CAACE,aAAa,CACtB;IAED,IAAI,CAACrB,UAAU,GAAGT,cAAc,CAAC4B,OAAO,CAACO,UAAU,CAAC;IAEpD,IAAI,CAAClB,WAAW,EAAE;EACpB"},"metadata":{},"sourceType":"module","externalDependencies":[]}