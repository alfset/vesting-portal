{"ast":null,"code":"import { useEffect, useMemo, useState, useCallback } from \"react\";\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { MaxUint256 } from '@ethersproject/constants';\nimport { useTokenAllowance } from '../data/Allowances';\nimport { useTransactionAdder, useHasPendingApproval } from '../state/transactions/hooks';\nimport { calculateGasMargin } from '../utils';\nimport { recordsApprove } from '../utils/bridge/register';\nimport { useTokenContract } from './useContract';\nimport { useActiveWeb3React } from './index';\nimport config from '../config';\nexport let ApprovalState = /*#__PURE__*/function (ApprovalState) {\n  ApprovalState[ApprovalState[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  ApprovalState[ApprovalState[\"NOT_APPROVED\"] = 1] = \"NOT_APPROVED\";\n  ApprovalState[ApprovalState[\"PENDING\"] = 2] = \"PENDING\";\n  ApprovalState[ApprovalState[\"APPROVED\"] = 3] = \"APPROVED\";\n  return ApprovalState;\n}({});\n\n// returns a variable indicating the state of the approval and a function which approves if necessary or early returns\nexport function useApproveCallback(amountToApprove, spender, token) {\n  const {\n    account,\n    chainId\n  } = useActiveWeb3React();\n  // const token = amountToApprove?.token ? amountToApprove.token : undefined\n  // console.log(amountToApprove)\n  // console.log(amountToApprove ? amountToApprove.raw.toString() : '')\n  const currentAllowance = useTokenAllowance(token, account !== null && account !== void 0 ? account : undefined, spender);\n  const pendingApproval = useHasPendingApproval(token === null || token === void 0 ? void 0 : token.address, spender);\n  // console.log(currentAllowance)\n  // console.log(amountToApprove)\n  // console.log(token)\n  // console.log(spender)\n  // console.log(token)\n  // check the current approval status\n  const approvalState = useMemo(() => {\n    if (!amountToApprove || !spender) return ApprovalState.UNKNOWN;\n    // we might not have enough data to know whether or not we need to approve\n    if (!currentAllowance) return ApprovalState.UNKNOWN;\n\n    // amountToApprove will be defined if currentAllowance is\n    return currentAllowance.lessThan(amountToApprove) ? pendingApproval ? ApprovalState.PENDING : ApprovalState.NOT_APPROVED : ApprovalState.APPROVED;\n  }, [amountToApprove, currentAllowance, pendingApproval, spender]);\n  const tokenContract = useTokenContract(token === null || token === void 0 ? void 0 : token.address);\n  const addTransaction = useTransactionAdder();\n  const approve = useCallback(async () => {\n    console.log(amountToApprove ? amountToApprove.raw.toString() : '');\n    if (approvalState !== ApprovalState.NOT_APPROVED) {\n      console.error('approve was called unnecessarily');\n      return;\n    }\n    if (!token) {\n      console.error('no token');\n      return;\n    }\n    if (!tokenContract) {\n      console.error('tokenContract is null');\n      return;\n    }\n    if (!amountToApprove) {\n      console.error('missing amount to approve');\n      return;\n    }\n    if (!spender) {\n      console.error('no spender');\n      return;\n    }\n    let useExact = false;\n    const estimatedGas = await tokenContract.estimateGas.approve(spender, MaxUint256).catch(() => {\n      // general fallback for tokens who restrict approval amounts\n      useExact = true;\n      return tokenContract.estimateGas.approve(spender, amountToApprove.raw.toString());\n    });\n    return tokenContract.approve(spender, useExact ? amountToApprove.raw.toString() : MaxUint256, {\n      gasLimit: calculateGasMargin(estimatedGas)\n    }).then(response => {\n      recordsApprove({\n        token: token === null || token === void 0 ? void 0 : token.address,\n        spender: spender,\n        account: account,\n        amount: useExact ? amountToApprove.raw.toString() : MaxUint256,\n        symbol: token.symbol,\n        decimals: token.decimals,\n        hash: response === null || response === void 0 ? void 0 : response.hash,\n        chainId: chainId,\n        type: \"Approve\"\n      });\n      addTransaction(response, {\n        summary: config.getBaseCoin(token.symbol, chainId) + ' approved, you can continue the cross chain transaction',\n        // summary: t('approvedTip', {\n        //   symbol: config.getBaseCoin(amountToApprove.currency.symbol, chainId)\n        // }),\n        approval: {\n          tokenAddress: token.address,\n          spender: spender\n        }\n      });\n    }).catch(error => {\n      console.debug('Failed to approve token', error);\n      throw error;\n    });\n  }, [approvalState, token, tokenContract, amountToApprove, spender, addTransaction]);\n  return [approvalState, approve];\n}\nexport function useNonApproveCallback(token, spender, symbol) {\n  const {\n    account,\n    chainId\n  } = useActiveWeb3React();\n  const addTransaction = useTransactionAdder();\n  const pendingApproval = useHasPendingApproval(token !== null && token !== void 0 ? token : undefined, spender !== null && spender !== void 0 ? spender : undefined);\n  const [isSetApprove, setIsSetApprove] = useState(false);\n\n  // const contract = useTokenContract(token, false)\n  const tokenContract = useTokenContract(token);\n  // if (!tokenContract || !spender || !account || !symbol || !chainId) return {\n  //   isSetApprove: false,\n  //   approve: () => {console.log()}\n  // }\n  useEffect(() => {\n    if (tokenContract && account && chainId && spender && token) {\n      try {\n        tokenContract.allowance(account, spender).then(res => {\n          console.log(res);\n          if (res && res._hex && res.gt(BigNumber.from(0))) {\n            setIsSetApprove(true);\n          } else {\n            setIsSetApprove(false);\n          }\n        }).catch(error => {\n          console.debug('Failed to approve token', error);\n          throw error;\n        });\n      } catch (error) {\n        console.debug('Failed to approve token', error);\n        throw error;\n      }\n    } else {\n      setIsSetApprove(false);\n    }\n  }, [tokenContract, pendingApproval]);\n  const approve = useCallback(async () => {\n    if (!tokenContract || !spender || !account || !symbol || !chainId) return;\n    return tokenContract.approve(spender, '0x0').then(response => {\n      recordsApprove({\n        token: token,\n        spender: spender,\n        account: account,\n        amount: '0x0',\n        symbol: symbol,\n        decimals: 18,\n        hash: response === null || response === void 0 ? void 0 : response.hash,\n        chainId: chainId,\n        type: \"Revoke\"\n      });\n      addTransaction(response, {\n        summary: 'Approve ' + config.getBaseCoin(symbol, chainId),\n        approval: {\n          tokenAddress: token,\n          spender: spender\n        }\n      });\n    }).catch(error => {\n      console.debug('Failed to approve token', error);\n      throw error;\n    });\n  }, [tokenContract, spender, account, chainId, addTransaction]);\n  return {\n    isSetApprove,\n    approve\n  };\n  // return useMemo(() => {\n  // }, [isSetApprove, approve])\n}","map":{"version":3,"names":["useEffect","useMemo","useState","useCallback","BigNumber","MaxUint256","useTokenAllowance","useTransactionAdder","useHasPendingApproval","calculateGasMargin","recordsApprove","useTokenContract","useActiveWeb3React","config","ApprovalState","useApproveCallback","amountToApprove","spender","token","account","chainId","currentAllowance","undefined","pendingApproval","address","approvalState","UNKNOWN","lessThan","PENDING","NOT_APPROVED","APPROVED","tokenContract","addTransaction","approve","console","log","raw","toString","error","useExact","estimatedGas","estimateGas","catch","gasLimit","then","response","amount","symbol","decimals","hash","type","summary","getBaseCoin","approval","tokenAddress","debug","useNonApproveCallback","isSetApprove","setIsSetApprove","allowance","res","_hex","gt","from"],"sources":["/workspace/Planq-Dapps/vesting-portal/src/hooks/useApproveCallback.ts"],"sourcesContent":["import { useEffect, useMemo, useState, useCallback } from \"react\"\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { MaxUint256 } from '@ethersproject/constants'\nimport { TransactionResponse } from '@ethersproject/providers'\nimport { useTokenAllowance } from '../data/Allowances'\nimport { useTransactionAdder, useHasPendingApproval } from '../state/transactions/hooks'\nimport { calculateGasMargin } from '../utils'\nimport {recordsApprove} from '../utils/bridge/register'\nimport { useTokenContract } from './useContract'\nimport { useActiveWeb3React } from './index'\n\nimport config from '../config'\n\nexport enum ApprovalState {\n  UNKNOWN,\n  NOT_APPROVED,\n  PENDING,\n  APPROVED\n}\n\n// returns a variable indicating the state of the approval and a function which approves if necessary or early returns\nexport function useApproveCallback(\n  amountToApprove?: any,\n  spender?: string,\n  token?: any\n): [ApprovalState, () => Promise<void>] {\n  const { account, chainId } = useActiveWeb3React()\n  // const token = amountToApprove?.token ? amountToApprove.token : undefined\n  // console.log(amountToApprove)\n  // console.log(amountToApprove ? amountToApprove.raw.toString() : '')\n  const currentAllowance = useTokenAllowance(token, account ?? undefined, spender)\n  const pendingApproval = useHasPendingApproval(token?.address, spender)\n  // console.log(currentAllowance)\n  // console.log(amountToApprove)\n  // console.log(token)\n  // console.log(spender)\n  // console.log(token)\n  // check the current approval status\n  const approvalState: ApprovalState = useMemo(() => {\n    if (!amountToApprove || !spender) return ApprovalState.UNKNOWN\n    // we might not have enough data to know whether or not we need to approve\n    if (!currentAllowance) return ApprovalState.UNKNOWN\n\n    // amountToApprove will be defined if currentAllowance is\n    return currentAllowance.lessThan(amountToApprove)\n      ? pendingApproval\n        ? ApprovalState.PENDING\n        : ApprovalState.NOT_APPROVED\n      : ApprovalState.APPROVED\n  }, [amountToApprove, currentAllowance, pendingApproval, spender])\n\n  const tokenContract = useTokenContract(token?.address)\n  const addTransaction = useTransactionAdder()\n\n  const approve = useCallback(async (): Promise<void> => {\n    console.log(amountToApprove ? amountToApprove.raw.toString() : '')\n    if (approvalState !== ApprovalState.NOT_APPROVED) {\n      console.error('approve was called unnecessarily')\n      return\n    }\n    if (!token) {\n      console.error('no token')\n      return\n    }\n\n    if (!tokenContract) {\n      console.error('tokenContract is null')\n      return\n    }\n\n    if (!amountToApprove) {\n      console.error('missing amount to approve')\n      return\n    }\n\n    if (!spender) {\n      console.error('no spender')\n      return\n    }\n\n    let useExact = false\n    const estimatedGas = await tokenContract.estimateGas.approve(spender, MaxUint256).catch(() => {\n      // general fallback for tokens who restrict approval amounts\n      useExact = true\n      return tokenContract.estimateGas.approve(spender, amountToApprove.raw.toString())\n    })\n\n    return tokenContract\n      .approve(spender, useExact ? amountToApprove.raw.toString() : MaxUint256, {\n        gasLimit: calculateGasMargin(estimatedGas)\n      })\n      .then((response: TransactionResponse) => {\n        recordsApprove({\n          token: token?.address,\n          spender: spender,\n          account: account,\n          amount: useExact ? amountToApprove.raw.toString() : MaxUint256,\n          symbol: token.symbol,\n          decimals: token.decimals,\n          hash: response?.hash,\n          chainId: chainId,\n          type: \"Approve\",\n        })\n        addTransaction(response, {\n          summary: config.getBaseCoin(token.symbol, chainId) + ' approved, you can continue the cross chain transaction',\n          // summary: t('approvedTip', {\n          //   symbol: config.getBaseCoin(amountToApprove.currency.symbol, chainId)\n          // }),\n          approval: { tokenAddress: token.address, spender: spender }\n        })\n      })\n      .catch((error: Error) => {\n        console.debug('Failed to approve token', error)\n        throw error\n      })\n  }, [approvalState, token, tokenContract, amountToApprove, spender, addTransaction])\n\n  return [approvalState, approve]\n}\n\nexport function useNonApproveCallback(\n  token: any,\n  spender: any,\n  symbol: any,\n) {\n  const { account, chainId } = useActiveWeb3React()\n  const addTransaction = useTransactionAdder()\n  const pendingApproval = useHasPendingApproval(token ?? undefined, spender ?? undefined)\n\n  const [isSetApprove, setIsSetApprove] = useState<any>(false)\n\n  // const contract = useTokenContract(token, false)\n  const tokenContract = useTokenContract(token)\n  // if (!tokenContract || !spender || !account || !symbol || !chainId) return {\n  //   isSetApprove: false,\n  //   approve: () => {console.log()}\n  // }\n  useEffect(() => {\n    if (\n      tokenContract\n      && account\n      && chainId\n      && spender\n      && token\n    ) {\n      try {\n        tokenContract.allowance(account, spender).then((res:any) => {\n          console.log(res)\n          if (res && res._hex && res.gt(BigNumber.from(0))) {\n            setIsSetApprove(true)\n          } else {\n            setIsSetApprove(false)\n          }\n        }).catch((error: Error) => {\n          console.debug('Failed to approve token', error)\n          throw error\n        })\n      } catch (error) {\n        console.debug('Failed to approve token', error)\n          throw error\n      }\n    } else {\n      setIsSetApprove(false)\n    }\n  }, [tokenContract, pendingApproval])\n\n  const approve = useCallback(async (): Promise<void> => {\n    if (!tokenContract || !spender || !account || !symbol || !chainId) return\n    return tokenContract.approve(spender, '0x0').then((response: TransactionResponse) => {\n      recordsApprove({\n        token: token,\n        spender: spender,\n        account: account,\n        amount: '0x0',\n        symbol: symbol,\n        decimals: 18,\n        hash: response?.hash,\n        chainId: chainId,\n        type: \"Revoke\",\n      })\n      addTransaction(response, {\n        summary: 'Approve ' + config.getBaseCoin(symbol, chainId),\n        approval: { tokenAddress: token, spender: spender }\n      })\n    })\n    .catch((error: Error) => {\n      console.debug('Failed to approve token', error)\n      throw error\n    })\n  }, [tokenContract, spender, account, chainId, addTransaction])\n\n  \n  return {\n    isSetApprove,\n    approve\n  }\n  // return useMemo(() => {\n  // }, [isSetApprove, approve])\n}\n"],"mappings":"AAAA,SAASA,SAAS,EAAEC,OAAO,EAAEC,QAAQ,EAAEC,WAAW,QAAQ,OAAO;AACjE,SAASC,SAAS,QAAQ,0BAA0B;AACpD,SAASC,UAAU,QAAQ,0BAA0B;AAErD,SAASC,iBAAiB,QAAQ,oBAAoB;AACtD,SAASC,mBAAmB,EAAEC,qBAAqB,QAAQ,6BAA6B;AACxF,SAASC,kBAAkB,QAAQ,UAAU;AAC7C,SAAQC,cAAc,QAAO,0BAA0B;AACvD,SAASC,gBAAgB,QAAQ,eAAe;AAChD,SAASC,kBAAkB,QAAQ,SAAS;AAE5C,OAAOC,MAAM,MAAM,WAAW;AAE9B,WAAYC,aAAa,0BAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAbA,aAAa,CAAbA,aAAa;EAAA,OAAbA,aAAa;AAAA;;AAOzB;AACA,OAAO,SAASC,kBAAkBA,CAChCC,eAAqB,EACrBC,OAAgB,EAChBC,KAAW,EAC2B;EACtC,MAAM;IAAEC,OAAO;IAAEC;EAAQ,CAAC,GAAGR,kBAAkB,CAAC,CAAC;EACjD;EACA;EACA;EACA,MAAMS,gBAAgB,GAAGf,iBAAiB,CAACY,KAAK,EAAEC,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAIG,SAAS,EAAEL,OAAO,CAAC;EAChF,MAAMM,eAAe,GAAGf,qBAAqB,CAACU,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEM,OAAO,EAAEP,OAAO,CAAC;EACtE;EACA;EACA;EACA;EACA;EACA;EACA,MAAMQ,aAA4B,GAAGxB,OAAO,CAAC,MAAM;IACjD,IAAI,CAACe,eAAe,IAAI,CAACC,OAAO,EAAE,OAAOH,aAAa,CAACY,OAAO;IAC9D;IACA,IAAI,CAACL,gBAAgB,EAAE,OAAOP,aAAa,CAACY,OAAO;;IAEnD;IACA,OAAOL,gBAAgB,CAACM,QAAQ,CAACX,eAAe,CAAC,GAC7CO,eAAe,GACbT,aAAa,CAACc,OAAO,GACrBd,aAAa,CAACe,YAAY,GAC5Bf,aAAa,CAACgB,QAAQ;EAC5B,CAAC,EAAE,CAACd,eAAe,EAAEK,gBAAgB,EAAEE,eAAe,EAAEN,OAAO,CAAC,CAAC;EAEjE,MAAMc,aAAa,GAAGpB,gBAAgB,CAACO,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEM,OAAO,CAAC;EACtD,MAAMQ,cAAc,GAAGzB,mBAAmB,CAAC,CAAC;EAE5C,MAAM0B,OAAO,GAAG9B,WAAW,CAAC,YAA2B;IACrD+B,OAAO,CAACC,GAAG,CAACnB,eAAe,GAAGA,eAAe,CAACoB,GAAG,CAACC,QAAQ,CAAC,CAAC,GAAG,EAAE,CAAC;IAClE,IAAIZ,aAAa,KAAKX,aAAa,CAACe,YAAY,EAAE;MAChDK,OAAO,CAACI,KAAK,CAAC,kCAAkC,CAAC;MACjD;IACF;IACA,IAAI,CAACpB,KAAK,EAAE;MACVgB,OAAO,CAACI,KAAK,CAAC,UAAU,CAAC;MACzB;IACF;IAEA,IAAI,CAACP,aAAa,EAAE;MAClBG,OAAO,CAACI,KAAK,CAAC,uBAAuB,CAAC;MACtC;IACF;IAEA,IAAI,CAACtB,eAAe,EAAE;MACpBkB,OAAO,CAACI,KAAK,CAAC,2BAA2B,CAAC;MAC1C;IACF;IAEA,IAAI,CAACrB,OAAO,EAAE;MACZiB,OAAO,CAACI,KAAK,CAAC,YAAY,CAAC;MAC3B;IACF;IAEA,IAAIC,QAAQ,GAAG,KAAK;IACpB,MAAMC,YAAY,GAAG,MAAMT,aAAa,CAACU,WAAW,CAACR,OAAO,CAAChB,OAAO,EAAEZ,UAAU,CAAC,CAACqC,KAAK,CAAC,MAAM;MAC5F;MACAH,QAAQ,GAAG,IAAI;MACf,OAAOR,aAAa,CAACU,WAAW,CAACR,OAAO,CAAChB,OAAO,EAAED,eAAe,CAACoB,GAAG,CAACC,QAAQ,CAAC,CAAC,CAAC;IACnF,CAAC,CAAC;IAEF,OAAON,aAAa,CACjBE,OAAO,CAAChB,OAAO,EAAEsB,QAAQ,GAAGvB,eAAe,CAACoB,GAAG,CAACC,QAAQ,CAAC,CAAC,GAAGhC,UAAU,EAAE;MACxEsC,QAAQ,EAAElC,kBAAkB,CAAC+B,YAAY;IAC3C,CAAC,CAAC,CACDI,IAAI,CAAEC,QAA6B,IAAK;MACvCnC,cAAc,CAAC;QACbQ,KAAK,EAAEA,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEM,OAAO;QACrBP,OAAO,EAAEA,OAAO;QAChBE,OAAO,EAAEA,OAAO;QAChB2B,MAAM,EAAEP,QAAQ,GAAGvB,eAAe,CAACoB,GAAG,CAACC,QAAQ,CAAC,CAAC,GAAGhC,UAAU;QAC9D0C,MAAM,EAAE7B,KAAK,CAAC6B,MAAM;QACpBC,QAAQ,EAAE9B,KAAK,CAAC8B,QAAQ;QACxBC,IAAI,EAAEJ,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEI,IAAI;QACpB7B,OAAO,EAAEA,OAAO;QAChB8B,IAAI,EAAE;MACR,CAAC,CAAC;MACFlB,cAAc,CAACa,QAAQ,EAAE;QACvBM,OAAO,EAAEtC,MAAM,CAACuC,WAAW,CAAClC,KAAK,CAAC6B,MAAM,EAAE3B,OAAO,CAAC,GAAG,yDAAyD;QAC9G;QACA;QACA;QACAiC,QAAQ,EAAE;UAAEC,YAAY,EAAEpC,KAAK,CAACM,OAAO;UAAEP,OAAO,EAAEA;QAAQ;MAC5D,CAAC,CAAC;IACJ,CAAC,CAAC,CACDyB,KAAK,CAAEJ,KAAY,IAAK;MACvBJ,OAAO,CAACqB,KAAK,CAAC,yBAAyB,EAAEjB,KAAK,CAAC;MAC/C,MAAMA,KAAK;IACb,CAAC,CAAC;EACN,CAAC,EAAE,CAACb,aAAa,EAAEP,KAAK,EAAEa,aAAa,EAAEf,eAAe,EAAEC,OAAO,EAAEe,cAAc,CAAC,CAAC;EAEnF,OAAO,CAACP,aAAa,EAAEQ,OAAO,CAAC;AACjC;AAEA,OAAO,SAASuB,qBAAqBA,CACnCtC,KAAU,EACVD,OAAY,EACZ8B,MAAW,EACX;EACA,MAAM;IAAE5B,OAAO;IAAEC;EAAQ,CAAC,GAAGR,kBAAkB,CAAC,CAAC;EACjD,MAAMoB,cAAc,GAAGzB,mBAAmB,CAAC,CAAC;EAC5C,MAAMgB,eAAe,GAAGf,qBAAqB,CAACU,KAAK,aAALA,KAAK,cAALA,KAAK,GAAII,SAAS,EAAEL,OAAO,aAAPA,OAAO,cAAPA,OAAO,GAAIK,SAAS,CAAC;EAEvF,MAAM,CAACmC,YAAY,EAAEC,eAAe,CAAC,GAAGxD,QAAQ,CAAM,KAAK,CAAC;;EAE5D;EACA,MAAM6B,aAAa,GAAGpB,gBAAgB,CAACO,KAAK,CAAC;EAC7C;EACA;EACA;EACA;EACAlB,SAAS,CAAC,MAAM;IACd,IACE+B,aAAa,IACVZ,OAAO,IACPC,OAAO,IACPH,OAAO,IACPC,KAAK,EACR;MACA,IAAI;QACFa,aAAa,CAAC4B,SAAS,CAACxC,OAAO,EAAEF,OAAO,CAAC,CAAC2B,IAAI,CAAEgB,GAAO,IAAK;UAC1D1B,OAAO,CAACC,GAAG,CAACyB,GAAG,CAAC;UAChB,IAAIA,GAAG,IAAIA,GAAG,CAACC,IAAI,IAAID,GAAG,CAACE,EAAE,CAAC1D,SAAS,CAAC2D,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;YAChDL,eAAe,CAAC,IAAI,CAAC;UACvB,CAAC,MAAM;YACLA,eAAe,CAAC,KAAK,CAAC;UACxB;QACF,CAAC,CAAC,CAAChB,KAAK,CAAEJ,KAAY,IAAK;UACzBJ,OAAO,CAACqB,KAAK,CAAC,yBAAyB,EAAEjB,KAAK,CAAC;UAC/C,MAAMA,KAAK;QACb,CAAC,CAAC;MACJ,CAAC,CAAC,OAAOA,KAAK,EAAE;QACdJ,OAAO,CAACqB,KAAK,CAAC,yBAAyB,EAAEjB,KAAK,CAAC;QAC7C,MAAMA,KAAK;MACf;IACF,CAAC,MAAM;MACLoB,eAAe,CAAC,KAAK,CAAC;IACxB;EACF,CAAC,EAAE,CAAC3B,aAAa,EAAER,eAAe,CAAC,CAAC;EAEpC,MAAMU,OAAO,GAAG9B,WAAW,CAAC,YAA2B;IACrD,IAAI,CAAC4B,aAAa,IAAI,CAACd,OAAO,IAAI,CAACE,OAAO,IAAI,CAAC4B,MAAM,IAAI,CAAC3B,OAAO,EAAE;IACnE,OAAOW,aAAa,CAACE,OAAO,CAAChB,OAAO,EAAE,KAAK,CAAC,CAAC2B,IAAI,CAAEC,QAA6B,IAAK;MACnFnC,cAAc,CAAC;QACbQ,KAAK,EAAEA,KAAK;QACZD,OAAO,EAAEA,OAAO;QAChBE,OAAO,EAAEA,OAAO;QAChB2B,MAAM,EAAE,KAAK;QACbC,MAAM,EAAEA,MAAM;QACdC,QAAQ,EAAE,EAAE;QACZC,IAAI,EAAEJ,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEI,IAAI;QACpB7B,OAAO,EAAEA,OAAO;QAChB8B,IAAI,EAAE;MACR,CAAC,CAAC;MACFlB,cAAc,CAACa,QAAQ,EAAE;QACvBM,OAAO,EAAE,UAAU,GAAGtC,MAAM,CAACuC,WAAW,CAACL,MAAM,EAAE3B,OAAO,CAAC;QACzDiC,QAAQ,EAAE;UAAEC,YAAY,EAAEpC,KAAK;UAAED,OAAO,EAAEA;QAAQ;MACpD,CAAC,CAAC;IACJ,CAAC,CAAC,CACDyB,KAAK,CAAEJ,KAAY,IAAK;MACvBJ,OAAO,CAACqB,KAAK,CAAC,yBAAyB,EAAEjB,KAAK,CAAC;MAC/C,MAAMA,KAAK;IACb,CAAC,CAAC;EACJ,CAAC,EAAE,CAACP,aAAa,EAAEd,OAAO,EAAEE,OAAO,EAAEC,OAAO,EAAEY,cAAc,CAAC,CAAC;EAG9D,OAAO;IACLyB,YAAY;IACZxB;EACF,CAAC;EACD;EACA;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}