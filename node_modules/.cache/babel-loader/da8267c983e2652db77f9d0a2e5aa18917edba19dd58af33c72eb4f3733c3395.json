{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.Block = void 0;\nconst bufferutils_1 = require('./bufferutils');\nconst bcrypto = require('./crypto');\nconst merkle_1 = require('./merkle');\nconst transaction_1 = require('./transaction');\nconst types = require('./types');\nconst {\n  typeforce\n} = types;\nconst errorMerkleNoTxes = new TypeError('Cannot compute merkle root for zero transactions');\nconst errorWitnessNotSegwit = new TypeError('Cannot compute witness commit for non-segwit block');\nclass Block {\n  constructor() {\n    this.version = 1;\n    this.prevHash = undefined;\n    this.merkleRoot = undefined;\n    this.timestamp = 0;\n    this.witnessCommit = undefined;\n    this.bits = 0;\n    this.nonce = 0;\n    this.transactions = undefined;\n  }\n  static fromBuffer(buffer) {\n    if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const block = new Block();\n    block.version = bufferReader.readInt32();\n    block.prevHash = bufferReader.readSlice(32);\n    block.merkleRoot = bufferReader.readSlice(32);\n    block.timestamp = bufferReader.readUInt32();\n    block.bits = bufferReader.readUInt32();\n    block.nonce = bufferReader.readUInt32();\n    if (buffer.length === 80) return block;\n    const readTransaction = () => {\n      const tx = transaction_1.Transaction.fromBuffer(bufferReader.buffer.slice(bufferReader.offset), true);\n      bufferReader.offset += tx.byteLength();\n      return tx;\n    };\n    const nTransactions = bufferReader.readVarInt();\n    block.transactions = [];\n    for (let i = 0; i < nTransactions; ++i) {\n      const tx = readTransaction();\n      block.transactions.push(tx);\n    }\n    const witnessCommit = block.getWitnessCommit();\n    // This Block contains a witness commit\n    if (witnessCommit) block.witnessCommit = witnessCommit;\n    return block;\n  }\n  static fromHex(hex) {\n    return Block.fromBuffer(Buffer.from(hex, 'hex'));\n  }\n  static calculateTarget(bits) {\n    const exponent = ((bits & 0xff000000) >> 24) - 3;\n    const mantissa = bits & 0x007fffff;\n    const target = Buffer.alloc(32, 0);\n    target.writeUIntBE(mantissa, 29 - exponent, 3);\n    return target;\n  }\n  static calculateMerkleRoot(transactions, forWitness) {\n    typeforce([{\n      getHash: types.Function\n    }], transactions);\n    if (transactions.length === 0) throw errorMerkleNoTxes;\n    if (forWitness && !txesHaveWitnessCommit(transactions)) throw errorWitnessNotSegwit;\n    const hashes = transactions.map(transaction => transaction.getHash(forWitness));\n    const rootHash = (0, merkle_1.fastMerkleRoot)(hashes, bcrypto.hash256);\n    return forWitness ? bcrypto.hash256(Buffer.concat([rootHash, transactions[0].ins[0].witness[0]])) : rootHash;\n  }\n  getWitnessCommit() {\n    if (!txesHaveWitnessCommit(this.transactions)) return null;\n    // The merkle root for the witness data is in an OP_RETURN output.\n    // There is no rule for the index of the output, so use filter to find it.\n    // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed\n    // If multiple commits are found, the output with highest index is assumed.\n    const witnessCommits = this.transactions[0].outs.filter(out => out.script.slice(0, 6).equals(Buffer.from('6a24aa21a9ed', 'hex'))).map(out => out.script.slice(6, 38));\n    if (witnessCommits.length === 0) return null;\n    // Use the commit with the highest output (should only be one though)\n    const result = witnessCommits[witnessCommits.length - 1];\n    if (!(result instanceof Buffer && result.length === 32)) return null;\n    return result;\n  }\n  hasWitnessCommit() {\n    if (this.witnessCommit instanceof Buffer && this.witnessCommit.length === 32) return true;\n    if (this.getWitnessCommit() !== null) return true;\n    return false;\n  }\n  hasWitness() {\n    return anyTxHasWitness(this.transactions);\n  }\n  weight() {\n    const base = this.byteLength(false, false);\n    const total = this.byteLength(false, true);\n    return base * 3 + total;\n  }\n  byteLength(headersOnly) {\n    let allowWitness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (headersOnly || !this.transactions) return 80;\n    return 80 + bufferutils_1.varuint.encodingLength(this.transactions.length) + this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0);\n  }\n  getHash() {\n    return bcrypto.hash256(this.toBuffer(true));\n  }\n  getId() {\n    return (0, bufferutils_1.reverseBuffer)(this.getHash()).toString('hex');\n  }\n  getUTCDate() {\n    const date = new Date(0); // epoch\n    date.setUTCSeconds(this.timestamp);\n    return date;\n  }\n  // TODO: buffer, offset compatibility\n  toBuffer(headersOnly) {\n    const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));\n    const bufferWriter = new bufferutils_1.BufferWriter(buffer);\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(this.prevHash);\n    bufferWriter.writeSlice(this.merkleRoot);\n    bufferWriter.writeUInt32(this.timestamp);\n    bufferWriter.writeUInt32(this.bits);\n    bufferWriter.writeUInt32(this.nonce);\n    if (headersOnly || !this.transactions) return buffer;\n    bufferutils_1.varuint.encode(this.transactions.length, buffer, bufferWriter.offset);\n    bufferWriter.offset += bufferutils_1.varuint.encode.bytes;\n    this.transactions.forEach(tx => {\n      const txSize = tx.byteLength(); // TODO: extract from toBuffer?\n      tx.toBuffer(buffer, bufferWriter.offset);\n      bufferWriter.offset += txSize;\n    });\n    return buffer;\n  }\n  toHex(headersOnly) {\n    return this.toBuffer(headersOnly).toString('hex');\n  }\n  checkTxRoots() {\n    // If the Block has segwit transactions but no witness commit,\n    // there's no way it can be valid, so fail the check.\n    const hasWitnessCommit = this.hasWitnessCommit();\n    if (!hasWitnessCommit && this.hasWitness()) return false;\n    return this.__checkMerkleRoot() && (hasWitnessCommit ? this.__checkWitnessCommit() : true);\n  }\n  checkProofOfWork() {\n    const hash = (0, bufferutils_1.reverseBuffer)(this.getHash());\n    const target = Block.calculateTarget(this.bits);\n    return hash.compare(target) <= 0;\n  }\n  __checkMerkleRoot() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n    return this.merkleRoot.compare(actualMerkleRoot) === 0;\n  }\n  __checkWitnessCommit() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;\n    const actualWitnessCommit = Block.calculateMerkleRoot(this.transactions, true);\n    return this.witnessCommit.compare(actualWitnessCommit) === 0;\n  }\n}\nexports.Block = Block;\nfunction txesHaveWitnessCommit(transactions) {\n  return transactions instanceof Array && transactions[0] && transactions[0].ins && transactions[0].ins instanceof Array && transactions[0].ins[0] && transactions[0].ins[0].witness && transactions[0].ins[0].witness instanceof Array && transactions[0].ins[0].witness.length > 0;\n}\nfunction anyTxHasWitness(transactions) {\n  return transactions instanceof Array && transactions.some(tx => typeof tx === 'object' && tx.ins instanceof Array && tx.ins.some(input => typeof input === 'object' && input.witness instanceof Array && input.witness.length > 0));\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","Block","bufferutils_1","require","bcrypto","merkle_1","transaction_1","types","typeforce","errorMerkleNoTxes","TypeError","errorWitnessNotSegwit","constructor","version","prevHash","undefined","merkleRoot","timestamp","witnessCommit","bits","nonce","transactions","fromBuffer","buffer","length","Error","bufferReader","BufferReader","block","readInt32","readSlice","readUInt32","readTransaction","tx","Transaction","slice","offset","byteLength","nTransactions","readVarInt","i","push","getWitnessCommit","fromHex","hex","Buffer","from","calculateTarget","exponent","mantissa","target","alloc","writeUIntBE","calculateMerkleRoot","forWitness","getHash","Function","txesHaveWitnessCommit","hashes","map","transaction","rootHash","fastMerkleRoot","hash256","concat","ins","witness","witnessCommits","outs","filter","out","script","equals","result","hasWitnessCommit","hasWitness","anyTxHasWitness","weight","base","total","headersOnly","allowWitness","arguments","varuint","encodingLength","reduce","a","x","toBuffer","getId","reverseBuffer","toString","getUTCDate","date","Date","setUTCSeconds","allocUnsafe","bufferWriter","BufferWriter","writeInt32","writeSlice","writeUInt32","encode","bytes","forEach","txSize","toHex","checkTxRoots","__checkMerkleRoot","__checkWitnessCommit","checkProofOfWork","hash","compare","actualMerkleRoot","actualWitnessCommit","Array","some","input"],"sources":["/workspace/Planq-Dapps/vesting-portal/node_modules/bitcoinjs-lib/src/block.js"],"sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.Block = void 0;\nconst bufferutils_1 = require('./bufferutils');\nconst bcrypto = require('./crypto');\nconst merkle_1 = require('./merkle');\nconst transaction_1 = require('./transaction');\nconst types = require('./types');\nconst { typeforce } = types;\nconst errorMerkleNoTxes = new TypeError(\n  'Cannot compute merkle root for zero transactions',\n);\nconst errorWitnessNotSegwit = new TypeError(\n  'Cannot compute witness commit for non-segwit block',\n);\nclass Block {\n  constructor() {\n    this.version = 1;\n    this.prevHash = undefined;\n    this.merkleRoot = undefined;\n    this.timestamp = 0;\n    this.witnessCommit = undefined;\n    this.bits = 0;\n    this.nonce = 0;\n    this.transactions = undefined;\n  }\n  static fromBuffer(buffer) {\n    if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const block = new Block();\n    block.version = bufferReader.readInt32();\n    block.prevHash = bufferReader.readSlice(32);\n    block.merkleRoot = bufferReader.readSlice(32);\n    block.timestamp = bufferReader.readUInt32();\n    block.bits = bufferReader.readUInt32();\n    block.nonce = bufferReader.readUInt32();\n    if (buffer.length === 80) return block;\n    const readTransaction = () => {\n      const tx = transaction_1.Transaction.fromBuffer(\n        bufferReader.buffer.slice(bufferReader.offset),\n        true,\n      );\n      bufferReader.offset += tx.byteLength();\n      return tx;\n    };\n    const nTransactions = bufferReader.readVarInt();\n    block.transactions = [];\n    for (let i = 0; i < nTransactions; ++i) {\n      const tx = readTransaction();\n      block.transactions.push(tx);\n    }\n    const witnessCommit = block.getWitnessCommit();\n    // This Block contains a witness commit\n    if (witnessCommit) block.witnessCommit = witnessCommit;\n    return block;\n  }\n  static fromHex(hex) {\n    return Block.fromBuffer(Buffer.from(hex, 'hex'));\n  }\n  static calculateTarget(bits) {\n    const exponent = ((bits & 0xff000000) >> 24) - 3;\n    const mantissa = bits & 0x007fffff;\n    const target = Buffer.alloc(32, 0);\n    target.writeUIntBE(mantissa, 29 - exponent, 3);\n    return target;\n  }\n  static calculateMerkleRoot(transactions, forWitness) {\n    typeforce([{ getHash: types.Function }], transactions);\n    if (transactions.length === 0) throw errorMerkleNoTxes;\n    if (forWitness && !txesHaveWitnessCommit(transactions))\n      throw errorWitnessNotSegwit;\n    const hashes = transactions.map(transaction =>\n      transaction.getHash(forWitness),\n    );\n    const rootHash = (0, merkle_1.fastMerkleRoot)(hashes, bcrypto.hash256);\n    return forWitness\n      ? bcrypto.hash256(\n          Buffer.concat([rootHash, transactions[0].ins[0].witness[0]]),\n        )\n      : rootHash;\n  }\n  getWitnessCommit() {\n    if (!txesHaveWitnessCommit(this.transactions)) return null;\n    // The merkle root for the witness data is in an OP_RETURN output.\n    // There is no rule for the index of the output, so use filter to find it.\n    // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed\n    // If multiple commits are found, the output with highest index is assumed.\n    const witnessCommits = this.transactions[0].outs\n      .filter(out =>\n        out.script.slice(0, 6).equals(Buffer.from('6a24aa21a9ed', 'hex')),\n      )\n      .map(out => out.script.slice(6, 38));\n    if (witnessCommits.length === 0) return null;\n    // Use the commit with the highest output (should only be one though)\n    const result = witnessCommits[witnessCommits.length - 1];\n    if (!(result instanceof Buffer && result.length === 32)) return null;\n    return result;\n  }\n  hasWitnessCommit() {\n    if (\n      this.witnessCommit instanceof Buffer &&\n      this.witnessCommit.length === 32\n    )\n      return true;\n    if (this.getWitnessCommit() !== null) return true;\n    return false;\n  }\n  hasWitness() {\n    return anyTxHasWitness(this.transactions);\n  }\n  weight() {\n    const base = this.byteLength(false, false);\n    const total = this.byteLength(false, true);\n    return base * 3 + total;\n  }\n  byteLength(headersOnly, allowWitness = true) {\n    if (headersOnly || !this.transactions) return 80;\n    return (\n      80 +\n      bufferutils_1.varuint.encodingLength(this.transactions.length) +\n      this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0)\n    );\n  }\n  getHash() {\n    return bcrypto.hash256(this.toBuffer(true));\n  }\n  getId() {\n    return (0, bufferutils_1.reverseBuffer)(this.getHash()).toString('hex');\n  }\n  getUTCDate() {\n    const date = new Date(0); // epoch\n    date.setUTCSeconds(this.timestamp);\n    return date;\n  }\n  // TODO: buffer, offset compatibility\n  toBuffer(headersOnly) {\n    const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));\n    const bufferWriter = new bufferutils_1.BufferWriter(buffer);\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(this.prevHash);\n    bufferWriter.writeSlice(this.merkleRoot);\n    bufferWriter.writeUInt32(this.timestamp);\n    bufferWriter.writeUInt32(this.bits);\n    bufferWriter.writeUInt32(this.nonce);\n    if (headersOnly || !this.transactions) return buffer;\n    bufferutils_1.varuint.encode(\n      this.transactions.length,\n      buffer,\n      bufferWriter.offset,\n    );\n    bufferWriter.offset += bufferutils_1.varuint.encode.bytes;\n    this.transactions.forEach(tx => {\n      const txSize = tx.byteLength(); // TODO: extract from toBuffer?\n      tx.toBuffer(buffer, bufferWriter.offset);\n      bufferWriter.offset += txSize;\n    });\n    return buffer;\n  }\n  toHex(headersOnly) {\n    return this.toBuffer(headersOnly).toString('hex');\n  }\n  checkTxRoots() {\n    // If the Block has segwit transactions but no witness commit,\n    // there's no way it can be valid, so fail the check.\n    const hasWitnessCommit = this.hasWitnessCommit();\n    if (!hasWitnessCommit && this.hasWitness()) return false;\n    return (\n      this.__checkMerkleRoot() &&\n      (hasWitnessCommit ? this.__checkWitnessCommit() : true)\n    );\n  }\n  checkProofOfWork() {\n    const hash = (0, bufferutils_1.reverseBuffer)(this.getHash());\n    const target = Block.calculateTarget(this.bits);\n    return hash.compare(target) <= 0;\n  }\n  __checkMerkleRoot() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n    return this.merkleRoot.compare(actualMerkleRoot) === 0;\n  }\n  __checkWitnessCommit() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;\n    const actualWitnessCommit = Block.calculateMerkleRoot(\n      this.transactions,\n      true,\n    );\n    return this.witnessCommit.compare(actualWitnessCommit) === 0;\n  }\n}\nexports.Block = Block;\nfunction txesHaveWitnessCommit(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions[0] &&\n    transactions[0].ins &&\n    transactions[0].ins instanceof Array &&\n    transactions[0].ins[0] &&\n    transactions[0].ins[0].witness &&\n    transactions[0].ins[0].witness instanceof Array &&\n    transactions[0].ins[0].witness.length > 0\n  );\n}\nfunction anyTxHasWitness(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions.some(\n      tx =>\n        typeof tx === 'object' &&\n        tx.ins instanceof Array &&\n        tx.ins.some(\n          input =>\n            typeof input === 'object' &&\n            input.witness instanceof Array &&\n            input.witness.length > 0,\n        ),\n    )\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}