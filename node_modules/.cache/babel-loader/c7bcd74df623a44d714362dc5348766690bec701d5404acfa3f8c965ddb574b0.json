{"ast":null,"code":"import { WebConnectorStatusType } from '@terra-dev/web-connector-interface';\nimport bowser from 'bowser';\nimport { BehaviorSubject } from 'rxjs';\nasync function getConnector(hostWindow) {\n  return new Promise(resolve => {\n    let count = 20;\n    function task() {\n      if (--count > 0) {\n        if (typeof hostWindow.terraWebConnectors !== 'undefined' && Array.isArray(hostWindow.terraWebConnectors) && hostWindow.terraWebConnectors.length > 0) {\n          console.log(\"TerraWebConnector: \", JSON.stringify(hostWindow.terraWebConnectors[0].getInfo()));\n          resolve(hostWindow.terraWebConnectors[0]);\n        } else {\n          console.warn(\"Can't find window.terraWebConnectors. wait 500ms...\");\n          setTimeout(task, 500);\n        }\n      } else {\n        resolve(undefined);\n      }\n    }\n    task();\n  });\n}\nexport class WebConnectorController {\n  constructor(hostWindow) {\n    var _this = this;\n    this.hostWindow = hostWindow;\n    this._connector = null;\n    /**\n     * Refetch the clientsStates\n     *\n     * You don't need call this method in most cases.\n     * Normally, when the clientStates is changed, states() get the new clientStates.\n     *\n     * @example\n     * client.states()\n     *       .subscribe(states => {\n     *         // 2. will get new clientStates\n     *         console.log('Got new states', Date.now())\n     *       })\n     *\n     * function callback() {\n     *   // 1. refetch client states\n     *   client.refetchStates()\n     * }\n     */\n    this.refetchStates = () => {\n      var _a;\n      (_a = this._connector) === null || _a === void 0 ? void 0 : _a.refetchStates();\n    };\n    /**\n     * Request approval connection to the Extension. (Connect)\n     */\n    this.requestApproval = () => {\n      var _a;\n      (_a = this._connector) === null || _a === void 0 ? void 0 : _a.requestApproval();\n    };\n    this.status = () => {\n      return this._status.asObservable();\n    };\n    this.getLastStatus = () => {\n      return this._status.getValue();\n    };\n    /**\n     * Execute transaction\n     *\n     * @example\n     * client.post(terraAddress, tx: CreateTxOptions)\n     *       .subscribe({\n     *          next: (result: WebConnectorTxProgress | WebConnectorTxSucceed) => {\n     *            switch (result.status) {\n     *              case WebConnectorTxStatus.PROGRESS:\n     *                console.log('in progress', result.payload)\n     *                break;\n     *              case WebConnectorTxStatus.SUCCEED:\n     *                console.log('succeed', result.payload)\n     *                break;\n     *            }\n     *          },\n     *          error: (error) => {\n     *            if (error instanceof WebConnectorUserDenied) {\n     *              console.log('user denied')\n     *            } else if (error instanceof WebConnectorCreateTxFailed) {\n     *              console.log('create tx failed', error.message)\n     *            } else if (error instanceof WebConnectorTxFailed) {\n     *              console.log('tx failed', error.txhash, error.message, error.raw_message)\n     *            } else {\n     *              console.log('unspecified error', 'message' in error ? error.message : String(error))\n     *            }\n     *          }\n     *       })\n     *\n     * @description The stream will be\n     * TxProgress -> [...TxProgress] -> TxSucceed\n     *\n     * - Tx is Succeed : TxProgress -> [...TxProgress] -> TxSucceed\n     */\n    this.post = (terraAddress, tx) => {\n      return this._connector.post(terraAddress, tx);\n    };\n    this.hasCW20Tokens = function (chainID) {\n      for (var _len = arguments.length, tokenAddrs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        tokenAddrs[_key - 1] = arguments[_key];\n      }\n      return _this._connector.hasCW20Tokens(chainID, ...tokenAddrs);\n    };\n    /**\n     * Add CW20 Token to extension dashboard\n     */\n    this.addCW20Tokens = function (chainID) {\n      for (var _len2 = arguments.length, tokenAddrs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        tokenAddrs[_key2 - 1] = arguments[_key2];\n      }\n      return _this._connector.addCW20Tokens(chainID, ...tokenAddrs);\n    };\n    this.hasNetwork = (chainID, lcd) => {\n      return this._connector.hasNetwork({\n        chainID,\n        lcd\n      });\n    };\n    this.addNetwork = (name, chainID, lcd) => {\n      return this._connector.addNetwork({\n        name: name !== null && name !== void 0 ? name : '',\n        chainID,\n        lcd\n      });\n    };\n    /**\n     * @example\n     * client.states()\n     *       .subscribe(states => {\n     *         if (!states) {\n     *           console.log('client is still not ready')\n     *         } else {\n     *           console.log('current network is', states.network)\n     *           console.log('current wallets are', states.wallets)\n     *         }\n     *       })\n     */\n    this.states = () => {\n      return this._states.asObservable();\n    };\n    this.getLastStates = () => {\n      return this._states.getValue();\n    };\n    /**\n     * Destroy this client\n     *\n     * - Unsubscribe all RxJs Subjects (every Observables are stoped)\n     */\n    this.destroy = () => {\n      var _a;\n      (_a = this._connector) === null || _a === void 0 ? void 0 : _a.close();\n      this._connector = null;\n    };\n    this._status = new BehaviorSubject({\n      type: WebConnectorStatusType.INITIALIZING\n    });\n    this._states = new BehaviorSubject(null);\n    const browser = bowser.getParser(navigator.userAgent);\n    //@ts-ignore\n    getConnector(hostWindow).then(connector => {\n      if (!connector) {\n        const name = browser.getBrowserName(true);\n        let installLink;\n        switch (name) {\n          case 'chrome':\n          case 'microsoft edge':\n            installLink = 'https://google.com/chrome';\n            break;\n          case 'firefox':\n            installLink = 'https://google.com/firefox';\n            break;\n          case 'safari':\n            installLink = 'https://google.com/safari';\n            break;\n          default:\n            installLink = 'https://google.com/chrome';\n            break;\n        }\n        this._status.next({\n          type: WebConnectorStatusType.NO_AVAILABLE,\n          isConnectorExists: false,\n          installLink\n        });\n        return;\n      }\n      if (!connector.checkBrowserAvailability(navigator.userAgent)) {\n        this._status.next({\n          type: WebConnectorStatusType.NO_AVAILABLE,\n          isConnectorExists: true,\n          isSupportBrowser: false\n        });\n        return;\n      }\n      connector.open(hostWindow, this._status, this._states);\n      this._connector = connector;\n    });\n  }\n}","map":{"version":3,"names":["WebConnectorStatusType","bowser","BehaviorSubject","getConnector","hostWindow","Promise","resolve","count","task","terraWebConnectors","Array","isArray","length","console","log","JSON","stringify","getInfo","warn","setTimeout","undefined","WebConnectorController","constructor","_this","_connector","refetchStates","_a","requestApproval","status","_status","asObservable","getLastStatus","getValue","post","terraAddress","tx","hasCW20Tokens","chainID","_len","arguments","tokenAddrs","_key","addCW20Tokens","_len2","_key2","hasNetwork","lcd","addNetwork","name","states","_states","getLastStates","destroy","close","type","INITIALIZING","browser","getParser","navigator","userAgent","then","connector","getBrowserName","installLink","next","NO_AVAILABLE","isConnectorExists","checkBrowserAvailability","isSupportBrowser","open"],"sources":["../../../src/@terra-dev/web-connector-controller/index.ts"],"sourcesContent":["import {\n  TerraWebConnector,\n  WebConnectorStates,\n  WebConnectorStatus,\n  WebConnectorStatusType,\n  WebConnectorTxResult,\n} from '@terra-dev/web-connector-interface';\nimport { CreateTxOptions } from '@terra-money/terra.js';\nimport bowser from 'bowser';\nimport { BehaviorSubject, Observable } from 'rxjs';\n\nasync function getConnector(hostWindow: {\n  terraWebConnectors: TerraWebConnector[] | undefined;\n}): Promise<TerraWebConnector | undefined> {\n  return new Promise((resolve) => {\n    let count = 20;\n\n    function task() {\n      if (--count > 0) {\n        if (\n          typeof hostWindow.terraWebConnectors !== 'undefined' &&\n          Array.isArray(hostWindow.terraWebConnectors) &&\n          hostWindow.terraWebConnectors.length > 0\n        ) {\n          console.log(\n            `TerraWebConnector: `,\n            JSON.stringify(hostWindow.terraWebConnectors[0].getInfo()),\n          );\n          resolve(hostWindow.terraWebConnectors[0]);\n        } else {\n          console.warn(`Can't find window.terraWebConnectors. wait 500ms...`);\n          setTimeout(task, 500);\n        }\n      } else {\n        resolve(undefined);\n      }\n    }\n\n    task();\n  });\n}\n\nexport class WebConnectorController {\n  private readonly _status: BehaviorSubject<WebConnectorStatus>;\n  private readonly _states: BehaviorSubject<WebConnectorStates | null>;\n  private _connector: TerraWebConnector | null = null;\n\n  constructor(private hostWindow: Window) {\n    this._status = new BehaviorSubject<WebConnectorStatus>({\n      type: WebConnectorStatusType.INITIALIZING,\n    });\n\n    this._states = new BehaviorSubject<WebConnectorStates | null>(null);\n\n    const browser = bowser.getParser(navigator.userAgent);\n\n    //@ts-ignore\n    getConnector(hostWindow).then((connector) => {\n      if (!connector) {\n        const name = browser.getBrowserName(true);\n\n        let installLink: string;\n\n        switch (name) {\n          case 'chrome':\n          case 'microsoft edge':\n            installLink = 'https://google.com/chrome';\n            break;\n          case 'firefox':\n            installLink = 'https://google.com/firefox';\n            break;\n          case 'safari':\n            installLink = 'https://google.com/safari';\n            break;\n          default:\n            installLink = 'https://google.com/chrome';\n            break;\n        }\n\n        this._status.next({\n          type: WebConnectorStatusType.NO_AVAILABLE,\n          isConnectorExists: false,\n          installLink,\n        });\n\n        return;\n      }\n\n      if (!connector.checkBrowserAvailability(navigator.userAgent)) {\n        this._status.next({\n          type: WebConnectorStatusType.NO_AVAILABLE,\n          isConnectorExists: true,\n          isSupportBrowser: false,\n        });\n\n        return;\n      }\n\n      connector.open(hostWindow, this._status, this._states);\n\n      this._connector = connector;\n    });\n  }\n\n  /**\n   * Refetch the clientsStates\n   *\n   * You don't need call this method in most cases.\n   * Normally, when the clientStates is changed, states() get the new clientStates.\n   *\n   * @example\n   * client.states()\n   *       .subscribe(states => {\n   *         // 2. will get new clientStates\n   *         console.log('Got new states', Date.now())\n   *       })\n   *\n   * function callback() {\n   *   // 1. refetch client states\n   *   client.refetchStates()\n   * }\n   */\n  refetchStates = () => {\n    this._connector?.refetchStates();\n  };\n\n  /**\n   * Request approval connection to the Extension. (Connect)\n   */\n  requestApproval = () => {\n    this._connector?.requestApproval();\n  };\n\n  status = () => {\n    return this._status.asObservable();\n  };\n\n  getLastStatus = () => {\n    return this._status.getValue();\n  };\n\n  /**\n   * Execute transaction\n   *\n   * @example\n   * client.post(terraAddress, tx: CreateTxOptions)\n   *       .subscribe({\n   *          next: (result: WebConnectorTxProgress | WebConnectorTxSucceed) => {\n   *            switch (result.status) {\n   *              case WebConnectorTxStatus.PROGRESS:\n   *                console.log('in progress', result.payload)\n   *                break;\n   *              case WebConnectorTxStatus.SUCCEED:\n   *                console.log('succeed', result.payload)\n   *                break;\n   *            }\n   *          },\n   *          error: (error) => {\n   *            if (error instanceof WebConnectorUserDenied) {\n   *              console.log('user denied')\n   *            } else if (error instanceof WebConnectorCreateTxFailed) {\n   *              console.log('create tx failed', error.message)\n   *            } else if (error instanceof WebConnectorTxFailed) {\n   *              console.log('tx failed', error.txhash, error.message, error.raw_message)\n   *            } else {\n   *              console.log('unspecified error', 'message' in error ? error.message : String(error))\n   *            }\n   *          }\n   *       })\n   *\n   * @description The stream will be\n   * TxProgress -> [...TxProgress] -> TxSucceed\n   *\n   * - Tx is Succeed : TxProgress -> [...TxProgress] -> TxSucceed\n   */\n  post = (\n    terraAddress: string,\n    tx: CreateTxOptions,\n  ): Observable<WebConnectorTxResult> => {\n    return this._connector!.post(terraAddress, tx);\n  };\n\n  hasCW20Tokens = (chainID: string, ...tokenAddrs: string[]) => {\n    return this._connector!.hasCW20Tokens(chainID, ...tokenAddrs);\n  };\n\n  /**\n   * Add CW20 Token to extension dashboard\n   */\n  addCW20Tokens = (chainID: string, ...tokenAddrs: string[]) => {\n    return this._connector!.addCW20Tokens(chainID, ...tokenAddrs);\n  };\n\n  hasNetwork = (chainID: string, lcd: string) => {\n    return this._connector!.hasNetwork({\n      chainID,\n      lcd,\n    });\n  };\n\n  addNetwork = (name: string | undefined, chainID: string, lcd: string) => {\n    return this._connector!.addNetwork({\n      name: name ?? '',\n      chainID,\n      lcd,\n    });\n  };\n\n  /**\n   * @example\n   * client.states()\n   *       .subscribe(states => {\n   *         if (!states) {\n   *           console.log('client is still not ready')\n   *         } else {\n   *           console.log('current network is', states.network)\n   *           console.log('current wallets are', states.wallets)\n   *         }\n   *       })\n   */\n  states = () => {\n    return this._states.asObservable();\n  };\n\n  getLastStates = () => {\n    return this._states.getValue();\n  };\n\n  /**\n   * Destroy this client\n   *\n   * - Unsubscribe all RxJs Subjects (every Observables are stoped)\n   */\n  destroy = () => {\n    this._connector?.close();\n    this._connector = null;\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}