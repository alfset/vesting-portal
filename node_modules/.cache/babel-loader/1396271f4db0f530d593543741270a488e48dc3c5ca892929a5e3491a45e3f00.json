{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.toOutputScript = exports.fromOutputScript = exports.toBech32 = exports.toBase58Check = exports.fromBech32 = exports.fromBase58Check = void 0;\nconst networks = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst types_1 = require('./types');\nconst bech32_1 = require('bech32');\nconst bs58check = require('bs58check');\nconst FUTURE_SEGWIT_MAX_SIZE = 40;\nconst FUTURE_SEGWIT_MIN_SIZE = 2;\nconst FUTURE_SEGWIT_MAX_VERSION = 16;\nconst FUTURE_SEGWIT_MIN_VERSION = 2;\nconst FUTURE_SEGWIT_VERSION_DIFF = 0x50;\nconst FUTURE_SEGWIT_VERSION_WARNING = 'WARNING: Sending to a future segwit version address can lead to loss of funds. ' + 'End users MUST be warned carefully in the GUI and asked if they wish to proceed ' + 'with caution. Wallets should verify the segwit version from the output of fromBech32, ' + 'then decide when it is safe to use which version of segwit.';\nfunction _toFutureSegwitAddress(output, network) {\n  const data = output.slice(2);\n  if (data.length < FUTURE_SEGWIT_MIN_SIZE || data.length > FUTURE_SEGWIT_MAX_SIZE) throw new TypeError('Invalid program length for segwit address');\n  const version = output[0] - FUTURE_SEGWIT_VERSION_DIFF;\n  if (version < FUTURE_SEGWIT_MIN_VERSION || version > FUTURE_SEGWIT_MAX_VERSION) throw new TypeError('Invalid version for segwit address');\n  if (output[1] !== data.length) throw new TypeError('Invalid script for segwit address');\n  console.warn(FUTURE_SEGWIT_VERSION_WARNING);\n  return toBech32(data, version, network.bech32);\n}\nfunction fromBase58Check(address) {\n  const payload = Buffer.from(bs58check.decode(address));\n  // TODO: 4.0.0, move to \"toOutputScript\"\n  if (payload.length < 21) throw new TypeError(address + ' is too short');\n  if (payload.length > 21) throw new TypeError(address + ' is too long');\n  const version = payload.readUInt8(0);\n  const hash = payload.slice(1);\n  return {\n    version,\n    hash\n  };\n}\nexports.fromBase58Check = fromBase58Check;\nfunction fromBech32(address) {\n  let result;\n  let version;\n  try {\n    result = bech32_1.bech32.decode(address);\n  } catch (e) {}\n  if (result) {\n    version = result.words[0];\n    if (version !== 0) throw new TypeError(address + ' uses wrong encoding');\n  } else {\n    result = bech32_1.bech32m.decode(address);\n    version = result.words[0];\n    if (version === 0) throw new TypeError(address + ' uses wrong encoding');\n  }\n  const data = bech32_1.bech32.fromWords(result.words.slice(1));\n  return {\n    version,\n    prefix: result.prefix,\n    data: Buffer.from(data)\n  };\n}\nexports.fromBech32 = fromBech32;\nfunction toBase58Check(hash, version) {\n  (0, types_1.typeforce)((0, types_1.tuple)(types_1.Hash160bit, types_1.UInt8), arguments);\n  const payload = Buffer.allocUnsafe(21);\n  payload.writeUInt8(version, 0);\n  hash.copy(payload, 1);\n  return bs58check.encode(payload);\n}\nexports.toBase58Check = toBase58Check;\nfunction toBech32(data, version, prefix) {\n  const words = bech32_1.bech32.toWords(data);\n  words.unshift(version);\n  return version === 0 ? bech32_1.bech32.encode(prefix, words) : bech32_1.bech32m.encode(prefix, words);\n}\nexports.toBech32 = toBech32;\nfunction fromOutputScript(output, network) {\n  // TODO: Network\n  network = network || networks.bitcoin;\n  try {\n    return payments.p2pkh({\n      output,\n      network\n    }).address;\n  } catch (e) {}\n  try {\n    return payments.p2sh({\n      output,\n      network\n    }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wpkh({\n      output,\n      network\n    }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wsh({\n      output,\n      network\n    }).address;\n  } catch (e) {}\n  try {\n    return payments.p2tr({\n      output,\n      network\n    }).address;\n  } catch (e) {}\n  try {\n    return _toFutureSegwitAddress(output, network);\n  } catch (e) {}\n  throw new Error(bscript.toASM(output) + ' has no matching Address');\n}\nexports.fromOutputScript = fromOutputScript;\nfunction toOutputScript(address, network) {\n  network = network || networks.bitcoin;\n  let decodeBase58;\n  let decodeBech32;\n  try {\n    decodeBase58 = fromBase58Check(address);\n  } catch (e) {}\n  if (decodeBase58) {\n    if (decodeBase58.version === network.pubKeyHash) return payments.p2pkh({\n      hash: decodeBase58.hash\n    }).output;\n    if (decodeBase58.version === network.scriptHash) return payments.p2sh({\n      hash: decodeBase58.hash\n    }).output;\n  } else {\n    try {\n      decodeBech32 = fromBech32(address);\n    } catch (e) {}\n    if (decodeBech32) {\n      if (decodeBech32.prefix !== network.bech32) throw new Error(address + ' has an invalid prefix');\n      if (decodeBech32.version === 0) {\n        if (decodeBech32.data.length === 20) return payments.p2wpkh({\n          hash: decodeBech32.data\n        }).output;\n        if (decodeBech32.data.length === 32) return payments.p2wsh({\n          hash: decodeBech32.data\n        }).output;\n      } else if (decodeBech32.version === 1) {\n        if (decodeBech32.data.length === 32) return payments.p2tr({\n          pubkey: decodeBech32.data\n        }).output;\n      } else if (decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION && decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION && decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE && decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE) {\n        console.warn(FUTURE_SEGWIT_VERSION_WARNING);\n        return bscript.compile([decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF, decodeBech32.data]);\n      }\n    }\n  }\n  throw new Error(address + ' has no matching Script');\n}\nexports.toOutputScript = toOutputScript;","map":{"version":3,"names":["Object","defineProperty","exports","value","toOutputScript","fromOutputScript","toBech32","toBase58Check","fromBech32","fromBase58Check","networks","require","payments","bscript","types_1","bech32_1","bs58check","FUTURE_SEGWIT_MAX_SIZE","FUTURE_SEGWIT_MIN_SIZE","FUTURE_SEGWIT_MAX_VERSION","FUTURE_SEGWIT_MIN_VERSION","FUTURE_SEGWIT_VERSION_DIFF","FUTURE_SEGWIT_VERSION_WARNING","_toFutureSegwitAddress","output","network","data","slice","length","TypeError","version","console","warn","bech32","address","payload","Buffer","from","decode","readUInt8","hash","result","e","words","bech32m","fromWords","prefix","typeforce","tuple","Hash160bit","UInt8","arguments","allocUnsafe","writeUInt8","copy","encode","toWords","unshift","bitcoin","p2pkh","p2sh","p2wpkh","p2wsh","p2tr","Error","toASM","decodeBase58","decodeBech32","pubKeyHash","scriptHash","pubkey","compile"],"sources":["/workspace/Planq-Dapps/vesting-portal/node_modules/bitcoinjs-lib/src/address.js"],"sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.toOutputScript =\n  exports.fromOutputScript =\n  exports.toBech32 =\n  exports.toBase58Check =\n  exports.fromBech32 =\n  exports.fromBase58Check =\n    void 0;\nconst networks = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst types_1 = require('./types');\nconst bech32_1 = require('bech32');\nconst bs58check = require('bs58check');\nconst FUTURE_SEGWIT_MAX_SIZE = 40;\nconst FUTURE_SEGWIT_MIN_SIZE = 2;\nconst FUTURE_SEGWIT_MAX_VERSION = 16;\nconst FUTURE_SEGWIT_MIN_VERSION = 2;\nconst FUTURE_SEGWIT_VERSION_DIFF = 0x50;\nconst FUTURE_SEGWIT_VERSION_WARNING =\n  'WARNING: Sending to a future segwit version address can lead to loss of funds. ' +\n  'End users MUST be warned carefully in the GUI and asked if they wish to proceed ' +\n  'with caution. Wallets should verify the segwit version from the output of fromBech32, ' +\n  'then decide when it is safe to use which version of segwit.';\nfunction _toFutureSegwitAddress(output, network) {\n  const data = output.slice(2);\n  if (\n    data.length < FUTURE_SEGWIT_MIN_SIZE ||\n    data.length > FUTURE_SEGWIT_MAX_SIZE\n  )\n    throw new TypeError('Invalid program length for segwit address');\n  const version = output[0] - FUTURE_SEGWIT_VERSION_DIFF;\n  if (\n    version < FUTURE_SEGWIT_MIN_VERSION ||\n    version > FUTURE_SEGWIT_MAX_VERSION\n  )\n    throw new TypeError('Invalid version for segwit address');\n  if (output[1] !== data.length)\n    throw new TypeError('Invalid script for segwit address');\n  console.warn(FUTURE_SEGWIT_VERSION_WARNING);\n  return toBech32(data, version, network.bech32);\n}\nfunction fromBase58Check(address) {\n  const payload = Buffer.from(bs58check.decode(address));\n  // TODO: 4.0.0, move to \"toOutputScript\"\n  if (payload.length < 21) throw new TypeError(address + ' is too short');\n  if (payload.length > 21) throw new TypeError(address + ' is too long');\n  const version = payload.readUInt8(0);\n  const hash = payload.slice(1);\n  return { version, hash };\n}\nexports.fromBase58Check = fromBase58Check;\nfunction fromBech32(address) {\n  let result;\n  let version;\n  try {\n    result = bech32_1.bech32.decode(address);\n  } catch (e) {}\n  if (result) {\n    version = result.words[0];\n    if (version !== 0) throw new TypeError(address + ' uses wrong encoding');\n  } else {\n    result = bech32_1.bech32m.decode(address);\n    version = result.words[0];\n    if (version === 0) throw new TypeError(address + ' uses wrong encoding');\n  }\n  const data = bech32_1.bech32.fromWords(result.words.slice(1));\n  return {\n    version,\n    prefix: result.prefix,\n    data: Buffer.from(data),\n  };\n}\nexports.fromBech32 = fromBech32;\nfunction toBase58Check(hash, version) {\n  (0, types_1.typeforce)(\n    (0, types_1.tuple)(types_1.Hash160bit, types_1.UInt8),\n    arguments,\n  );\n  const payload = Buffer.allocUnsafe(21);\n  payload.writeUInt8(version, 0);\n  hash.copy(payload, 1);\n  return bs58check.encode(payload);\n}\nexports.toBase58Check = toBase58Check;\nfunction toBech32(data, version, prefix) {\n  const words = bech32_1.bech32.toWords(data);\n  words.unshift(version);\n  return version === 0\n    ? bech32_1.bech32.encode(prefix, words)\n    : bech32_1.bech32m.encode(prefix, words);\n}\nexports.toBech32 = toBech32;\nfunction fromOutputScript(output, network) {\n  // TODO: Network\n  network = network || networks.bitcoin;\n  try {\n    return payments.p2pkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2sh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wpkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wsh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2tr({ output, network }).address;\n  } catch (e) {}\n  try {\n    return _toFutureSegwitAddress(output, network);\n  } catch (e) {}\n  throw new Error(bscript.toASM(output) + ' has no matching Address');\n}\nexports.fromOutputScript = fromOutputScript;\nfunction toOutputScript(address, network) {\n  network = network || networks.bitcoin;\n  let decodeBase58;\n  let decodeBech32;\n  try {\n    decodeBase58 = fromBase58Check(address);\n  } catch (e) {}\n  if (decodeBase58) {\n    if (decodeBase58.version === network.pubKeyHash)\n      return payments.p2pkh({ hash: decodeBase58.hash }).output;\n    if (decodeBase58.version === network.scriptHash)\n      return payments.p2sh({ hash: decodeBase58.hash }).output;\n  } else {\n    try {\n      decodeBech32 = fromBech32(address);\n    } catch (e) {}\n    if (decodeBech32) {\n      if (decodeBech32.prefix !== network.bech32)\n        throw new Error(address + ' has an invalid prefix');\n      if (decodeBech32.version === 0) {\n        if (decodeBech32.data.length === 20)\n          return payments.p2wpkh({ hash: decodeBech32.data }).output;\n        if (decodeBech32.data.length === 32)\n          return payments.p2wsh({ hash: decodeBech32.data }).output;\n      } else if (decodeBech32.version === 1) {\n        if (decodeBech32.data.length === 32)\n          return payments.p2tr({ pubkey: decodeBech32.data }).output;\n      } else if (\n        decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION &&\n        decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION &&\n        decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE &&\n        decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE\n      ) {\n        console.warn(FUTURE_SEGWIT_VERSION_WARNING);\n        return bscript.compile([\n          decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF,\n          decodeBech32.data,\n        ]);\n      }\n    }\n  }\n  throw new Error(address + ' has no matching Script');\n}\nexports.toOutputScript = toOutputScript;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}