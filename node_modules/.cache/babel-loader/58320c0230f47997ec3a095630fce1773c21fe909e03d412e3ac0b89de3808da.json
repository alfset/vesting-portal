{"ast":null,"code":"\"use strict\";\n\nfunction compile(nodes) {\n  var assignedPaths = [];\n  var valueAssignments = [];\n  var currentPath = \"\";\n  var data = {};\n  var context = data;\n  var arrayMode = false;\n  return reduce(nodes);\n  function reduce(nodes) {\n    var node;\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      switch (node.type) {\n        case \"Assign\":\n          assign(node);\n          break;\n        case \"ObjectPath\":\n          setPath(node);\n          break;\n        case \"ArrayPath\":\n          addTableArray(node);\n          break;\n      }\n    }\n    return data;\n  }\n  function genError(err, line, col) {\n    var ex = new Error(err);\n    ex.line = line;\n    ex.column = col;\n    throw ex;\n  }\n  function assign(node) {\n    var key = node.key;\n    var value = node.value;\n    var line = node.line;\n    var column = node.column;\n    var fullPath;\n    if (currentPath) {\n      fullPath = currentPath + \".\" + key;\n    } else {\n      fullPath = key;\n    }\n    if (typeof context[key] !== \"undefined\") {\n      genError(\"Cannot redefine existing key '\" + fullPath + \"'.\", line, column);\n    }\n    context[key] = reduceValueNode(value);\n    if (!pathAssigned(fullPath)) {\n      assignedPaths.push(fullPath);\n      valueAssignments.push(fullPath);\n    }\n  }\n  function pathAssigned(path) {\n    return assignedPaths.indexOf(path) !== -1;\n  }\n  function reduceValueNode(node) {\n    if (node.type === \"Array\") {\n      return reduceArrayWithTypeChecking(node.value);\n    } else if (node.type === \"InlineTable\") {\n      return reduceInlineTableNode(node.value);\n    } else {\n      return node.value;\n    }\n  }\n  function reduceInlineTableNode(values) {\n    var obj = {};\n    for (var i = 0; i < values.length; i++) {\n      var val = values[i];\n      if (val.value.type === \"InlineTable\") {\n        obj[val.key] = reduceInlineTableNode(val.value.value);\n      } else if (val.type === \"InlineTableValue\") {\n        obj[val.key] = reduceValueNode(val.value);\n      }\n    }\n    return obj;\n  }\n  function setPath(node) {\n    var path = node.value;\n    var quotedPath = path.map(quoteDottedString).join(\".\");\n    var line = node.line;\n    var column = node.column;\n    if (pathAssigned(quotedPath)) {\n      genError(\"Cannot redefine existing key '\" + path + \"'.\", line, column);\n    }\n    assignedPaths.push(quotedPath);\n    context = deepRef(data, path, {}, line, column);\n    currentPath = path;\n  }\n  function addTableArray(node) {\n    var path = node.value;\n    var quotedPath = path.map(quoteDottedString).join(\".\");\n    var line = node.line;\n    var column = node.column;\n    if (!pathAssigned(quotedPath)) {\n      assignedPaths.push(quotedPath);\n    }\n    assignedPaths = assignedPaths.filter(function (p) {\n      return p.indexOf(quotedPath) !== 0;\n    });\n    assignedPaths.push(quotedPath);\n    context = deepRef(data, path, [], line, column);\n    currentPath = quotedPath;\n    if (context instanceof Array) {\n      var newObj = {};\n      context.push(newObj);\n      context = newObj;\n    } else {\n      genError(\"Cannot redefine existing key '\" + path + \"'.\", line, column);\n    }\n  }\n\n  // Given a path 'a.b.c', create (as necessary) `start.a`,\n  // `start.a.b`, and `start.a.b.c`, assigning `value` to `start.a.b.c`.\n  // If `a` or `b` are arrays and have items in them, the last item in the\n  // array is used as the context for the next sub-path.\n  function deepRef(start, keys, value, line, column) {\n    var traversed = [];\n    var traversedPath = \"\";\n    var path = keys.join(\".\");\n    var ctx = start;\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      traversed.push(key);\n      traversedPath = traversed.join(\".\");\n      if (typeof ctx[key] === \"undefined\") {\n        if (i === keys.length - 1) {\n          ctx[key] = value;\n        } else {\n          ctx[key] = {};\n        }\n      } else if (i !== keys.length - 1 && valueAssignments.indexOf(traversedPath) > -1) {\n        // already a non-object value at key, can't be used as part of a new path\n        genError(\"Cannot redefine existing key '\" + traversedPath + \"'.\", line, column);\n      }\n      ctx = ctx[key];\n      if (ctx instanceof Array && ctx.length && i < keys.length - 1) {\n        ctx = ctx[ctx.length - 1];\n      }\n    }\n    return ctx;\n  }\n  function reduceArrayWithTypeChecking(array) {\n    // Ensure that all items in the array are of the same type\n    var firstType = null;\n    for (var i = 0; i < array.length; i++) {\n      var node = array[i];\n      if (firstType === null) {\n        firstType = node.type;\n      } else {\n        if (node.type !== firstType) {\n          genError(\"Cannot add value of type \" + node.type + \" to array of type \" + firstType + \".\", node.line, node.column);\n        }\n      }\n    }\n\n    // Recursively reduce array of nodes into array of the nodes' values\n    return array.map(reduceValueNode);\n  }\n  function quoteDottedString(str) {\n    if (str.indexOf(\".\") > -1) {\n      return \"\\\"\" + str + \"\\\"\";\n    } else {\n      return str;\n    }\n  }\n}\nmodule.exports = {\n  compile: compile\n};","map":{"version":3,"names":["compile","nodes","assignedPaths","valueAssignments","currentPath","data","context","arrayMode","reduce","node","i","length","type","assign","setPath","addTableArray","genError","err","line","col","ex","Error","column","key","value","fullPath","reduceValueNode","pathAssigned","push","path","indexOf","reduceArrayWithTypeChecking","reduceInlineTableNode","values","obj","val","quotedPath","map","quoteDottedString","join","deepRef","filter","p","Array","newObj","start","keys","traversed","traversedPath","ctx","array","firstType","str","module","exports"],"sources":["/workspace/Planq-Dapps/vesting-portal/node_modules/toml/lib/compiler.js"],"sourcesContent":["\"use strict\";\nfunction compile(nodes) {\n  var assignedPaths = [];\n  var valueAssignments = [];\n  var currentPath = \"\";\n  var data = {};\n  var context = data;\n  var arrayMode = false;\n\n  return reduce(nodes);\n\n  function reduce(nodes) {\n    var node;\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      switch (node.type) {\n      case \"Assign\":\n        assign(node);\n        break;\n      case \"ObjectPath\":\n        setPath(node);\n        break;\n      case \"ArrayPath\":\n        addTableArray(node);\n        break;\n      }\n    }\n\n    return data;\n  }\n\n  function genError(err, line, col) {\n    var ex = new Error(err);\n    ex.line = line;\n    ex.column = col;\n    throw ex;\n  }\n\n  function assign(node) {\n    var key = node.key;\n    var value = node.value;\n    var line = node.line;\n    var column = node.column;\n\n    var fullPath;\n    if (currentPath) {\n      fullPath = currentPath + \".\" + key;\n    } else {\n      fullPath = key;\n    }\n    if (typeof context[key] !== \"undefined\") {\n      genError(\"Cannot redefine existing key '\" + fullPath + \"'.\", line, column);\n    }\n\n    context[key] = reduceValueNode(value);\n\n    if (!pathAssigned(fullPath)) {\n      assignedPaths.push(fullPath);\n      valueAssignments.push(fullPath);\n    }\n  }\n\n\n  function pathAssigned(path) {\n    return assignedPaths.indexOf(path) !== -1;\n  }\n\n  function reduceValueNode(node) {\n    if (node.type === \"Array\") {\n      return reduceArrayWithTypeChecking(node.value);\n    } else if (node.type === \"InlineTable\") {\n      return reduceInlineTableNode(node.value);\n    } else {\n      return node.value;\n    }\n  }\n\n  function reduceInlineTableNode(values) {\n    var obj = {};\n    for (var i = 0; i < values.length; i++) {\n      var val = values[i];\n      if (val.value.type === \"InlineTable\") {\n        obj[val.key] = reduceInlineTableNode(val.value.value);\n      } else if (val.type === \"InlineTableValue\") {\n        obj[val.key] = reduceValueNode(val.value);\n      }\n    }\n\n    return obj;\n  }\n\n  function setPath(node) {\n    var path = node.value;\n    var quotedPath = path.map(quoteDottedString).join(\".\");\n    var line = node.line;\n    var column = node.column;\n\n    if (pathAssigned(quotedPath)) {\n      genError(\"Cannot redefine existing key '\" + path + \"'.\", line, column);\n    }\n    assignedPaths.push(quotedPath);\n    context = deepRef(data, path, {}, line, column);\n    currentPath = path;\n  }\n\n  function addTableArray(node) {\n    var path = node.value;\n    var quotedPath = path.map(quoteDottedString).join(\".\");\n    var line = node.line;\n    var column = node.column;\n\n    if (!pathAssigned(quotedPath)) {\n      assignedPaths.push(quotedPath);\n    }\n    assignedPaths = assignedPaths.filter(function(p) {\n      return p.indexOf(quotedPath) !== 0;\n    });\n    assignedPaths.push(quotedPath);\n    context = deepRef(data, path, [], line, column);\n    currentPath = quotedPath;\n\n    if (context instanceof Array) {\n      var newObj = {};\n      context.push(newObj);\n      context = newObj;\n    } else {\n      genError(\"Cannot redefine existing key '\" + path + \"'.\", line, column);\n    }\n  }\n\n  // Given a path 'a.b.c', create (as necessary) `start.a`,\n  // `start.a.b`, and `start.a.b.c`, assigning `value` to `start.a.b.c`.\n  // If `a` or `b` are arrays and have items in them, the last item in the\n  // array is used as the context for the next sub-path.\n  function deepRef(start, keys, value, line, column) {\n    var traversed = [];\n    var traversedPath = \"\";\n    var path = keys.join(\".\");\n    var ctx = start;\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      traversed.push(key);\n      traversedPath = traversed.join(\".\");\n      if (typeof ctx[key] === \"undefined\") {\n        if (i === keys.length - 1) {\n          ctx[key] = value;\n        } else {\n          ctx[key] = {};\n        }\n      } else if (i !== keys.length - 1 && valueAssignments.indexOf(traversedPath) > -1) {\n        // already a non-object value at key, can't be used as part of a new path\n        genError(\"Cannot redefine existing key '\" + traversedPath + \"'.\", line, column);\n      }\n\n      ctx = ctx[key];\n      if (ctx instanceof Array && ctx.length && i < keys.length - 1) {\n        ctx = ctx[ctx.length - 1];\n      }\n    }\n\n    return ctx;\n  }\n\n  function reduceArrayWithTypeChecking(array) {\n    // Ensure that all items in the array are of the same type\n    var firstType = null;\n    for (var i = 0; i < array.length; i++) {\n      var node = array[i];\n      if (firstType === null) {\n        firstType = node.type;\n      } else {\n        if (node.type !== firstType) {\n          genError(\"Cannot add value of type \" + node.type + \" to array of type \" +\n            firstType + \".\", node.line, node.column);\n        }\n      }\n    }\n\n    // Recursively reduce array of nodes into array of the nodes' values\n    return array.map(reduceValueNode);\n  }\n\n  function quoteDottedString(str) {\n    if (str.indexOf(\".\") > -1) {\n      return \"\\\"\" + str + \"\\\"\";\n    } else {\n      return str;\n    }\n  }\n}\n\nmodule.exports = {\n  compile: compile\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}