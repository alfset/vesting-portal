{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nconst range = n => [...Array(n).keys()];\nconst isValidDERKey = pubkey => pubkey.length === 33 && [2, 3].includes(pubkey[0]) || pubkey.length === 65 && 4 === pubkey[0];\nfunction makeConverter(TYPE_BYTE) {\n  let isValidPubkey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : isValidDERKey;\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error('Decode Error: could not decode bip32Derivation with key 0x' + keyVal.key.toString('hex'));\n    }\n    const pubkey = keyVal.key.slice(1);\n    if (!isValidPubkey(pubkey)) {\n      throw new Error('Decode Error: bip32Derivation has invalid pubkey in key 0x' + keyVal.key.toString('hex'));\n    }\n    if (keyVal.value.length / 4 % 1 !== 0) {\n      throw new Error('Decode Error: Input BIP32_DERIVATION value length should be multiple of 4');\n    }\n    const data = {\n      masterFingerprint: keyVal.value.slice(0, 4),\n      pubkey,\n      path: 'm'\n    };\n    for (const i of range(keyVal.value.length / 4 - 1)) {\n      const val = keyVal.value.readUInt32LE(i * 4 + 4);\n      const isHard = !!(val & 0x80000000);\n      const idx = val & 0x7fffffff;\n      data.path += '/' + idx.toString(10) + (isHard ? \"'\" : '');\n    }\n    return data;\n  }\n  function encode(data) {\n    const head = Buffer.from([TYPE_BYTE]);\n    const key = Buffer.concat([head, data.pubkey]);\n    const splitPath = data.path.split('/');\n    const value = Buffer.allocUnsafe(splitPath.length * 4);\n    data.masterFingerprint.copy(value, 0);\n    let offset = 4;\n    splitPath.slice(1).forEach(level => {\n      const isHard = level.slice(-1) === \"'\";\n      let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);\n      if (isHard) num += 0x80000000;\n      value.writeUInt32LE(num, offset);\n      offset += 4;\n    });\n    return {\n      key,\n      value\n    };\n  }\n  const expected = '{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }';\n  function check(data) {\n    return Buffer.isBuffer(data.pubkey) && Buffer.isBuffer(data.masterFingerprint) && typeof data.path === 'string' && isValidPubkey(data.pubkey) && data.masterFingerprint.length === 4;\n  }\n  function canAddToArray(array, item, dupeSet) {\n    const dupeString = item.pubkey.toString('hex');\n    if (dupeSet.has(dupeString)) return false;\n    dupeSet.add(dupeString);\n    return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAddToArray\n  };\n}\nexports.makeConverter = makeConverter;","map":{"version":3,"names":["Object","defineProperty","exports","value","range","n","Array","keys","isValidDERKey","pubkey","length","includes","makeConverter","TYPE_BYTE","isValidPubkey","arguments","undefined","decode","keyVal","key","Error","toString","slice","data","masterFingerprint","path","i","val","readUInt32LE","isHard","idx","encode","head","Buffer","from","concat","splitPath","split","allocUnsafe","copy","offset","forEach","level","num","parseInt","writeUInt32LE","expected","check","isBuffer","canAddToArray","array","item","dupeSet","dupeString","has","add","filter","v","equals"],"sources":["/workspace/Planq-Dapps/vesting-portal/node_modules/bip174/src/lib/converter/shared/bip32Derivation.js"],"sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst range = n => [...Array(n).keys()];\nconst isValidDERKey = pubkey =>\n  (pubkey.length === 33 && [2, 3].includes(pubkey[0])) ||\n  (pubkey.length === 65 && 4 === pubkey[0]);\nfunction makeConverter(TYPE_BYTE, isValidPubkey = isValidDERKey) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error(\n        'Decode Error: could not decode bip32Derivation with key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    const pubkey = keyVal.key.slice(1);\n    if (!isValidPubkey(pubkey)) {\n      throw new Error(\n        'Decode Error: bip32Derivation has invalid pubkey in key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    if ((keyVal.value.length / 4) % 1 !== 0) {\n      throw new Error(\n        'Decode Error: Input BIP32_DERIVATION value length should be multiple of 4',\n      );\n    }\n    const data = {\n      masterFingerprint: keyVal.value.slice(0, 4),\n      pubkey,\n      path: 'm',\n    };\n    for (const i of range(keyVal.value.length / 4 - 1)) {\n      const val = keyVal.value.readUInt32LE(i * 4 + 4);\n      const isHard = !!(val & 0x80000000);\n      const idx = val & 0x7fffffff;\n      data.path += '/' + idx.toString(10) + (isHard ? \"'\" : '');\n    }\n    return data;\n  }\n  function encode(data) {\n    const head = Buffer.from([TYPE_BYTE]);\n    const key = Buffer.concat([head, data.pubkey]);\n    const splitPath = data.path.split('/');\n    const value = Buffer.allocUnsafe(splitPath.length * 4);\n    data.masterFingerprint.copy(value, 0);\n    let offset = 4;\n    splitPath.slice(1).forEach(level => {\n      const isHard = level.slice(-1) === \"'\";\n      let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);\n      if (isHard) num += 0x80000000;\n      value.writeUInt32LE(num, offset);\n      offset += 4;\n    });\n    return {\n      key,\n      value,\n    };\n  }\n  const expected =\n    '{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }';\n  function check(data) {\n    return (\n      Buffer.isBuffer(data.pubkey) &&\n      Buffer.isBuffer(data.masterFingerprint) &&\n      typeof data.path === 'string' &&\n      isValidPubkey(data.pubkey) &&\n      data.masterFingerprint.length === 4\n    );\n  }\n  function canAddToArray(array, item, dupeSet) {\n    const dupeString = item.pubkey.toString('hex');\n    if (dupeSet.has(dupeString)) return false;\n    dupeSet.add(dupeString);\n    return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAddToArray,\n  };\n}\nexports.makeConverter = makeConverter;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}