{"ast":null,"code":"import { log } from '@onflow/util-logger';\n\n/**\n * Creates a type descriptor for a given type\n * @param label - The label for the type\n * @param asArgument - A function that converts the type to a JsonCdcType\n * @param asInjection - A function which returns the argument as is\n * @returns A type descriptor\n * @internal\n */\nconst typedef = (label, asArgument, asInjection) => ({\n  label,\n  asArgument,\n  asInjection: x => {\n    log.deprecate({\n      pkg: \"@onflow/types\",\n      subject: \"Passing in \".concat(label, \" as value for \").concat(label),\n      message: \"Going forward, use \".concat(label, \" as value for \").concat(label, \".\")\n    });\n    return asInjection(x);\n  }\n});\nconst isArray = d => Array.isArray(d);\nconst isObj = d => typeof d === \"object\";\nconst isNull = d => d == null;\nconst isBoolean = d => typeof d === \"boolean\";\nconst isNumber = d => typeof d === \"number\";\nconst isInteger = d => Number.isInteger(d);\nconst isString = d => typeof d === \"string\";\nconst throwTypeError = msg => {\n  throw new Error(\"Type Error: \" + msg);\n};\nconst numberValuesDeprecationNotice = type => {\n  log.deprecate({\n    pkg: \"@onflow/types\",\n    subject: \"Passing in Number as value for \".concat(type),\n    message: \"Going forward, use String as value for \".concat(type, \".\"),\n    transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/types/WARNINGS.md#0002-[U]Int*-and-Word*-as-Number\"\n  });\n};\nlet identityDeprecationShown = false;\n/**\n * @deprecated will be removed in v2.0.0\n */\nconst Identity = {\n  label: \"Identity\",\n  asArgument: v => {\n    if (!identityDeprecationShown) {\n      log.deprecate({\n        pkg: \"@onflow/types\",\n        subject: \"Identity\",\n        message: \"Identity type is deprecated and will be removed in v2.0.0.  Please remove it from your code.\"\n      });\n      identityDeprecationShown = true;\n    }\n    return v;\n  },\n  asInjection: v => v\n};\nconst UInt = typedef(\"UInt\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"UInt\");\n    return {\n      type: \"UInt\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"UInt\",\n      value: v\n    };\n  }\n  return throwTypeError(\"Expected Positive Integer for type Unsigned Int\");\n}, v => v);\nconst Int = typedef(\"Int\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Int\");\n    return {\n      type: \"Int\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Int\",\n      value: v\n    };\n  }\n  return throwTypeError(\"Expected Integer for type Int\");\n}, v => v);\nconst UInt8 = typedef(\"UInt8\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"UInt8\");\n    return {\n      type: \"UInt8\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"UInt8\",\n      value: v\n    };\n  }\n  return throwTypeError(\"Expected integer for UInt8\");\n}, v => v);\nconst Int8 = typedef(\"Int8\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Int8\");\n    return {\n      type: \"Int8\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Int8\",\n      value: v\n    };\n  }\n  return throwTypeError(\"Expected positive integer for Int8\");\n}, v => v);\nconst UInt16 = typedef(\"UInt16\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"UInt16\");\n    return {\n      type: \"UInt16\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"UInt16\",\n      value: v\n    };\n  }\n  return throwTypeError(\"Expected integer for UInt16\");\n}, v => v);\nconst Int16 = typedef(\"Int16\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Int16\");\n    return {\n      type: \"Int16\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Int16\",\n      value: v\n    };\n  }\n  return throwTypeError(\"Expected positive integer for Int16\");\n}, v => v);\nconst UInt32 = typedef(\"UInt32\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"UInt32\");\n    return {\n      type: \"UInt32\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"UInt32\",\n      value: v\n    };\n  }\n  return throwTypeError(\"Expected integer for UInt32\");\n}, v => v);\nconst Int32 = typedef(\"Int32\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Int32\");\n    return {\n      type: \"Int32\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Int32\",\n      value: v\n    };\n  }\n  return throwTypeError(\"Expected positive integer for Int32\");\n}, v => v);\nconst UInt64 = typedef(\"UInt64\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"UInt64\");\n    return {\n      type: \"UInt64\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"UInt64\",\n      value: v\n    };\n  }\n  return throwTypeError(\"Expected integer for UInt64\");\n}, v => v);\nconst Int64 = typedef(\"Int64\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Int64\");\n    return {\n      type: \"Int64\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Int64\",\n      value: v\n    };\n  }\n  return throwTypeError(\"Expected positive integer for Int64\");\n}, v => v);\nconst UInt128 = typedef(\"UInt128\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"UInt128\");\n    return {\n      type: \"UInt128\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"UInt128\",\n      value: v\n    };\n  }\n  return throwTypeError(\"Expected integer for UInt128\");\n}, v => v);\nconst Int128 = typedef(\"Int128\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Int128\");\n    return {\n      type: \"Int128\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Int128\",\n      value: v\n    };\n  }\n  return throwTypeError(\"Expected positive integer for Int128\");\n}, v => v);\nconst UInt256 = typedef(\"UInt256\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"UInt256\");\n    return {\n      type: \"UInt256\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"UInt256\",\n      value: v\n    };\n  }\n  return throwTypeError(\"Expected integer for UInt256\");\n}, v => v);\nconst Int256 = typedef(\"Int256\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Int256\");\n    return {\n      type: \"Int256\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Int256\",\n      value: v\n    };\n  }\n  return throwTypeError(\"Expected integer for Int256\");\n}, v => v);\nconst Word8 = typedef(\"Word8\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Word8\");\n    return {\n      type: \"Word8\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Word8\",\n      value: v\n    };\n  }\n  return throwTypeError(\"Expected positive number for Word8\");\n}, v => v);\nconst Word16 = typedef(\"Word16\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Word16\");\n    return {\n      type: \"Word16\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Word16\",\n      value: v\n    };\n  }\n  return throwTypeError(\"Expected positive number for Word16\");\n}, v => v);\nconst Word32 = typedef(\"Word32\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Word32\");\n    return {\n      type: \"Word32\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Word32\",\n      value: v\n    };\n  }\n  return throwTypeError(\"Expected positive number for Word32\");\n}, v => v);\nconst Word64 = typedef(\"Word64\", v => {\n  if (isNumber(v) && isInteger(v)) {\n    numberValuesDeprecationNotice(\"Word64\");\n    return {\n      type: \"Word64\",\n      value: v.toString()\n    };\n  }\n  if (isString(v)) {\n    return {\n      type: \"Word64\",\n      value: v\n    };\n  }\n  return throwTypeError(\"Expected positive number for Word64\");\n}, v => v);\nconst UFix64AndFix64NumberDeprecationNotice = () => {\n  log.deprecate({\n    subject: \"Passing in Numbers as values for Fix64 and UFix64 types\",\n    pkg: \"@onflow/types\",\n    transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/types/WARNINGS.md#0001-[U]Fix64-as-Number\"\n  });\n};\nconst UFix64 = typedef(\"UFix64\", v => {\n  if (isString(v)) {\n    const vParts = v.split(\".\");\n    if (vParts.length !== 2) {\n      return throwTypeError(\"Expected one decimal but found \".concat(vParts.length, \" in the [U]Fix64 value. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers\"));\n    }\n    if (vParts[1].length == 0 || vParts[1].length > 8) {\n      return throwTypeError(\"Expected at least one digit, and at most 8 digits following the decimal of the [U]Fix64 value but found \".concat(vParts[1].length, \" digits. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers\"));\n    }\n\n    // make sure the number is extended to 8 decimal places so it matches cadence encoding of UFix values\n    vParts[1] = vParts[1].padEnd(8, \"0\");\n    v = vParts.join(\".\");\n    return {\n      type: \"UFix64\",\n      value: v\n    };\n  } else if (isNumber(v)) {\n    UFix64AndFix64NumberDeprecationNotice();\n    return {\n      type: \"UFix64\",\n      value: v.toString()\n    };\n  }\n  return throwTypeError(\"Expected String for UFix64\");\n}, v => v);\nconst Fix64 = typedef(\"Fix64\", v => {\n  if (isString(v)) {\n    const vParts = v.split(\".\");\n    if (vParts.length !== 2) {\n      return throwTypeError(\"Expected one decimal but found \".concat(vParts.length, \" in the [U]Fix64 value. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers\"));\n    }\n    if (vParts[1].length == 0 || vParts[1].length > 8) {\n      return throwTypeError(\"Expected at least one digit, and at most 8 digits following the decimal of the [U]Fix64 value but found \".concat(vParts[1].length, \" digits. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers\"));\n    }\n\n    // make sure the number is extended to 8 decimal places so it matches cadence encoding of Fix64 values\n    vParts[1] = vParts[1].padEnd(8, \"0\");\n    v = vParts.join(\".\");\n    return {\n      type: \"Fix64\",\n      value: v\n    };\n  } else if (isNumber(v)) {\n    UFix64AndFix64NumberDeprecationNotice();\n    return {\n      type: \"Fix64\",\n      value: v.toString()\n    };\n  }\n  return throwTypeError(\"Expected String for Fix64\");\n}, v => v);\nconst String = typedef(\"String\", v => {\n  if (isString(v)) return {\n    type: \"String\",\n    value: v\n  };\n  return throwTypeError(\"Expected String for type String\");\n}, v => v);\nconst Character = typedef(\"Character\", v => {\n  if (isString(v)) return {\n    type: \"Character\",\n    value: v\n  };\n  return throwTypeError(\"Expected Character for type Character\");\n}, v => v);\nconst Bool = typedef(\"Bool\", v => {\n  if (isBoolean(v)) return {\n    type: \"Bool\",\n    value: v\n  };\n  return throwTypeError(\"Expected Boolean for type Bool\");\n}, v => v);\nconst Address = typedef(\"Address\", v => {\n  if (isString(v)) return {\n    type: \"Address\",\n    value: v\n  };\n  return throwTypeError(\"Expected Address for type Address\");\n}, v => v);\nconst Void = typedef(\"Void\", v => {\n  if (!v || isNull(v)) return {\n    type: \"Void\",\n    value: null\n  };\n  return throwTypeError(\"Expected Void for type Void\");\n}, v => v);\nconst Optional = children => typedef(\"Optional\", v => ({\n  type: \"Optional\",\n  value: isNull(v) ? null : children.asArgument(v)\n}), v => v);\nconst Reference = typedef(\"Reference\", v => {\n  if (isObj(v)) return {\n    type: \"Reference\",\n    value: v\n  };\n  return throwTypeError(\"Expected Object for type Reference\");\n}, v => v);\nconst _Array = function () {\n  let children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return typedef(\"Array\", v => {\n    return {\n      type: \"Array\",\n      value: isArray(children) ? children.map((c, i) => c.asArgument(v[i])) : v.map(x => children.asArgument(x))\n    };\n  }, v => v);\n};\nconst Dictionary = function () {\n  let children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return typedef(\"Dictionary\", v => {\n    const vIsArray = isArray(v);\n    const childrenIsArray = isArray(children);\n    if (isObj(v)) return {\n      type: \"Dictionary\",\n      value: childrenIsArray && vIsArray ? children.map((c, i) => ({\n        key: c.key.asArgument(v[i].key),\n        value: c.value.asArgument(v[i].value)\n      })) : vIsArray && !childrenIsArray ? v.map(x => ({\n        key: children.key.asArgument(x.key),\n        value: children.value.asArgument(x.value)\n      })) : !vIsArray && !childrenIsArray ? [{\n        key: children.key.asArgument(v.key),\n        value: children.value.asArgument(v.value)\n      }] : throwTypeError(\"Invalid arguments for Dictionary.\")\n    };\n    return throwTypeError(\"Expected Object for type Dictionary\");\n  }, v => v);\n};\nconst Event = function (id) {\n  let fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return typedef(\"Event\", v => {\n    if (isObj(v)) return {\n      type: \"Event\",\n      value: {\n        id: id,\n        fields: isArray(fields) ? fields.map((c, i) => ({\n          name: v.fields[i].name,\n          value: c.value.asArgument(v.fields[i].value)\n        })) : v.fields.map(x => ({\n          name: x.name,\n          value: fields.value.asArgument(x.value)\n        }))\n      }\n    };\n    return throwTypeError(\"Expected Object for type Event\");\n  }, v => v);\n};\nconst Resource = function (id) {\n  let fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return typedef(\"Resource\", v => {\n    if (isObj(v)) return {\n      type: \"Resource\",\n      value: {\n        id: id,\n        fields: isArray(fields) ? fields.map((c, i) => ({\n          name: v.fields[i].name,\n          value: c.value.asArgument(v.fields[i].value)\n        })) : v.fields.map(x => ({\n          name: x.name,\n          value: fields.value.asArgument(x.value)\n        }))\n      }\n    };\n    return throwTypeError(\"Expected Object for type Resource\");\n  }, v => v);\n};\nconst Struct = function (id) {\n  let fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return typedef(\"Struct\", v => {\n    if (isObj(v)) return {\n      type: \"Struct\",\n      value: {\n        id: id,\n        fields: isArray(fields) ? fields.map((c, i) => ({\n          name: v.fields[i].name,\n          value: c.value.asArgument(v.fields[i].value)\n        })) : v.fields.map(x => ({\n          name: x.name,\n          value: fields.value.asArgument(x.value)\n        }))\n      }\n    };\n    return throwTypeError(\"Expected Object for type Struct\");\n  }, v => v);\n};\nconst Enum = function (id) {\n  let fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return typedef(\"Enum\", v => {\n    if (isObj(v)) return {\n      type: \"Enum\",\n      value: {\n        id: id,\n        fields: isArray(fields) ? fields.map((c, i) => ({\n          name: v.fields[i].name,\n          value: c.value.asArgument(v.fields[i].value)\n        })) : v.fields.map(x => ({\n          name: x.name,\n          value: fields.value.asArgument(x.value)\n        }))\n      }\n    };\n    return throwTypeError(\"Expected Object for type Enum\");\n  }, v => v);\n};\nconst Path = typedef(\"Path\", v => {\n  if (isObj(v)) {\n    if (!isString(v.domain)) {\n      return throwTypeError(\"Expected a string for the Path domain but found \".concat(v.domain, \". Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path\"));\n    }\n    if (!(v.domain === \"storage\" || v.domain === \"private\" || v.domain === \"public\")) {\n      return throwTypeError(\"Expected either \\\"storage\\\", \\\"private\\\" or \\\"public\\\" as the Path domain but found \".concat(v.domain, \". Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path\"));\n    }\n    if (!isString(v.identifier)) {\n      return throwTypeError(\"Expected a string for the Path identifier but found \".concat(v.identifier, \". Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path\"));\n    }\n    return {\n      type: \"Path\",\n      value: {\n        domain: v.domain,\n        identifier: v.identifier\n      }\n    };\n  }\n  return throwTypeError(\"Expected Object for type Path\");\n}, v => v);\nexport { Address, _Array as Array, Bool, Character, Dictionary, Enum, Event, Fix64, Identity, Int, Int128, Int16, Int256, Int32, Int64, Int8, Optional, Path, Reference, Resource, String, Struct, UFix64, UInt, UInt128, UInt16, UInt256, UInt32, UInt64, UInt8, Void, Word16, Word32, Word64, Word8, _Array };","map":{"version":3,"names":["typedef","label","asArgument","asInjection","x","log","deprecate","pkg","subject","concat","message","isArray","d","Array","isObj","isNull","isBoolean","isNumber","isInteger","Number","isString","throwTypeError","msg","Error","numberValuesDeprecationNotice","type","transition","identityDeprecationShown","Identity","v","UInt","value","toString","Int","UInt8","Int8","UInt16","Int16","UInt32","Int32","UInt64","Int64","UInt128","Int128","UInt256","Int256","Word8","Word16","Word32","Word64","UFix64AndFix64NumberDeprecationNotice","UFix64","vParts","split","length","padEnd","join","Fix64","String","Character","Bool","Address","Void","Optional","children","Reference","_Array","arguments","undefined","map","c","i","Dictionary","vIsArray","childrenIsArray","key","Event","id","fields","name","Resource","Struct","Enum","Path","domain","identifier"],"sources":["../src/types.ts"],"sourcesContent":["import {log} from \"@onflow/util-logger\"\n\nexport type JsonCdc<L extends string, T> = {\n  type: L\n  value: T\n}\n\ntype JsonCdcLabel<X extends JsonCdc<string, unknown>> = X extends JsonCdc<\n  infer L,\n  unknown\n>\n  ? L\n  : never\n\nexport interface TypeDescriptor<T, V extends JsonCdc<string, unknown>> {\n  label: JsonCdcLabel<V>\n  asArgument: (x: T) => V\n  asInjection: (x: T) => T\n}\n\ntype TypeDescriptorInput<\n  X extends TypeDescriptor<any, JsonCdc<string, unknown>>\n> = X extends TypeDescriptor<infer T, JsonCdc<string, unknown>> ? T : never\n\nexport interface PathValue {\n  domain: \"storage\" | \"private\" | \"public\"\n  identifier: string\n}\n\nexport interface ReferenceValue {\n  type: string\n  address: string\n}\n\n/**\n * Creates a type descriptor for a given type\n * @param label - The label for the type\n * @param asArgument - A function that converts the type to a JsonCdcType\n * @param asInjection - A function which returns the argument as is\n * @returns A type descriptor\n * @internal\n */\nconst typedef = <T, V extends JsonCdc<string, unknown>>(\n  label: JsonCdcLabel<V>,\n  asArgument: (x: T) => V,\n  asInjection: (x: T) => T\n): TypeDescriptor<T, V> => ({\n  label,\n  asArgument,\n  asInjection: (x: T) => {\n    log.deprecate({\n      pkg: \"@onflow/types\",\n      subject: `Passing in ${label} as value for ${label}`,\n      message: `Going forward, use ${label} as value for ${label}.`,\n    })\n    return asInjection(x)\n  },\n})\n\nconst isArray = <T>(d: unknown): d is T[] => Array.isArray(d)\nconst isObj = (d: unknown): d is object => typeof d === \"object\"\nconst isNull = (d: unknown): d is null | undefined => d == null\nconst isBoolean = (d: unknown): d is boolean => typeof d === \"boolean\"\nconst isNumber = (d: unknown): d is number => typeof d === \"number\"\nconst isInteger = (d: unknown): d is number => Number.isInteger(d)\nconst isString = (d: unknown): d is string => typeof d === \"string\"\n\nconst throwTypeError = (msg: unknown): never => {\n  throw new Error(\"Type Error: \" + msg)\n}\n\nconst numberValuesDeprecationNotice = (type: string) => {\n  log.deprecate({\n    pkg: \"@onflow/types\",\n    subject: `Passing in Number as value for ${type}`,\n    message: `Going forward, use String as value for ${type}.`,\n    transition:\n      \"https://github.com/onflow/flow-js-sdk/blob/master/packages/types/WARNINGS.md#0002-[U]Int*-and-Word*-as-Number\",\n  })\n}\n\nlet identityDeprecationShown = false\n/**\n * @deprecated will be removed in v2.0.0\n */\nexport const Identity = {\n  label: \"Identity\",\n  asArgument: <T>(v: T) => {\n    if (!identityDeprecationShown) {\n      log.deprecate({\n        pkg: \"@onflow/types\",\n        subject: \"Identity\",\n        message:\n          \"Identity type is deprecated and will be removed in v2.0.0.  Please remove it from your code.\",\n      })\n      identityDeprecationShown = true\n    }\n    return v\n  },\n  asInjection: <T>(v: T) => v,\n}\n\nexport const UInt = typedef(\n  \"UInt\",\n  (v: number | string) => {\n    if (isNumber(v) && isInteger(v)) {\n      numberValuesDeprecationNotice(\"UInt\")\n      return {\n        type: \"UInt\",\n        value: v.toString(),\n      }\n    }\n    if (isString(v)) {\n      return {\n        type: \"UInt\",\n        value: v,\n      }\n    }\n    return throwTypeError(\"Expected Positive Integer for type Unsigned Int\")\n  },\n  v => v\n)\n\nexport const Int = typedef(\n  \"Int\",\n  (v: number | string) => {\n    if (isNumber(v) && isInteger(v)) {\n      numberValuesDeprecationNotice(\"Int\")\n      return {\n        type: \"Int\",\n        value: v.toString(),\n      }\n    }\n    if (isString(v)) {\n      return {\n        type: \"Int\",\n        value: v,\n      }\n    }\n    return throwTypeError(\"Expected Integer for type Int\")\n  },\n  v => v\n)\n\nexport const UInt8 = typedef(\n  \"UInt8\",\n  (v: number | string) => {\n    if (isNumber(v) && isInteger(v)) {\n      numberValuesDeprecationNotice(\"UInt8\")\n      return {\n        type: \"UInt8\",\n        value: v.toString(),\n      }\n    }\n    if (isString(v)) {\n      return {\n        type: \"UInt8\",\n        value: v,\n      }\n    }\n    return throwTypeError(\"Expected integer for UInt8\")\n  },\n  v => v\n)\n\nexport const Int8 = typedef(\n  \"Int8\",\n  (v: number | string) => {\n    if (isNumber(v) && isInteger(v)) {\n      numberValuesDeprecationNotice(\"Int8\")\n      return {\n        type: \"Int8\",\n        value: v.toString(),\n      }\n    }\n    if (isString(v)) {\n      return {\n        type: \"Int8\",\n        value: v,\n      }\n    }\n    return throwTypeError(\"Expected positive integer for Int8\")\n  },\n  v => v\n)\n\nexport const UInt16 = typedef(\n  \"UInt16\",\n  (v: number | string) => {\n    if (isNumber(v) && isInteger(v)) {\n      numberValuesDeprecationNotice(\"UInt16\")\n      return {\n        type: \"UInt16\",\n        value: v.toString(),\n      }\n    }\n    if (isString(v)) {\n      return {\n        type: \"UInt16\",\n        value: v,\n      }\n    }\n    return throwTypeError(\"Expected integer for UInt16\")\n  },\n  v => v\n)\n\nexport const Int16 = typedef(\n  \"Int16\",\n  (v: number | string) => {\n    if (isNumber(v) && isInteger(v)) {\n      numberValuesDeprecationNotice(\"Int16\")\n      return {\n        type: \"Int16\",\n        value: v.toString(),\n      }\n    }\n    if (isString(v)) {\n      return {\n        type: \"Int16\",\n        value: v,\n      }\n    }\n    return throwTypeError(\"Expected positive integer for Int16\")\n  },\n  v => v\n)\n\nexport const UInt32 = typedef(\n  \"UInt32\",\n  (v: number | string) => {\n    if (isNumber(v) && isInteger(v)) {\n      numberValuesDeprecationNotice(\"UInt32\")\n      return {\n        type: \"UInt32\",\n        value: v.toString(),\n      }\n    }\n    if (isString(v)) {\n      return {\n        type: \"UInt32\",\n        value: v,\n      }\n    }\n    return throwTypeError(\"Expected integer for UInt32\")\n  },\n  v => v\n)\n\nexport const Int32 = typedef(\n  \"Int32\",\n  (v: number | string) => {\n    if (isNumber(v) && isInteger(v)) {\n      numberValuesDeprecationNotice(\"Int32\")\n      return {\n        type: \"Int32\",\n        value: v.toString(),\n      }\n    }\n    if (isString(v)) {\n      return {\n        type: \"Int32\",\n        value: v,\n      }\n    }\n    return throwTypeError(\"Expected positive integer for Int32\")\n  },\n  v => v\n)\n\nexport const UInt64 = typedef(\n  \"UInt64\",\n  (v: number | string) => {\n    if (isNumber(v) && isInteger(v)) {\n      numberValuesDeprecationNotice(\"UInt64\")\n      return {\n        type: \"UInt64\",\n        value: v.toString(),\n      }\n    }\n    if (isString(v)) {\n      return {\n        type: \"UInt64\",\n        value: v,\n      }\n    }\n    return throwTypeError(\"Expected integer for UInt64\")\n  },\n  v => v\n)\n\nexport const Int64 = typedef(\n  \"Int64\",\n  (v: number | string) => {\n    if (isNumber(v) && isInteger(v)) {\n      numberValuesDeprecationNotice(\"Int64\")\n      return {\n        type: \"Int64\",\n        value: v.toString(),\n      }\n    }\n    if (isString(v)) {\n      return {\n        type: \"Int64\",\n        value: v,\n      }\n    }\n    return throwTypeError(\"Expected positive integer for Int64\")\n  },\n  v => v\n)\n\nexport const UInt128 = typedef(\n  \"UInt128\",\n  (v: number | string) => {\n    if (isNumber(v) && isInteger(v)) {\n      numberValuesDeprecationNotice(\"UInt128\")\n      return {\n        type: \"UInt128\",\n        value: v.toString(),\n      }\n    }\n    if (isString(v)) {\n      return {\n        type: \"UInt128\",\n        value: v,\n      }\n    }\n    return throwTypeError(\"Expected integer for UInt128\")\n  },\n  v => v\n)\n\nexport const Int128 = typedef(\n  \"Int128\",\n  (v: number | string) => {\n    if (isNumber(v) && isInteger(v)) {\n      numberValuesDeprecationNotice(\"Int128\")\n      return {\n        type: \"Int128\",\n        value: v.toString(),\n      }\n    }\n    if (isString(v)) {\n      return {\n        type: \"Int128\",\n        value: v,\n      }\n    }\n    return throwTypeError(\"Expected positive integer for Int128\")\n  },\n  v => v\n)\n\nexport const UInt256 = typedef(\n  \"UInt256\",\n  (v: number | string) => {\n    if (isNumber(v) && isInteger(v)) {\n      numberValuesDeprecationNotice(\"UInt256\")\n      return {\n        type: \"UInt256\",\n        value: v.toString(),\n      }\n    }\n    if (isString(v)) {\n      return {\n        type: \"UInt256\",\n        value: v,\n      }\n    }\n    return throwTypeError(\"Expected integer for UInt256\")\n  },\n  v => v\n)\n\nexport const Int256 = typedef(\n  \"Int256\",\n  (v: number | string) => {\n    if (isNumber(v) && isInteger(v)) {\n      numberValuesDeprecationNotice(\"Int256\")\n      return {\n        type: \"Int256\",\n        value: v.toString(),\n      }\n    }\n    if (isString(v)) {\n      return {\n        type: \"Int256\",\n        value: v,\n      }\n    }\n    return throwTypeError(\"Expected integer for Int256\")\n  },\n  v => v\n)\n\nexport const Word8 = typedef(\n  \"Word8\",\n  (v: number | string) => {\n    if (isNumber(v) && isInteger(v)) {\n      numberValuesDeprecationNotice(\"Word8\")\n      return {\n        type: \"Word8\",\n        value: v.toString(),\n      }\n    }\n    if (isString(v)) {\n      return {\n        type: \"Word8\",\n        value: v,\n      }\n    }\n    return throwTypeError(\"Expected positive number for Word8\")\n  },\n  v => v\n)\n\nexport const Word16 = typedef(\n  \"Word16\",\n  (v: number | string) => {\n    if (isNumber(v) && isInteger(v)) {\n      numberValuesDeprecationNotice(\"Word16\")\n      return {\n        type: \"Word16\",\n        value: v.toString(),\n      }\n    }\n    if (isString(v)) {\n      return {\n        type: \"Word16\",\n        value: v,\n      }\n    }\n    return throwTypeError(\"Expected positive number for Word16\")\n  },\n  v => v\n)\n\nexport const Word32 = typedef(\n  \"Word32\",\n  (v: number | string) => {\n    if (isNumber(v) && isInteger(v)) {\n      numberValuesDeprecationNotice(\"Word32\")\n      return {\n        type: \"Word32\",\n        value: v.toString(),\n      }\n    }\n    if (isString(v)) {\n      return {\n        type: \"Word32\",\n        value: v,\n      }\n    }\n    return throwTypeError(\"Expected positive number for Word32\")\n  },\n  v => v\n)\n\nexport const Word64 = typedef(\n  \"Word64\",\n  (v: number | string) => {\n    if (isNumber(v) && isInteger(v)) {\n      numberValuesDeprecationNotice(\"Word64\")\n      return {\n        type: \"Word64\",\n        value: v.toString(),\n      }\n    }\n    if (isString(v)) {\n      return {\n        type: \"Word64\",\n        value: v,\n      }\n    }\n    return throwTypeError(\"Expected positive number for Word64\")\n  },\n  v => v\n)\n\nconst UFix64AndFix64NumberDeprecationNotice = () => {\n  log.deprecate({\n    subject: \"Passing in Numbers as values for Fix64 and UFix64 types\",\n    pkg: \"@onflow/types\",\n    transition:\n      \"https://github.com/onflow/flow-js-sdk/blob/master/packages/types/WARNINGS.md#0001-[U]Fix64-as-Number\",\n  })\n}\n\nexport const UFix64 = typedef(\n  \"UFix64\",\n  (v: number | string) => {\n    if (isString(v)) {\n      const vParts = v.split(\".\")\n      if (vParts.length !== 2) {\n        return throwTypeError(\n          `Expected one decimal but found ${vParts.length} in the [U]Fix64 value. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`\n        )\n      }\n      if (vParts[1].length == 0 || vParts[1].length > 8) {\n        return throwTypeError(\n          `Expected at least one digit, and at most 8 digits following the decimal of the [U]Fix64 value but found ${vParts[1].length} digits. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`\n        )\n      }\n\n      // make sure the number is extended to 8 decimal places so it matches cadence encoding of UFix values\n      vParts[1] = vParts[1].padEnd(8, \"0\")\n      v = vParts.join(\".\")\n\n      return {\n        type: \"UFix64\",\n        value: v,\n      }\n    } else if (isNumber(v)) {\n      UFix64AndFix64NumberDeprecationNotice()\n      return {\n        type: \"UFix64\",\n        value: v.toString(),\n      }\n    }\n    return throwTypeError(\"Expected String for UFix64\")\n  },\n  v => v\n)\n\nexport const Fix64 = typedef(\n  \"Fix64\",\n  (v: number | string) => {\n    if (isString(v)) {\n      const vParts = v.split(\".\")\n      if (vParts.length !== 2) {\n        return throwTypeError(\n          `Expected one decimal but found ${vParts.length} in the [U]Fix64 value. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`\n        )\n      }\n      if (vParts[1].length == 0 || vParts[1].length > 8) {\n        return throwTypeError(\n          `Expected at least one digit, and at most 8 digits following the decimal of the [U]Fix64 value but found ${vParts[1].length} digits. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers`\n        )\n      }\n\n      // make sure the number is extended to 8 decimal places so it matches cadence encoding of Fix64 values\n      vParts[1] = vParts[1].padEnd(8, \"0\")\n      v = vParts.join(\".\")\n\n      return {\n        type: \"Fix64\",\n        value: v,\n      }\n    } else if (isNumber(v)) {\n      UFix64AndFix64NumberDeprecationNotice()\n      return {\n        type: \"Fix64\",\n        value: v.toString(),\n      }\n    }\n    return throwTypeError(\"Expected String for Fix64\")\n  },\n  v => v\n)\n\nexport const String = typedef(\n  \"String\",\n  (v: string) => {\n    if (isString(v))\n      return {\n        type: \"String\",\n        value: v,\n      }\n    return throwTypeError(\"Expected String for type String\")\n  },\n  v => v\n)\n\nexport const Character = typedef(\n  \"Character\",\n  (v: string) => {\n    if (isString(v))\n      return {\n        type: \"Character\",\n        value: v,\n      }\n    return throwTypeError(\"Expected Character for type Character\")\n  },\n  v => v\n)\n\nexport const Bool = typedef(\n  \"Bool\",\n  (v: boolean) => {\n    if (isBoolean(v))\n      return {\n        type: \"Bool\",\n        value: v,\n      }\n    return throwTypeError(\"Expected Boolean for type Bool\")\n  },\n  v => v\n)\n\nexport const Address = typedef(\n  \"Address\",\n  (v: string) => {\n    if (isString(v))\n      return {\n        type: \"Address\",\n        value: v,\n      }\n    return throwTypeError(\"Expected Address for type Address\")\n  },\n  v => v\n)\n\nexport const Void = typedef(\n  \"Void\",\n  (v?: null) => {\n    if (!v || isNull(v))\n      return {\n        type: \"Void\",\n        value: null,\n      }\n    return throwTypeError(\"Expected Void for type Void\")\n  },\n  v => v\n)\n\nexport const Optional = <\n  T extends TypeDescriptor<any, JsonCdc<string, unknown>>\n>(\n  children: T\n) =>\n  typedef(\n    \"Optional\",\n    (v?: TypeDescriptorInput<T> | null) => ({\n      type: \"Optional\",\n      value: isNull(v) ? null : children.asArgument(v),\n    }),\n    v => v\n  )\n\nexport const Reference = typedef(\n  \"Reference\",\n  (v: ReferenceValue) => {\n    if (isObj(v))\n      return {\n        type: \"Reference\",\n        value: v,\n      }\n    return throwTypeError(\"Expected Object for type Reference\")\n  },\n  v => v\n)\n\nexport const _Array = <T extends TypeDescriptor<any, JsonCdc<string, unknown>>>(\n  children: T[] | T = []\n) =>\n  typedef(\n    \"Array\",\n    (v: TypeDescriptorInput<T>[]) => {\n      return {\n        type: \"Array\",\n        value: isArray(children)\n          ? children.map((c, i) => c.asArgument(v[i]))\n          : v.map(x => children.asArgument(x)),\n      }\n    },\n    v => v\n  )\n\nexport {_Array as Array}\n\nexport const Dictionary = <\n  K extends TypeDescriptor<any, JsonCdc<string, unknown>>,\n  V extends TypeDescriptor<any, JsonCdc<string, unknown>>\n>(\n  children:\n    | {\n        key: K\n        value: V\n      }[]\n    | {\n        key: K\n        value: V\n      } = []\n) =>\n  typedef(\n    \"Dictionary\",\n    (\n      v:\n        | {key: TypeDescriptorInput<K>; value: TypeDescriptorInput<V>}[]\n        | {key: TypeDescriptorInput<K>; value: TypeDescriptorInput<V>}\n    ) => {\n      const vIsArray = isArray(v)\n      const childrenIsArray = isArray(children)\n\n      if (isObj(v))\n        return {\n          type: \"Dictionary\",\n          value:\n            childrenIsArray && vIsArray\n              ? children.map((c, i) => ({\n                  key: c.key.asArgument(v[i].key),\n                  value: c.value.asArgument(v[i].value),\n                }))\n              : vIsArray && !childrenIsArray\n              ? v.map(x => ({\n                  key: children.key.asArgument(x.key),\n                  value: children.value.asArgument(x.value),\n                }))\n              : !vIsArray && !childrenIsArray\n              ? [\n                  {\n                    key: children.key.asArgument(v.key),\n                    value: children.value.asArgument(v.value),\n                  },\n                ]\n              : throwTypeError(\"Invalid arguments for Dictionary.\"),\n        }\n      return throwTypeError(\"Expected Object for type Dictionary\")\n    },\n    v => v\n  )\n\nexport const Event = <V extends TypeDescriptor<any, JsonCdc<string, unknown>>>(\n  id: string,\n  fields: {value: V}[] | {value: V} = []\n) =>\n  typedef(\n    \"Event\",\n    (v: {fields: {name: string; value: TypeDescriptorInput<V>}[]}) => {\n      if (isObj(v))\n        return {\n          type: \"Event\",\n          value: {\n            id: id,\n            fields: isArray(fields)\n              ? fields.map((c, i) => ({\n                  name: v.fields[i].name,\n                  value: c.value.asArgument(v.fields[i].value),\n                }))\n              : v.fields.map(x => ({\n                  name: x.name,\n                  value: fields.value.asArgument(x.value),\n                })),\n          },\n        }\n      return throwTypeError(\"Expected Object for type Event\")\n    },\n    v => v\n  )\n\nexport const Resource = <\n  V extends TypeDescriptor<any, JsonCdc<string, unknown>>\n>(\n  id: string,\n  fields: {value: V}[] | {value: V} = []\n) =>\n  typedef(\n    \"Resource\",\n    (v: {fields: {name: string; value: TypeDescriptorInput<V>}[]}) => {\n      if (isObj(v))\n        return {\n          type: \"Resource\",\n          value: {\n            id: id,\n            fields: isArray(fields)\n              ? fields.map((c, i) => ({\n                  name: v.fields[i].name,\n                  value: c.value.asArgument(v.fields[i].value),\n                }))\n              : v.fields.map(x => ({\n                  name: x.name,\n                  value: fields.value.asArgument(x.value),\n                })),\n          },\n        }\n      return throwTypeError(\"Expected Object for type Resource\")\n    },\n    v => v\n  )\n\nexport const Struct = <V extends TypeDescriptor<any, JsonCdc<string, unknown>>>(\n  id: string,\n  fields: {value: V}[] | {value: V} = []\n) =>\n  typedef(\n    \"Struct\",\n    (v: {fields: {name: string; value: TypeDescriptorInput<V>}[]}) => {\n      if (isObj(v))\n        return {\n          type: \"Struct\",\n          value: {\n            id: id,\n            fields: isArray(fields)\n              ? fields.map((c, i) => ({\n                  name: v.fields[i].name,\n                  value: c.value.asArgument(v.fields[i].value),\n                }))\n              : v.fields.map(x => ({\n                  name: x.name,\n                  value: fields.value.asArgument(x.value),\n                })),\n          },\n        }\n      return throwTypeError(\"Expected Object for type Struct\")\n    },\n    v => v\n  )\n\nexport const Enum = <V extends TypeDescriptor<any, JsonCdc<string, unknown>>>(\n  id: string,\n  fields: {value: V}[] | {value: V} = []\n) =>\n  typedef(\n    \"Enum\",\n    (v: {fields: {name: string; value: TypeDescriptorInput<V>}[]}) => {\n      if (isObj(v))\n        return {\n          type: \"Enum\",\n          value: {\n            id: id,\n            fields: isArray(fields)\n              ? fields.map((c, i) => ({\n                  name: v.fields[i].name,\n                  value: c.value.asArgument(v.fields[i].value),\n                }))\n              : v.fields.map(x => ({\n                  name: x.name,\n                  value: fields.value.asArgument(x.value),\n                })),\n          },\n        }\n      return throwTypeError(\"Expected Object for type Enum\")\n    },\n    v => v\n  )\n\nexport const Path = typedef(\n  \"Path\",\n  (v: PathValue) => {\n    if (isObj(v)) {\n      if (!isString(v.domain)) {\n        return throwTypeError(\n          `Expected a string for the Path domain but found ${v.domain}. Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path`\n        )\n      }\n\n      if (\n        !(\n          v.domain === \"storage\" ||\n          v.domain === \"private\" ||\n          v.domain === \"public\"\n        )\n      ) {\n        return throwTypeError(\n          `Expected either \"storage\", \"private\" or \"public\" as the Path domain but found ${v.domain}. Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path`\n        )\n      }\n\n      if (!isString(v.identifier)) {\n        return throwTypeError(\n          `Expected a string for the Path identifier but found ${v.identifier}. Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path`\n        )\n      }\n\n      return {\n        type: \"Path\",\n        value: {\n          domain: v.domain,\n          identifier: v.identifier,\n        },\n      }\n    }\n    return throwTypeError(\"Expected Object for type Path\")\n  },\n  v => v\n)\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}