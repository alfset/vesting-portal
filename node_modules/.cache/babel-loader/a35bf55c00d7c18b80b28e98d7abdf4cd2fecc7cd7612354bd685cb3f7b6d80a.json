{"ast":null,"code":"const BN = require('bn.js');\nconst EC = require('elliptic').ec;\nconst secp256k1 = new EC('secp256k1');\nconst deterministicGenerateK = require('./rfc6979');\nconst ZERO32 = Buffer.alloc(32, 0);\nconst EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex');\nconst EC_P = Buffer.from('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f', 'hex');\nconst n = secp256k1.curve.n;\nconst nDiv2 = n.shrn(1);\nconst G = secp256k1.curve.g;\nconst THROW_BAD_PRIVATE = 'Expected Private';\nconst THROW_BAD_POINT = 'Expected Point';\nconst THROW_BAD_TWEAK = 'Expected Tweak';\nconst THROW_BAD_HASH = 'Expected Hash';\nconst THROW_BAD_SIGNATURE = 'Expected Signature';\nconst THROW_BAD_EXTRA_DATA = 'Expected Extra Data (32 bytes)';\nfunction isScalar(x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\nfunction isOrderScalar(x) {\n  if (!isScalar(x)) return false;\n  return x.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\nfunction isPoint(p) {\n  if (!Buffer.isBuffer(p)) return false;\n  if (p.length < 33) return false;\n  const t = p[0];\n  const x = p.slice(1, 33);\n  if (x.compare(ZERO32) === 0) return false;\n  if (x.compare(EC_P) >= 0) return false;\n  if ((t === 0x02 || t === 0x03) && p.length === 33) {\n    try {\n      decodeFrom(p);\n    } catch (e) {\n      return false;\n    } // TODO: temporary\n    return true;\n  }\n  const y = p.slice(33);\n  if (y.compare(ZERO32) === 0) return false;\n  if (y.compare(EC_P) >= 0) return false;\n  if (t === 0x04 && p.length === 65) return true;\n  return false;\n}\nfunction __isPointCompressed(p) {\n  return p[0] !== 0x04;\n}\nfunction isPointCompressed(p) {\n  if (!isPoint(p)) return false;\n  return __isPointCompressed(p);\n}\nfunction isPrivate(x) {\n  if (!isScalar(x)) return false;\n  return x.compare(ZERO32) > 0 &&\n  // > 0\n  x.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\nfunction isSignature(value) {\n  const r = value.slice(0, 32);\n  const s = value.slice(32, 64);\n  return Buffer.isBuffer(value) && value.length === 64 && r.compare(EC_GROUP_ORDER) < 0 && s.compare(EC_GROUP_ORDER) < 0;\n}\nfunction assumeCompression(value, pubkey) {\n  if (value === undefined && pubkey !== undefined) return __isPointCompressed(pubkey);\n  if (value === undefined) return true;\n  return value;\n}\nfunction fromBuffer(d) {\n  return new BN(d);\n}\nfunction toBuffer(d) {\n  return d.toArrayLike(Buffer, 'be', 32);\n}\nfunction decodeFrom(P) {\n  return secp256k1.curve.decodePoint(P);\n}\nfunction getEncoded(P, compressed) {\n  return Buffer.from(P._encode(compressed));\n}\nfunction pointAdd(pA, pB, __compressed) {\n  if (!isPoint(pA)) throw new TypeError(THROW_BAD_POINT);\n  if (!isPoint(pB)) throw new TypeError(THROW_BAD_POINT);\n  const a = decodeFrom(pA);\n  const b = decodeFrom(pB);\n  const pp = a.add(b);\n  if (pp.isInfinity()) return null;\n  const compressed = assumeCompression(__compressed, pA);\n  return getEncoded(pp, compressed);\n}\nfunction pointAddScalar(p, tweak, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);\n  const compressed = assumeCompression(__compressed, p);\n  const pp = decodeFrom(p);\n  if (tweak.compare(ZERO32) === 0) return getEncoded(pp, compressed);\n  const tt = fromBuffer(tweak);\n  const qq = G.mul(tt);\n  const uu = pp.add(qq);\n  if (uu.isInfinity()) return null;\n  return getEncoded(uu, compressed);\n}\nfunction pointCompress(p, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);\n  const pp = decodeFrom(p);\n  if (pp.isInfinity()) throw new TypeError(THROW_BAD_POINT);\n  const compressed = assumeCompression(__compressed, p);\n  return getEncoded(pp, compressed);\n}\nfunction pointFromScalar(d, __compressed) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);\n  const dd = fromBuffer(d);\n  const pp = G.mul(dd);\n  if (pp.isInfinity()) return null;\n  const compressed = assumeCompression(__compressed);\n  return getEncoded(pp, compressed);\n}\nfunction pointMultiply(p, tweak, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT);\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);\n  const compressed = assumeCompression(__compressed, p);\n  const pp = decodeFrom(p);\n  const tt = fromBuffer(tweak);\n  const qq = pp.mul(tt);\n  if (qq.isInfinity()) return null;\n  return getEncoded(qq, compressed);\n}\nfunction privateAdd(d, tweak) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);\n  const dd = fromBuffer(d);\n  const tt = fromBuffer(tweak);\n  const dt = toBuffer(dd.add(tt).umod(n));\n  if (!isPrivate(dt)) return null;\n  return dt;\n}\nfunction privateSub(d, tweak) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE);\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK);\n  const dd = fromBuffer(d);\n  const tt = fromBuffer(tweak);\n  const dt = toBuffer(dd.sub(tt).umod(n));\n  if (!isPrivate(dt)) return null;\n  return dt;\n}\nfunction sign(hash, x) {\n  return __sign(hash, x);\n}\nfunction signWithEntropy(hash, x, addData) {\n  return __sign(hash, x, addData);\n}\nfunction __sign(hash, x, addData) {\n  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH);\n  if (!isPrivate(x)) throw new TypeError(THROW_BAD_PRIVATE);\n  if (addData !== undefined && !isScalar(addData)) throw new TypeError(THROW_BAD_EXTRA_DATA);\n  const d = fromBuffer(x);\n  const e = fromBuffer(hash);\n  let r, s;\n  const checkSig = function (k) {\n    const kI = fromBuffer(k);\n    const Q = G.mul(kI);\n    if (Q.isInfinity()) return false;\n    r = Q.x.umod(n);\n    if (r.isZero() === 0) return false;\n    s = kI.invm(n).mul(e.add(d.mul(r))).umod(n);\n    if (s.isZero() === 0) return false;\n    return true;\n  };\n  deterministicGenerateK(hash, x, checkSig, isPrivate, addData);\n\n  // enforce low S values, see bip62: 'low s values in signatures'\n  if (s.cmp(nDiv2) > 0) {\n    s = n.sub(s);\n  }\n  const buffer = Buffer.allocUnsafe(64);\n  toBuffer(r).copy(buffer, 0);\n  toBuffer(s).copy(buffer, 32);\n  return buffer;\n}\nfunction verify(hash, q, signature, strict) {\n  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH);\n  if (!isPoint(q)) throw new TypeError(THROW_BAD_POINT);\n\n  // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1] (1, isSignature enforces '< n - 1')\n  if (!isSignature(signature)) throw new TypeError(THROW_BAD_SIGNATURE);\n  const Q = decodeFrom(q);\n  const r = fromBuffer(signature.slice(0, 32));\n  const s = fromBuffer(signature.slice(32, 64));\n  if (strict && s.cmp(nDiv2) > 0) {\n    return false;\n  }\n\n  // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1] (2, enforces '> 0')\n  if (r.gtn(0) <= 0 /* || r.compareTo(n) >= 0 */) return false;\n  if (s.gtn(0) <= 0 /* || s.compareTo(n) >= 0 */) return false;\n\n  // 1.4.2 H = Hash(M), already done by the user\n  // 1.4.3 e = H\n  const e = fromBuffer(hash);\n\n  // Compute s^-1\n  const sInv = s.invm(n);\n\n  // 1.4.4 Compute u1 = es^−1 mod n\n  //               u2 = rs^−1 mod n\n  const u1 = e.mul(sInv).umod(n);\n  const u2 = r.mul(sInv).umod(n);\n\n  // 1.4.5 Compute R = (xR, yR)\n  //               R = u1G + u2Q\n  const R = G.mulAdd(u1, Q, u2);\n\n  // 1.4.5 (cont.) Enforce R is not at infinity\n  if (R.isInfinity()) return false;\n\n  // 1.4.6 Convert the field element R.x to an integer\n  const xR = R.x;\n\n  // 1.4.7 Set v = xR mod n\n  const v = xR.umod(n);\n\n  // 1.4.8 If v = r, output \"valid\", and if v != r, output \"invalid\"\n  return v.eq(r);\n}\nmodule.exports = {\n  isPoint,\n  isPointCompressed,\n  isPrivate,\n  pointAdd,\n  pointAddScalar,\n  pointCompress,\n  pointFromScalar,\n  pointMultiply,\n  privateAdd,\n  privateSub,\n  sign,\n  signWithEntropy,\n  verify\n};","map":{"version":3,"names":["BN","require","EC","ec","secp256k1","deterministicGenerateK","ZERO32","Buffer","alloc","EC_GROUP_ORDER","from","EC_P","n","curve","nDiv2","shrn","G","g","THROW_BAD_PRIVATE","THROW_BAD_POINT","THROW_BAD_TWEAK","THROW_BAD_HASH","THROW_BAD_SIGNATURE","THROW_BAD_EXTRA_DATA","isScalar","x","isBuffer","length","isOrderScalar","compare","isPoint","p","t","slice","decodeFrom","e","y","__isPointCompressed","isPointCompressed","isPrivate","isSignature","value","r","s","assumeCompression","pubkey","undefined","fromBuffer","d","toBuffer","toArrayLike","P","decodePoint","getEncoded","compressed","_encode","pointAdd","pA","pB","__compressed","TypeError","a","b","pp","add","isInfinity","pointAddScalar","tweak","tt","qq","mul","uu","pointCompress","pointFromScalar","dd","pointMultiply","privateAdd","dt","umod","privateSub","sub","sign","hash","__sign","signWithEntropy","addData","checkSig","k","kI","Q","isZero","invm","cmp","buffer","allocUnsafe","copy","verify","q","signature","strict","gtn","sInv","u1","u2","R","mulAdd","xR","v","eq","module","exports"],"sources":["/workspace/Planq-Dapps/vesting-portal/node_modules/tiny-secp256k1/js.js"],"sourcesContent":["const BN = require('bn.js')\nconst EC = require('elliptic').ec\nconst secp256k1 = new EC('secp256k1')\nconst deterministicGenerateK = require('./rfc6979')\n\nconst ZERO32 = Buffer.alloc(32, 0)\nconst EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex')\nconst EC_P = Buffer.from('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f', 'hex')\n\nconst n = secp256k1.curve.n\nconst nDiv2 = n.shrn(1)\nconst G = secp256k1.curve.g\n\nconst THROW_BAD_PRIVATE = 'Expected Private'\nconst THROW_BAD_POINT = 'Expected Point'\nconst THROW_BAD_TWEAK = 'Expected Tweak'\nconst THROW_BAD_HASH = 'Expected Hash'\nconst THROW_BAD_SIGNATURE = 'Expected Signature'\nconst THROW_BAD_EXTRA_DATA = 'Expected Extra Data (32 bytes)'\n\nfunction isScalar (x) {\n  return Buffer.isBuffer(x) && x.length === 32\n}\n\nfunction isOrderScalar (x) {\n  if (!isScalar(x)) return false\n  return x.compare(EC_GROUP_ORDER) < 0 // < G\n}\n\nfunction isPoint (p) {\n  if (!Buffer.isBuffer(p)) return false\n  if (p.length < 33) return false\n\n  const t = p[0]\n  const x = p.slice(1, 33)\n  if (x.compare(ZERO32) === 0) return false\n  if (x.compare(EC_P) >= 0) return false\n  if ((t === 0x02 || t === 0x03) && p.length === 33) {\n    try { decodeFrom(p) } catch (e) { return false } // TODO: temporary\n    return true\n  }\n\n  const y = p.slice(33)\n  if (y.compare(ZERO32) === 0) return false\n  if (y.compare(EC_P) >= 0) return false\n  if (t === 0x04 && p.length === 65) return true\n  return false\n}\n\nfunction __isPointCompressed (p) {\n  return p[0] !== 0x04\n}\n\nfunction isPointCompressed (p) {\n  if (!isPoint(p)) return false\n  return __isPointCompressed(p)\n}\n\nfunction isPrivate (x) {\n  if (!isScalar(x)) return false\n  return x.compare(ZERO32) > 0 && // > 0\n    x.compare(EC_GROUP_ORDER) < 0 // < G\n}\n\nfunction isSignature (value) {\n  const r = value.slice(0, 32)\n  const s = value.slice(32, 64)\n  return Buffer.isBuffer(value) && value.length === 64 &&\n    r.compare(EC_GROUP_ORDER) < 0 &&\n    s.compare(EC_GROUP_ORDER) < 0\n}\n\nfunction assumeCompression (value, pubkey) {\n  if (value === undefined && pubkey !== undefined) return __isPointCompressed(pubkey)\n  if (value === undefined) return true\n  return value\n}\n\nfunction fromBuffer (d) { return new BN(d) }\nfunction toBuffer (d) { return d.toArrayLike(Buffer, 'be', 32) }\nfunction decodeFrom (P) { return secp256k1.curve.decodePoint(P) }\nfunction getEncoded (P, compressed) { return Buffer.from(P._encode(compressed)) }\n\nfunction pointAdd (pA, pB, __compressed) {\n  if (!isPoint(pA)) throw new TypeError(THROW_BAD_POINT)\n  if (!isPoint(pB)) throw new TypeError(THROW_BAD_POINT)\n\n  const a = decodeFrom(pA)\n  const b = decodeFrom(pB)\n  const pp = a.add(b)\n  if (pp.isInfinity()) return null\n\n  const compressed = assumeCompression(__compressed, pA)\n  return getEncoded(pp, compressed)\n}\n\nfunction pointAddScalar (p, tweak, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const compressed = assumeCompression(__compressed, p)\n  const pp = decodeFrom(p)\n  if (tweak.compare(ZERO32) === 0) return getEncoded(pp, compressed)\n\n  const tt = fromBuffer(tweak)\n  const qq = G.mul(tt)\n  const uu = pp.add(qq)\n  if (uu.isInfinity()) return null\n\n  return getEncoded(uu, compressed)\n}\n\nfunction pointCompress (p, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)\n\n  const pp = decodeFrom(p)\n  if (pp.isInfinity()) throw new TypeError(THROW_BAD_POINT)\n\n  const compressed = assumeCompression(__compressed, p)\n\n  return getEncoded(pp, compressed)\n}\n\nfunction pointFromScalar (d, __compressed) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)\n\n  const dd = fromBuffer(d)\n  const pp = G.mul(dd)\n  if (pp.isInfinity()) return null\n\n  const compressed = assumeCompression(__compressed)\n  return getEncoded(pp, compressed)\n}\n\nfunction pointMultiply (p, tweak, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const compressed = assumeCompression(__compressed, p)\n  const pp = decodeFrom(p)\n  const tt = fromBuffer(tweak)\n  const qq = pp.mul(tt)\n  if (qq.isInfinity()) return null\n\n  return getEncoded(qq, compressed)\n}\n\nfunction privateAdd (d, tweak) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const dd = fromBuffer(d)\n  const tt = fromBuffer(tweak)\n  const dt = toBuffer(dd.add(tt).umod(n))\n  if (!isPrivate(dt)) return null\n\n  return dt\n}\n\nfunction privateSub (d, tweak) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const dd = fromBuffer(d)\n  const tt = fromBuffer(tweak)\n  const dt = toBuffer(dd.sub(tt).umod(n))\n  if (!isPrivate(dt)) return null\n\n  return dt\n}\n\nfunction sign (hash, x) {\n  return __sign(hash, x)\n}\n\nfunction signWithEntropy (hash, x, addData) {\n  return __sign(hash, x, addData)\n}\n\nfunction __sign (hash, x, addData) {\n  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)\n  if (!isPrivate(x)) throw new TypeError(THROW_BAD_PRIVATE)\n  if (addData !== undefined && !isScalar(addData)) throw new TypeError(THROW_BAD_EXTRA_DATA)\n\n  const d = fromBuffer(x)\n  const e = fromBuffer(hash)\n\n  let r, s\n  const checkSig = function (k) {\n    const kI = fromBuffer(k)\n    const Q = G.mul(kI)\n\n    if (Q.isInfinity()) return false\n\n    r = Q.x.umod(n)\n    if (r.isZero() === 0) return false\n\n    s = kI\n      .invm(n)\n      .mul(e.add(d.mul(r)))\n      .umod(n)\n    if (s.isZero() === 0) return false\n\n    return true\n  }\n\n  deterministicGenerateK(hash, x, checkSig, isPrivate, addData)\n\n  // enforce low S values, see bip62: 'low s values in signatures'\n  if (s.cmp(nDiv2) > 0) {\n    s = n.sub(s)\n  }\n\n  const buffer = Buffer.allocUnsafe(64)\n  toBuffer(r).copy(buffer, 0)\n  toBuffer(s).copy(buffer, 32)\n  return buffer\n}\n\nfunction verify (hash, q, signature, strict) {\n  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)\n  if (!isPoint(q)) throw new TypeError(THROW_BAD_POINT)\n\n  // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1] (1, isSignature enforces '< n - 1')\n  if (!isSignature(signature)) throw new TypeError(THROW_BAD_SIGNATURE)\n\n  const Q = decodeFrom(q)\n  const r = fromBuffer(signature.slice(0, 32))\n  const s = fromBuffer(signature.slice(32, 64))\n\n  if (strict && s.cmp(nDiv2) > 0) {\n    return false\n  }\n\n  // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1] (2, enforces '> 0')\n  if (r.gtn(0) <= 0 /* || r.compareTo(n) >= 0 */) return false\n  if (s.gtn(0) <= 0 /* || s.compareTo(n) >= 0 */) return false\n\n  // 1.4.2 H = Hash(M), already done by the user\n  // 1.4.3 e = H\n  const e = fromBuffer(hash)\n\n  // Compute s^-1\n  const sInv = s.invm(n)\n\n  // 1.4.4 Compute u1 = es^−1 mod n\n  //               u2 = rs^−1 mod n\n  const u1 = e.mul(sInv).umod(n)\n  const u2 = r.mul(sInv).umod(n)\n\n  // 1.4.5 Compute R = (xR, yR)\n  //               R = u1G + u2Q\n  const R = G.mulAdd(u1, Q, u2)\n\n  // 1.4.5 (cont.) Enforce R is not at infinity\n  if (R.isInfinity()) return false\n\n  // 1.4.6 Convert the field element R.x to an integer\n  const xR = R.x\n\n  // 1.4.7 Set v = xR mod n\n  const v = xR.umod(n)\n\n  // 1.4.8 If v = r, output \"valid\", and if v != r, output \"invalid\"\n  return v.eq(r)\n}\n\nmodule.exports = {\n  isPoint,\n  isPointCompressed,\n  isPrivate,\n  pointAdd,\n  pointAddScalar,\n  pointCompress,\n  pointFromScalar,\n  pointMultiply,\n  privateAdd,\n  privateSub,\n  sign,\n  signWithEntropy,\n  verify\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}