{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.BufferReader = exports.BufferWriter = exports.cloneBuffer = exports.reverseBuffer = exports.writeUInt64LE = exports.readUInt64LE = exports.varuint = void 0;\nconst types = require('./types');\nconst {\n  typeforce\n} = types;\nconst varuint = require('varuint-bitcoin');\nexports.varuint = varuint;\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n  if (typeof value !== 'number') throw new Error('cannot write a non-number as a number');\n  if (value < 0) throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max) throw new Error('RangeError: value out of range');\n  if (Math.floor(value) !== value) throw new Error('value has a fractional component');\n}\nfunction readUInt64LE(buffer, offset) {\n  const a = buffer.readUInt32LE(offset);\n  let b = buffer.readUInt32LE(offset + 4);\n  b *= 0x100000000;\n  verifuint(b + a, 0x001fffffffffffff);\n  return b + a;\n}\nexports.readUInt64LE = readUInt64LE;\nfunction writeUInt64LE(buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff);\n  buffer.writeInt32LE(value & -1, offset);\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n  return offset + 8;\n}\nexports.writeUInt64LE = writeUInt64LE;\nfunction reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n}\nexports.reverseBuffer = reverseBuffer;\nfunction cloneBuffer(buffer) {\n  const clone = Buffer.allocUnsafe(buffer.length);\n  buffer.copy(clone);\n  return clone;\n}\nexports.cloneBuffer = cloneBuffer;\n/**\n * Helper class for serialization of bitcoin data types into a pre-allocated buffer.\n */\nclass BufferWriter {\n  static withCapacity(size) {\n    return new BufferWriter(Buffer.alloc(size));\n  }\n  constructor(buffer) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  writeUInt8(i) {\n    this.offset = this.buffer.writeUInt8(i, this.offset);\n  }\n  writeInt32(i) {\n    this.offset = this.buffer.writeInt32LE(i, this.offset);\n  }\n  writeUInt32(i) {\n    this.offset = this.buffer.writeUInt32LE(i, this.offset);\n  }\n  writeUInt64(i) {\n    this.offset = writeUInt64LE(this.buffer, i, this.offset);\n  }\n  writeVarInt(i) {\n    varuint.encode(i, this.buffer, this.offset);\n    this.offset += varuint.encode.bytes;\n  }\n  writeSlice(slice) {\n    if (this.buffer.length < this.offset + slice.length) {\n      throw new Error('Cannot write slice out of bounds');\n    }\n    this.offset += slice.copy(this.buffer, this.offset);\n  }\n  writeVarSlice(slice) {\n    this.writeVarInt(slice.length);\n    this.writeSlice(slice);\n  }\n  writeVector(vector) {\n    this.writeVarInt(vector.length);\n    vector.forEach(buf => this.writeVarSlice(buf));\n  }\n  end() {\n    if (this.buffer.length === this.offset) {\n      return this.buffer;\n    }\n    throw new Error(\"buffer size \".concat(this.buffer.length, \", offset \").concat(this.offset));\n  }\n}\nexports.BufferWriter = BufferWriter;\n/**\n * Helper class for reading of bitcoin data types from a buffer.\n */\nclass BufferReader {\n  constructor(buffer) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  readUInt8() {\n    const result = this.buffer.readUInt8(this.offset);\n    this.offset++;\n    return result;\n  }\n  readInt32() {\n    const result = this.buffer.readInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt32() {\n    const result = this.buffer.readUInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt64() {\n    const result = readUInt64LE(this.buffer, this.offset);\n    this.offset += 8;\n    return result;\n  }\n  readVarInt() {\n    const vi = varuint.decode(this.buffer, this.offset);\n    this.offset += varuint.decode.bytes;\n    return vi;\n  }\n  readSlice(n) {\n    if (this.buffer.length < this.offset + n) {\n      throw new Error('Cannot read slice out of bounds');\n    }\n    const result = this.buffer.slice(this.offset, this.offset + n);\n    this.offset += n;\n    return result;\n  }\n  readVarSlice() {\n    return this.readSlice(this.readVarInt());\n  }\n  readVector() {\n    const count = this.readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());\n    return vector;\n  }\n}\nexports.BufferReader = BufferReader;","map":{"version":3,"names":["Object","defineProperty","exports","value","BufferReader","BufferWriter","cloneBuffer","reverseBuffer","writeUInt64LE","readUInt64LE","varuint","types","require","typeforce","verifuint","max","Error","Math","floor","buffer","offset","a","readUInt32LE","b","writeInt32LE","writeUInt32LE","length","j","tmp","i","clone","Buffer","allocUnsafe","copy","withCapacity","size","alloc","constructor","arguments","undefined","tuple","UInt32","writeUInt8","writeInt32","writeUInt32","writeUInt64","writeVarInt","encode","bytes","writeSlice","slice","writeVarSlice","writeVector","vector","forEach","buf","end","concat","readUInt8","result","readInt32","readInt32LE","readUInt32","readUInt64","readVarInt","vi","decode","readSlice","n","readVarSlice","readVector","count","push"],"sources":["/workspace/Planq-Dapps/vesting-portal/node_modules/bitcoinjs-lib/src/bufferutils.js"],"sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.BufferReader =\n  exports.BufferWriter =\n  exports.cloneBuffer =\n  exports.reverseBuffer =\n  exports.writeUInt64LE =\n  exports.readUInt64LE =\n  exports.varuint =\n    void 0;\nconst types = require('./types');\nconst { typeforce } = types;\nconst varuint = require('varuint-bitcoin');\nexports.varuint = varuint;\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n  if (typeof value !== 'number')\n    throw new Error('cannot write a non-number as a number');\n  if (value < 0)\n    throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max) throw new Error('RangeError: value out of range');\n  if (Math.floor(value) !== value)\n    throw new Error('value has a fractional component');\n}\nfunction readUInt64LE(buffer, offset) {\n  const a = buffer.readUInt32LE(offset);\n  let b = buffer.readUInt32LE(offset + 4);\n  b *= 0x100000000;\n  verifuint(b + a, 0x001fffffffffffff);\n  return b + a;\n}\nexports.readUInt64LE = readUInt64LE;\nfunction writeUInt64LE(buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff);\n  buffer.writeInt32LE(value & -1, offset);\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n  return offset + 8;\n}\nexports.writeUInt64LE = writeUInt64LE;\nfunction reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n}\nexports.reverseBuffer = reverseBuffer;\nfunction cloneBuffer(buffer) {\n  const clone = Buffer.allocUnsafe(buffer.length);\n  buffer.copy(clone);\n  return clone;\n}\nexports.cloneBuffer = cloneBuffer;\n/**\n * Helper class for serialization of bitcoin data types into a pre-allocated buffer.\n */\nclass BufferWriter {\n  static withCapacity(size) {\n    return new BufferWriter(Buffer.alloc(size));\n  }\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  writeUInt8(i) {\n    this.offset = this.buffer.writeUInt8(i, this.offset);\n  }\n  writeInt32(i) {\n    this.offset = this.buffer.writeInt32LE(i, this.offset);\n  }\n  writeUInt32(i) {\n    this.offset = this.buffer.writeUInt32LE(i, this.offset);\n  }\n  writeUInt64(i) {\n    this.offset = writeUInt64LE(this.buffer, i, this.offset);\n  }\n  writeVarInt(i) {\n    varuint.encode(i, this.buffer, this.offset);\n    this.offset += varuint.encode.bytes;\n  }\n  writeSlice(slice) {\n    if (this.buffer.length < this.offset + slice.length) {\n      throw new Error('Cannot write slice out of bounds');\n    }\n    this.offset += slice.copy(this.buffer, this.offset);\n  }\n  writeVarSlice(slice) {\n    this.writeVarInt(slice.length);\n    this.writeSlice(slice);\n  }\n  writeVector(vector) {\n    this.writeVarInt(vector.length);\n    vector.forEach(buf => this.writeVarSlice(buf));\n  }\n  end() {\n    if (this.buffer.length === this.offset) {\n      return this.buffer;\n    }\n    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);\n  }\n}\nexports.BufferWriter = BufferWriter;\n/**\n * Helper class for reading of bitcoin data types from a buffer.\n */\nclass BufferReader {\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  readUInt8() {\n    const result = this.buffer.readUInt8(this.offset);\n    this.offset++;\n    return result;\n  }\n  readInt32() {\n    const result = this.buffer.readInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt32() {\n    const result = this.buffer.readUInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt64() {\n    const result = readUInt64LE(this.buffer, this.offset);\n    this.offset += 8;\n    return result;\n  }\n  readVarInt() {\n    const vi = varuint.decode(this.buffer, this.offset);\n    this.offset += varuint.decode.bytes;\n    return vi;\n  }\n  readSlice(n) {\n    if (this.buffer.length < this.offset + n) {\n      throw new Error('Cannot read slice out of bounds');\n    }\n    const result = this.buffer.slice(this.offset, this.offset + n);\n    this.offset += n;\n    return result;\n  }\n  readVarSlice() {\n    return this.readSlice(this.readVarInt());\n  }\n  readVector() {\n    const count = this.readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());\n    return vector;\n  }\n}\nexports.BufferReader = BufferReader;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}