{"ast":null,"code":"/*!\n * URI.js - Mutating URLs\n * URI Template Support - http://tools.ietf.org/html/rfc6570\n *\n * Version: 1.19.11\n *\n * Author: Rodney Rehm\n * Web: http://medialize.github.io/URI.js/\n *\n * Licensed under\n *   MIT License http://www.opensource.org/licenses/mit-license\n *\n */\n(function (root, factory) {\n  'use strict';\n\n  // https://github.com/umdjs/umd/blob/master/returnExports.js\n  if (typeof module === 'object' && module.exports) {\n    // Node\n    module.exports = factory(require('./URI'));\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['./URI'], factory);\n  } else {\n    // Browser globals (root is window)\n    root.URITemplate = factory(root.URI, root);\n  }\n})(this, function (URI, root) {\n  'use strict';\n\n  // FIXME: v2.0.0 renamce non-camelCase properties to uppercase\n  /*jshint camelcase: false */\n\n  // save current URITemplate variable, if any\n  var _URITemplate = root && root.URITemplate;\n  var hasOwn = Object.prototype.hasOwnProperty;\n  function URITemplate(expression) {\n    // serve from cache where possible\n    if (URITemplate._cache[expression]) {\n      return URITemplate._cache[expression];\n    }\n\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof URITemplate)) {\n      return new URITemplate(expression);\n    }\n    this.expression = expression;\n    URITemplate._cache[expression] = this;\n    return this;\n  }\n  function Data(data) {\n    this.data = data;\n    this.cache = {};\n  }\n  var p = URITemplate.prototype;\n  // list of operators and their defined options\n  var operators = {\n    // Simple string expansion\n    '': {\n      prefix: '',\n      separator: ',',\n      named: false,\n      empty_name_separator: false,\n      encode: 'encode'\n    },\n    // Reserved character strings\n    '+': {\n      prefix: '',\n      separator: ',',\n      named: false,\n      empty_name_separator: false,\n      encode: 'encodeReserved'\n    },\n    // Fragment identifiers prefixed by '#'\n    '#': {\n      prefix: '#',\n      separator: ',',\n      named: false,\n      empty_name_separator: false,\n      encode: 'encodeReserved'\n    },\n    // Name labels or extensions prefixed by '.'\n    '.': {\n      prefix: '.',\n      separator: '.',\n      named: false,\n      empty_name_separator: false,\n      encode: 'encode'\n    },\n    // Path segments prefixed by '/'\n    '/': {\n      prefix: '/',\n      separator: '/',\n      named: false,\n      empty_name_separator: false,\n      encode: 'encode'\n    },\n    // Path parameter name or name=value pairs prefixed by ';'\n    ';': {\n      prefix: ';',\n      separator: ';',\n      named: true,\n      empty_name_separator: false,\n      encode: 'encode'\n    },\n    // Query component beginning with '?' and consisting\n    // of name=value pairs separated by '&'; an\n    '?': {\n      prefix: '?',\n      separator: '&',\n      named: true,\n      empty_name_separator: true,\n      encode: 'encode'\n    },\n    // Continuation of query-style &name=value pairs\n    // within a literal query component.\n    '&': {\n      prefix: '&',\n      separator: '&',\n      named: true,\n      empty_name_separator: true,\n      encode: 'encode'\n    }\n\n    // The operator characters equals (\"=\"), comma (\",\"), exclamation (\"!\"),\n    // at sign (\"@\"), and pipe (\"|\") are reserved for future extensions.\n  };\n\n  // storage for already parsed templates\n  URITemplate._cache = {};\n  // pattern to identify expressions [operator, variable-list] in template\n  URITemplate.EXPRESSION_PATTERN = /\\{([^a-zA-Z0-9%_]?)([^\\}]+)(\\}|$)/g;\n  // pattern to identify variables [name, explode, maxlength] in variable-list\n  URITemplate.VARIABLE_PATTERN = /^([^*:.](?:\\.?[^*:.])*)((\\*)|:(\\d+))?$/;\n  // pattern to verify variable name integrity\n  URITemplate.VARIABLE_NAME_PATTERN = /[^a-zA-Z0-9%_.]/;\n  // pattern to verify literal integrity\n  URITemplate.LITERAL_PATTERN = /[<>{}\"`^| \\\\]/;\n\n  // expand parsed expression (expression, not template!)\n  URITemplate.expand = function (expression, data, opts) {\n    // container for defined options for the given operator\n    var options = operators[expression.operator];\n    // expansion type (include keys or not)\n    var type = options.named ? 'Named' : 'Unnamed';\n    // list of variables within the expression\n    var variables = expression.variables;\n    // result buffer for evaluating the expression\n    var buffer = [];\n    var d, variable, i;\n    for (i = 0; variable = variables[i]; i++) {\n      // fetch simplified data source\n      d = data.get(variable.name);\n      if (d.type === 0 && opts && opts.strict) {\n        throw new Error('Missing expansion value for variable \"' + variable.name + '\"');\n      }\n      if (!d.val.length) {\n        if (d.type) {\n          // empty variables (empty string)\n          // still lead to a separator being appended!\n          buffer.push('');\n        }\n        // no data, no action\n        continue;\n      }\n      if (d.type > 1 && variable.maxlength) {\n        // composite variable cannot specify maxlength\n        throw new Error('Invalid expression: Prefix modifier not applicable to variable \"' + variable.name + '\"');\n      }\n\n      // expand the given variable\n      buffer.push(URITemplate['expand' + type](d, options, variable.explode, variable.explode && options.separator || ',', variable.maxlength, variable.name));\n    }\n    if (buffer.length) {\n      return options.prefix + buffer.join(options.separator);\n    } else {\n      // prefix is not prepended for empty expressions\n      return '';\n    }\n  };\n  // expand a named variable\n  URITemplate.expandNamed = function (d, options, explode, separator, length, name) {\n    // variable result buffer\n    var result = '';\n    // peformance crap\n    var encode = options.encode;\n    var empty_name_separator = options.empty_name_separator;\n    // flag noting if values are already encoded\n    var _encode = !d[encode].length;\n    // key for named expansion\n    var _name = d.type === 2 ? '' : URI[encode](name);\n    var _value, i, l;\n\n    // for each found value\n    for (i = 0, l = d.val.length; i < l; i++) {\n      if (length) {\n        // maxlength must be determined before encoding can happen\n        _value = URI[encode](d.val[i][1].substring(0, length));\n        if (d.type === 2) {\n          // apply maxlength to keys of objects as well\n          _name = URI[encode](d.val[i][0].substring(0, length));\n        }\n      } else if (_encode) {\n        // encode value\n        _value = URI[encode](d.val[i][1]);\n        if (d.type === 2) {\n          // encode name and cache encoded value\n          _name = URI[encode](d.val[i][0]);\n          d[encode].push([_name, _value]);\n        } else {\n          // cache encoded value\n          d[encode].push([undefined, _value]);\n        }\n      } else {\n        // values are already encoded and can be pulled from cache\n        _value = d[encode][i][1];\n        if (d.type === 2) {\n          _name = d[encode][i][0];\n        }\n      }\n      if (result) {\n        // unless we're the first value, prepend the separator\n        result += separator;\n      }\n      if (!explode) {\n        if (!i) {\n          // first element, so prepend variable name\n          result += URI[encode](name) + (empty_name_separator || _value ? '=' : '');\n        }\n        if (d.type === 2) {\n          // without explode-modifier, keys of objects are returned comma-separated\n          result += _name + ',';\n        }\n        result += _value;\n      } else {\n        // only add the = if it is either default (?&) or there actually is a value (;)\n        result += _name + (empty_name_separator || _value ? '=' : '') + _value;\n      }\n    }\n    return result;\n  };\n  // expand an unnamed variable\n  URITemplate.expandUnnamed = function (d, options, explode, separator, length) {\n    // variable result buffer\n    var result = '';\n    // performance crap\n    var encode = options.encode;\n    var empty_name_separator = options.empty_name_separator;\n    // flag noting if values are already encoded\n    var _encode = !d[encode].length;\n    var _name, _value, i, l;\n\n    // for each found value\n    for (i = 0, l = d.val.length; i < l; i++) {\n      if (length) {\n        // maxlength must be determined before encoding can happen\n        _value = URI[encode](d.val[i][1].substring(0, length));\n      } else if (_encode) {\n        // encode and cache value\n        _value = URI[encode](d.val[i][1]);\n        d[encode].push([d.type === 2 ? URI[encode](d.val[i][0]) : undefined, _value]);\n      } else {\n        // value already encoded, pull from cache\n        _value = d[encode][i][1];\n      }\n      if (result) {\n        // unless we're the first value, prepend the separator\n        result += separator;\n      }\n      if (d.type === 2) {\n        if (length) {\n          // maxlength also applies to keys of objects\n          _name = URI[encode](d.val[i][0].substring(0, length));\n        } else {\n          // at this point the name must already be encoded\n          _name = d[encode][i][0];\n        }\n        result += _name;\n        if (explode) {\n          // explode-modifier separates name and value by \"=\"\n          result += empty_name_separator || _value ? '=' : '';\n        } else {\n          // no explode-modifier separates name and value by \",\"\n          result += ',';\n        }\n      }\n      result += _value;\n    }\n    return result;\n  };\n  URITemplate.noConflict = function () {\n    if (root.URITemplate === URITemplate) {\n      root.URITemplate = _URITemplate;\n    }\n    return URITemplate;\n  };\n\n  // expand template through given data map\n  p.expand = function (data, opts) {\n    var result = '';\n    if (!this.parts || !this.parts.length) {\n      // lazilyy parse the template\n      this.parse();\n    }\n    if (!(data instanceof Data)) {\n      // make given data available through the\n      // optimized data handling thingie\n      data = new Data(data);\n    }\n    for (var i = 0, l = this.parts.length; i < l; i++) {\n      /*jshint laxbreak: true */\n      result += typeof this.parts[i] === 'string'\n      // literal string\n      ? this.parts[i]\n      // expression\n      : URITemplate.expand(this.parts[i], data, opts);\n      /*jshint laxbreak: false */\n    }\n\n    return result;\n  };\n  // parse template into action tokens\n  p.parse = function () {\n    // performance crap\n    var expression = this.expression;\n    var ePattern = URITemplate.EXPRESSION_PATTERN;\n    var vPattern = URITemplate.VARIABLE_PATTERN;\n    var nPattern = URITemplate.VARIABLE_NAME_PATTERN;\n    var lPattern = URITemplate.LITERAL_PATTERN;\n    // token result buffer\n    var parts = [];\n    // position within source template\n    var pos = 0;\n    var variables, eMatch, vMatch;\n    var checkLiteral = function (literal) {\n      if (literal.match(lPattern)) {\n        throw new Error('Invalid Literal \"' + literal + '\"');\n      }\n      return literal;\n    };\n\n    // RegExp is shared accross all templates,\n    // which requires a manual reset\n    ePattern.lastIndex = 0;\n    // I don't like while(foo = bar()) loops,\n    // to make things simpler I go while(true) and break when required\n    while (true) {\n      eMatch = ePattern.exec(expression);\n      if (eMatch === null) {\n        // push trailing literal\n        parts.push(checkLiteral(expression.substring(pos)));\n        break;\n      } else {\n        // push leading literal\n        parts.push(checkLiteral(expression.substring(pos, eMatch.index)));\n        pos = eMatch.index + eMatch[0].length;\n      }\n      if (!operators[eMatch[1]]) {\n        throw new Error('Unknown Operator \"' + eMatch[1] + '\" in \"' + eMatch[0] + '\"');\n      } else if (!eMatch[3]) {\n        throw new Error('Unclosed Expression \"' + eMatch[0] + '\"');\n      }\n\n      // parse variable-list\n      variables = eMatch[2].split(',');\n      for (var i = 0, l = variables.length; i < l; i++) {\n        vMatch = variables[i].match(vPattern);\n        if (vMatch === null) {\n          throw new Error('Invalid Variable \"' + variables[i] + '\" in \"' + eMatch[0] + '\"');\n        } else if (vMatch[1].match(nPattern)) {\n          throw new Error('Invalid Variable Name \"' + vMatch[1] + '\" in \"' + eMatch[0] + '\"');\n        }\n        variables[i] = {\n          name: vMatch[1],\n          explode: !!vMatch[3],\n          maxlength: vMatch[4] && parseInt(vMatch[4], 10)\n        };\n      }\n      if (!variables.length) {\n        throw new Error('Expression Missing Variable(s) \"' + eMatch[0] + '\"');\n      }\n      parts.push({\n        expression: eMatch[0],\n        operator: eMatch[1],\n        variables: variables\n      });\n    }\n    if (!parts.length) {\n      // template doesn't contain any expressions\n      // so it is a simple literal string\n      // this probably should fire a warning or something?\n      parts.push(checkLiteral(expression));\n    }\n    this.parts = parts;\n    return this;\n  };\n\n  // simplify data structures\n  Data.prototype.get = function (key) {\n    // performance crap\n    var data = this.data;\n    // cache for processed data-point\n    var d = {\n      // type of data 0: undefined/null, 1: string, 2: object, 3: array\n      type: 0,\n      // original values (except undefined/null)\n      val: [],\n      // cache for encoded values (only for non-maxlength expansion)\n      encode: [],\n      encodeReserved: []\n    };\n    var i, l, value;\n    if (this.cache[key] !== undefined) {\n      // we've already processed this key\n      return this.cache[key];\n    }\n    this.cache[key] = d;\n    if (String(Object.prototype.toString.call(data)) === '[object Function]') {\n      // data itself is a callback (global callback)\n      value = data(key);\n    } else if (String(Object.prototype.toString.call(data[key])) === '[object Function]') {\n      // data is a map of callbacks (local callback)\n      value = data[key](key);\n    } else {\n      // data is a map of data\n      value = data[key];\n    }\n\n    // generalize input into [ [name1, value1], [name2, value2], … ]\n    // so expansion has to deal with a single data structure only\n    if (value === undefined || value === null) {\n      // undefined and null values are to be ignored completely\n      return d;\n    } else if (String(Object.prototype.toString.call(value)) === '[object Array]') {\n      for (i = 0, l = value.length; i < l; i++) {\n        if (value[i] !== undefined && value[i] !== null) {\n          // arrays don't have names\n          d.val.push([undefined, String(value[i])]);\n        }\n      }\n      if (d.val.length) {\n        // only treat non-empty arrays as arrays\n        d.type = 3; // array\n      }\n    } else if (String(Object.prototype.toString.call(value)) === '[object Object]') {\n      for (i in value) {\n        if (hasOwn.call(value, i) && value[i] !== undefined && value[i] !== null) {\n          // objects have keys, remember them for named expansion\n          d.val.push([i, String(value[i])]);\n        }\n      }\n      if (d.val.length) {\n        // only treat non-empty objects as objects\n        d.type = 2; // object\n      }\n    } else {\n      d.type = 1; // primitive string (could've been string, number, boolean and objects with a toString())\n      // arrays don't have names\n      d.val.push([undefined, String(value)]);\n    }\n    return d;\n  };\n\n  // hook into URI for fluid access\n  URI.expand = function (expression, data) {\n    var template = new URITemplate(expression);\n    var expansion = template.expand(data);\n    return new URI(expansion);\n  };\n  return URITemplate;\n});","map":{"version":3,"names":["root","factory","module","exports","require","define","amd","URITemplate","URI","_URITemplate","hasOwn","Object","prototype","hasOwnProperty","expression","_cache","Data","data","cache","p","operators","prefix","separator","named","empty_name_separator","encode","EXPRESSION_PATTERN","VARIABLE_PATTERN","VARIABLE_NAME_PATTERN","LITERAL_PATTERN","expand","opts","options","operator","type","variables","buffer","d","variable","i","get","name","strict","Error","val","length","push","maxlength","explode","join","expandNamed","result","_encode","_name","_value","l","substring","undefined","expandUnnamed","noConflict","parts","parse","ePattern","vPattern","nPattern","lPattern","pos","eMatch","vMatch","checkLiteral","literal","match","lastIndex","exec","index","split","parseInt","key","encodeReserved","value","String","toString","call","template","expansion"],"sources":["/workspace/Planq-Dapps/vesting-portal/node_modules/urijs/src/URITemplate.js"],"sourcesContent":["/*!\n * URI.js - Mutating URLs\n * URI Template Support - http://tools.ietf.org/html/rfc6570\n *\n * Version: 1.19.11\n *\n * Author: Rodney Rehm\n * Web: http://medialize.github.io/URI.js/\n *\n * Licensed under\n *   MIT License http://www.opensource.org/licenses/mit-license\n *\n */\n(function (root, factory) {\n  'use strict';\n  // https://github.com/umdjs/umd/blob/master/returnExports.js\n  if (typeof module === 'object' && module.exports) {\n    // Node\n    module.exports = factory(require('./URI'));\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['./URI'], factory);\n  } else {\n    // Browser globals (root is window)\n    root.URITemplate = factory(root.URI, root);\n  }\n}(this, function (URI, root) {\n  'use strict';\n  // FIXME: v2.0.0 renamce non-camelCase properties to uppercase\n  /*jshint camelcase: false */\n\n  // save current URITemplate variable, if any\n  var _URITemplate = root && root.URITemplate;\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n  function URITemplate(expression) {\n    // serve from cache where possible\n    if (URITemplate._cache[expression]) {\n      return URITemplate._cache[expression];\n    }\n\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof URITemplate)) {\n      return new URITemplate(expression);\n    }\n\n    this.expression = expression;\n    URITemplate._cache[expression] = this;\n    return this;\n  }\n\n  function Data(data) {\n    this.data = data;\n    this.cache = {};\n  }\n\n  var p = URITemplate.prototype;\n  // list of operators and their defined options\n  var operators = {\n    // Simple string expansion\n    '' : {\n      prefix: '',\n      separator: ',',\n      named: false,\n      empty_name_separator: false,\n      encode : 'encode'\n    },\n    // Reserved character strings\n    '+' : {\n      prefix: '',\n      separator: ',',\n      named: false,\n      empty_name_separator: false,\n      encode : 'encodeReserved'\n    },\n    // Fragment identifiers prefixed by '#'\n    '#' : {\n      prefix: '#',\n      separator: ',',\n      named: false,\n      empty_name_separator: false,\n      encode : 'encodeReserved'\n    },\n    // Name labels or extensions prefixed by '.'\n    '.' : {\n      prefix: '.',\n      separator: '.',\n      named: false,\n      empty_name_separator: false,\n      encode : 'encode'\n    },\n    // Path segments prefixed by '/'\n    '/' : {\n      prefix: '/',\n      separator: '/',\n      named: false,\n      empty_name_separator: false,\n      encode : 'encode'\n    },\n    // Path parameter name or name=value pairs prefixed by ';'\n    ';' : {\n      prefix: ';',\n      separator: ';',\n      named: true,\n      empty_name_separator: false,\n      encode : 'encode'\n    },\n    // Query component beginning with '?' and consisting\n    // of name=value pairs separated by '&'; an\n    '?' : {\n      prefix: '?',\n      separator: '&',\n      named: true,\n      empty_name_separator: true,\n      encode : 'encode'\n    },\n    // Continuation of query-style &name=value pairs\n    // within a literal query component.\n    '&' : {\n      prefix: '&',\n      separator: '&',\n      named: true,\n      empty_name_separator: true,\n      encode : 'encode'\n    }\n\n    // The operator characters equals (\"=\"), comma (\",\"), exclamation (\"!\"),\n    // at sign (\"@\"), and pipe (\"|\") are reserved for future extensions.\n  };\n\n  // storage for already parsed templates\n  URITemplate._cache = {};\n  // pattern to identify expressions [operator, variable-list] in template\n  URITemplate.EXPRESSION_PATTERN = /\\{([^a-zA-Z0-9%_]?)([^\\}]+)(\\}|$)/g;\n  // pattern to identify variables [name, explode, maxlength] in variable-list\n  URITemplate.VARIABLE_PATTERN = /^([^*:.](?:\\.?[^*:.])*)((\\*)|:(\\d+))?$/;\n  // pattern to verify variable name integrity\n  URITemplate.VARIABLE_NAME_PATTERN = /[^a-zA-Z0-9%_.]/;\n  // pattern to verify literal integrity\n  URITemplate.LITERAL_PATTERN = /[<>{}\"`^| \\\\]/;\n\n  // expand parsed expression (expression, not template!)\n  URITemplate.expand = function(expression, data, opts) {\n    // container for defined options for the given operator\n    var options = operators[expression.operator];\n    // expansion type (include keys or not)\n    var type = options.named ? 'Named' : 'Unnamed';\n    // list of variables within the expression\n    var variables = expression.variables;\n    // result buffer for evaluating the expression\n    var buffer = [];\n    var d, variable, i;\n\n    for (i = 0; (variable = variables[i]); i++) {\n      // fetch simplified data source\n      d = data.get(variable.name);\n      if (d.type === 0 && opts && opts.strict) {\n          throw new Error('Missing expansion value for variable \"' + variable.name + '\"');\n      }\n      if (!d.val.length) {\n        if (d.type) {\n          // empty variables (empty string)\n          // still lead to a separator being appended!\n          buffer.push('');\n        }\n        // no data, no action\n        continue;\n      }\n\n      if (d.type > 1 && variable.maxlength) {\n        // composite variable cannot specify maxlength\n        throw new Error('Invalid expression: Prefix modifier not applicable to variable \"' + variable.name + '\"');\n      }\n\n      // expand the given variable\n      buffer.push(URITemplate['expand' + type](\n        d,\n        options,\n        variable.explode,\n        variable.explode && options.separator || ',',\n        variable.maxlength,\n        variable.name\n      ));\n    }\n\n    if (buffer.length) {\n      return options.prefix + buffer.join(options.separator);\n    } else {\n      // prefix is not prepended for empty expressions\n      return '';\n    }\n  };\n  // expand a named variable\n  URITemplate.expandNamed = function(d, options, explode, separator, length, name) {\n    // variable result buffer\n    var result = '';\n    // peformance crap\n    var encode = options.encode;\n    var empty_name_separator = options.empty_name_separator;\n    // flag noting if values are already encoded\n    var _encode = !d[encode].length;\n    // key for named expansion\n    var _name = d.type === 2 ? '': URI[encode](name);\n    var _value, i, l;\n\n    // for each found value\n    for (i = 0, l = d.val.length; i < l; i++) {\n      if (length) {\n        // maxlength must be determined before encoding can happen\n        _value = URI[encode](d.val[i][1].substring(0, length));\n        if (d.type === 2) {\n          // apply maxlength to keys of objects as well\n          _name = URI[encode](d.val[i][0].substring(0, length));\n        }\n      } else if (_encode) {\n        // encode value\n        _value = URI[encode](d.val[i][1]);\n        if (d.type === 2) {\n          // encode name and cache encoded value\n          _name = URI[encode](d.val[i][0]);\n          d[encode].push([_name, _value]);\n        } else {\n          // cache encoded value\n          d[encode].push([undefined, _value]);\n        }\n      } else {\n        // values are already encoded and can be pulled from cache\n        _value = d[encode][i][1];\n        if (d.type === 2) {\n          _name = d[encode][i][0];\n        }\n      }\n\n      if (result) {\n        // unless we're the first value, prepend the separator\n        result += separator;\n      }\n\n      if (!explode) {\n        if (!i) {\n          // first element, so prepend variable name\n          result += URI[encode](name) + (empty_name_separator || _value ? '=' : '');\n        }\n\n        if (d.type === 2) {\n          // without explode-modifier, keys of objects are returned comma-separated\n          result += _name + ',';\n        }\n\n        result += _value;\n      } else {\n        // only add the = if it is either default (?&) or there actually is a value (;)\n        result += _name + (empty_name_separator || _value ? '=' : '') + _value;\n      }\n    }\n\n    return result;\n  };\n  // expand an unnamed variable\n  URITemplate.expandUnnamed = function(d, options, explode, separator, length) {\n    // variable result buffer\n    var result = '';\n    // performance crap\n    var encode = options.encode;\n    var empty_name_separator = options.empty_name_separator;\n    // flag noting if values are already encoded\n    var _encode = !d[encode].length;\n    var _name, _value, i, l;\n\n    // for each found value\n    for (i = 0, l = d.val.length; i < l; i++) {\n      if (length) {\n        // maxlength must be determined before encoding can happen\n        _value = URI[encode](d.val[i][1].substring(0, length));\n      } else if (_encode) {\n        // encode and cache value\n        _value = URI[encode](d.val[i][1]);\n        d[encode].push([\n          d.type === 2 ? URI[encode](d.val[i][0]) : undefined,\n          _value\n        ]);\n      } else {\n        // value already encoded, pull from cache\n        _value = d[encode][i][1];\n      }\n\n      if (result) {\n        // unless we're the first value, prepend the separator\n        result += separator;\n      }\n\n      if (d.type === 2) {\n        if (length) {\n          // maxlength also applies to keys of objects\n          _name = URI[encode](d.val[i][0].substring(0, length));\n        } else {\n          // at this point the name must already be encoded\n          _name = d[encode][i][0];\n        }\n\n        result += _name;\n        if (explode) {\n          // explode-modifier separates name and value by \"=\"\n          result += (empty_name_separator || _value ? '=' : '');\n        } else {\n          // no explode-modifier separates name and value by \",\"\n          result += ',';\n        }\n      }\n\n      result += _value;\n    }\n\n    return result;\n  };\n\n  URITemplate.noConflict = function() {\n    if (root.URITemplate === URITemplate) {\n      root.URITemplate = _URITemplate;\n    }\n\n    return URITemplate;\n  };\n\n  // expand template through given data map\n  p.expand = function(data, opts) {\n    var result = '';\n\n    if (!this.parts || !this.parts.length) {\n      // lazilyy parse the template\n      this.parse();\n    }\n\n    if (!(data instanceof Data)) {\n      // make given data available through the\n      // optimized data handling thingie\n      data = new Data(data);\n    }\n\n    for (var i = 0, l = this.parts.length; i < l; i++) {\n      /*jshint laxbreak: true */\n      result += typeof this.parts[i] === 'string'\n        // literal string\n        ? this.parts[i]\n        // expression\n        : URITemplate.expand(this.parts[i], data, opts);\n      /*jshint laxbreak: false */\n    }\n\n    return result;\n  };\n  // parse template into action tokens\n  p.parse = function() {\n    // performance crap\n    var expression = this.expression;\n    var ePattern = URITemplate.EXPRESSION_PATTERN;\n    var vPattern = URITemplate.VARIABLE_PATTERN;\n    var nPattern = URITemplate.VARIABLE_NAME_PATTERN;\n    var lPattern = URITemplate.LITERAL_PATTERN;\n    // token result buffer\n    var parts = [];\n      // position within source template\n    var pos = 0;\n    var variables, eMatch, vMatch;\n\n    var checkLiteral = function(literal) {\n      if (literal.match(lPattern)) {\n        throw new Error('Invalid Literal \"' + literal + '\"');\n      }\n      return literal;\n    };\n\n    // RegExp is shared accross all templates,\n    // which requires a manual reset\n    ePattern.lastIndex = 0;\n    // I don't like while(foo = bar()) loops,\n    // to make things simpler I go while(true) and break when required\n    while (true) {\n      eMatch = ePattern.exec(expression);\n      if (eMatch === null) {\n        // push trailing literal\n        parts.push(checkLiteral(expression.substring(pos)));\n        break;\n      } else {\n        // push leading literal\n        parts.push(checkLiteral(expression.substring(pos, eMatch.index)));\n        pos = eMatch.index + eMatch[0].length;\n      }\n\n      if (!operators[eMatch[1]]) {\n        throw new Error('Unknown Operator \"' + eMatch[1]  + '\" in \"' + eMatch[0] + '\"');\n      } else if (!eMatch[3]) {\n        throw new Error('Unclosed Expression \"' + eMatch[0]  + '\"');\n      }\n\n      // parse variable-list\n      variables = eMatch[2].split(',');\n      for (var i = 0, l = variables.length; i < l; i++) {\n        vMatch = variables[i].match(vPattern);\n        if (vMatch === null) {\n          throw new Error('Invalid Variable \"' + variables[i] + '\" in \"' + eMatch[0] + '\"');\n        } else if (vMatch[1].match(nPattern)) {\n          throw new Error('Invalid Variable Name \"' + vMatch[1] + '\" in \"' + eMatch[0] + '\"');\n        }\n\n        variables[i] = {\n          name: vMatch[1],\n          explode: !!vMatch[3],\n          maxlength: vMatch[4] && parseInt(vMatch[4], 10)\n        };\n      }\n\n      if (!variables.length) {\n        throw new Error('Expression Missing Variable(s) \"' + eMatch[0] + '\"');\n      }\n\n      parts.push({\n        expression: eMatch[0],\n        operator: eMatch[1],\n        variables: variables\n      });\n    }\n\n    if (!parts.length) {\n      // template doesn't contain any expressions\n      // so it is a simple literal string\n      // this probably should fire a warning or something?\n      parts.push(checkLiteral(expression));\n    }\n\n    this.parts = parts;\n    return this;\n  };\n\n  // simplify data structures\n  Data.prototype.get = function(key) {\n    // performance crap\n    var data = this.data;\n    // cache for processed data-point\n    var d = {\n      // type of data 0: undefined/null, 1: string, 2: object, 3: array\n      type: 0,\n      // original values (except undefined/null)\n      val: [],\n      // cache for encoded values (only for non-maxlength expansion)\n      encode: [],\n      encodeReserved: []\n    };\n    var i, l, value;\n\n    if (this.cache[key] !== undefined) {\n      // we've already processed this key\n      return this.cache[key];\n    }\n\n    this.cache[key] = d;\n\n    if (String(Object.prototype.toString.call(data)) === '[object Function]') {\n      // data itself is a callback (global callback)\n      value = data(key);\n    } else if (String(Object.prototype.toString.call(data[key])) === '[object Function]') {\n      // data is a map of callbacks (local callback)\n      value = data[key](key);\n    } else {\n      // data is a map of data\n      value = data[key];\n    }\n\n    // generalize input into [ [name1, value1], [name2, value2], … ]\n    // so expansion has to deal with a single data structure only\n    if (value === undefined || value === null) {\n      // undefined and null values are to be ignored completely\n      return d;\n    } else if (String(Object.prototype.toString.call(value)) === '[object Array]') {\n      for (i = 0, l = value.length; i < l; i++) {\n        if (value[i] !== undefined && value[i] !== null) {\n          // arrays don't have names\n          d.val.push([undefined, String(value[i])]);\n        }\n      }\n\n      if (d.val.length) {\n        // only treat non-empty arrays as arrays\n        d.type = 3; // array\n      }\n    } else if (String(Object.prototype.toString.call(value)) === '[object Object]') {\n      for (i in value) {\n        if (hasOwn.call(value, i) && value[i] !== undefined && value[i] !== null) {\n          // objects have keys, remember them for named expansion\n          d.val.push([i, String(value[i])]);\n        }\n      }\n\n      if (d.val.length) {\n        // only treat non-empty objects as objects\n        d.type = 2; // object\n      }\n    } else {\n      d.type = 1; // primitive string (could've been string, number, boolean and objects with a toString())\n      // arrays don't have names\n      d.val.push([undefined, String(value)]);\n    }\n\n    return d;\n  };\n\n  // hook into URI for fluid access\n  URI.expand = function(expression, data) {\n    var template = new URITemplate(expression);\n    var expansion = template.expand(data);\n\n    return new URI(expansion);\n  };\n\n  return URITemplate;\n}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}