{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.Transaction = void 0;\nconst bufferutils_1 = require('./bufferutils');\nconst bcrypto = require('./crypto');\nconst bscript = require('./script');\nconst script_1 = require('./script');\nconst types = require('./types');\nconst {\n  typeforce\n} = types;\nfunction varSliceSize(someScript) {\n  const length = someScript.length;\n  return bufferutils_1.varuint.encodingLength(length) + length;\n}\nfunction vectorSize(someVector) {\n  const length = someVector.length;\n  return bufferutils_1.varuint.encodingLength(length) + someVector.reduce((sum, witness) => {\n    return sum + varSliceSize(witness);\n  }, 0);\n}\nconst EMPTY_BUFFER = Buffer.allocUnsafe(0);\nconst EMPTY_WITNESS = [];\nconst ZERO = Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex');\nconst ONE = Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex');\nconst VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');\nconst BLANK_OUTPUT = {\n  script: EMPTY_BUFFER,\n  valueBuffer: VALUE_UINT64_MAX\n};\nfunction isOutput(out) {\n  return out.value !== undefined;\n}\nclass Transaction {\n  constructor() {\n    this.version = 1;\n    this.locktime = 0;\n    this.ins = [];\n    this.outs = [];\n  }\n  static fromBuffer(buffer, _NO_STRICT) {\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const tx = new Transaction();\n    tx.version = bufferReader.readInt32();\n    const marker = bufferReader.readUInt8();\n    const flag = bufferReader.readUInt8();\n    let hasWitnesses = false;\n    if (marker === Transaction.ADVANCED_TRANSACTION_MARKER && flag === Transaction.ADVANCED_TRANSACTION_FLAG) {\n      hasWitnesses = true;\n    } else {\n      bufferReader.offset -= 2;\n    }\n    const vinLen = bufferReader.readVarInt();\n    for (let i = 0; i < vinLen; ++i) {\n      tx.ins.push({\n        hash: bufferReader.readSlice(32),\n        index: bufferReader.readUInt32(),\n        script: bufferReader.readVarSlice(),\n        sequence: bufferReader.readUInt32(),\n        witness: EMPTY_WITNESS\n      });\n    }\n    const voutLen = bufferReader.readVarInt();\n    for (let i = 0; i < voutLen; ++i) {\n      tx.outs.push({\n        value: bufferReader.readUInt64(),\n        script: bufferReader.readVarSlice()\n      });\n    }\n    if (hasWitnesses) {\n      for (let i = 0; i < vinLen; ++i) {\n        tx.ins[i].witness = bufferReader.readVector();\n      }\n      // was this pointless?\n      if (!tx.hasWitnesses()) throw new Error('Transaction has superfluous witness data');\n    }\n    tx.locktime = bufferReader.readUInt32();\n    if (_NO_STRICT) return tx;\n    if (bufferReader.offset !== buffer.length) throw new Error('Transaction has unexpected data');\n    return tx;\n  }\n  static fromHex(hex) {\n    return Transaction.fromBuffer(Buffer.from(hex, 'hex'), false);\n  }\n  static isCoinbaseHash(buffer) {\n    typeforce(types.Hash256bit, buffer);\n    for (let i = 0; i < 32; ++i) {\n      if (buffer[i] !== 0) return false;\n    }\n    return true;\n  }\n  isCoinbase() {\n    return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);\n  }\n  addInput(hash, index, sequence, scriptSig) {\n    typeforce(types.tuple(types.Hash256bit, types.UInt32, types.maybe(types.UInt32), types.maybe(types.Buffer)), arguments);\n    if (types.Null(sequence)) {\n      sequence = Transaction.DEFAULT_SEQUENCE;\n    }\n    // Add the input and return the input's index\n    return this.ins.push({\n      hash,\n      index,\n      script: scriptSig || EMPTY_BUFFER,\n      sequence: sequence,\n      witness: EMPTY_WITNESS\n    }) - 1;\n  }\n  addOutput(scriptPubKey, value) {\n    typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);\n    // Add the output and return the output's index\n    return this.outs.push({\n      script: scriptPubKey,\n      value\n    }) - 1;\n  }\n  hasWitnesses() {\n    return this.ins.some(x => {\n      return x.witness.length !== 0;\n    });\n  }\n  weight() {\n    const base = this.byteLength(false);\n    const total = this.byteLength(true);\n    return base * 3 + total;\n  }\n  virtualSize() {\n    return Math.ceil(this.weight() / 4);\n  }\n  byteLength() {\n    let _ALLOW_WITNESS = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    return (hasWitnesses ? 10 : 8) + bufferutils_1.varuint.encodingLength(this.ins.length) + bufferutils_1.varuint.encodingLength(this.outs.length) + this.ins.reduce((sum, input) => {\n      return sum + 40 + varSliceSize(input.script);\n    }, 0) + this.outs.reduce((sum, output) => {\n      return sum + 8 + varSliceSize(output.script);\n    }, 0) + (hasWitnesses ? this.ins.reduce((sum, input) => {\n      return sum + vectorSize(input.witness);\n    }, 0) : 0);\n  }\n  clone() {\n    const newTx = new Transaction();\n    newTx.version = this.version;\n    newTx.locktime = this.locktime;\n    newTx.ins = this.ins.map(txIn => {\n      return {\n        hash: txIn.hash,\n        index: txIn.index,\n        script: txIn.script,\n        sequence: txIn.sequence,\n        witness: txIn.witness\n      };\n    });\n    newTx.outs = this.outs.map(txOut => {\n      return {\n        script: txOut.script,\n        value: txOut.value\n      };\n    });\n    return newTx;\n  }\n  /**\n   * Hash transaction for signing a specific input.\n   *\n   * Bitcoin uses a different hash for each signed transaction input.\n   * This method copies the transaction, makes the necessary changes based on the\n   * hashType, and then hashes the result.\n   * This hash can then be used to sign the provided transaction input.\n   */\n  hashForSignature(inIndex, prevOutScript, hashType) {\n    typeforce(types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */types.Number), arguments);\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n    if (inIndex >= this.ins.length) return ONE;\n    // ignore OP_CODESEPARATOR\n    const ourScript = bscript.compile(bscript.decompile(prevOutScript).filter(x => {\n      return x !== script_1.OPS.OP_CODESEPARATOR;\n    }));\n    const txTmp = this.clone();\n    // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n    if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n      txTmp.outs = [];\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, i) => {\n        if (i === inIndex) return;\n        input.sequence = 0;\n      });\n      // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n      if (inIndex >= this.outs.length) return ONE;\n      // truncate outputs after\n      txTmp.outs.length = inIndex + 1;\n      // \"blank\" outputs before\n      for (let i = 0; i < inIndex; i++) {\n        txTmp.outs[i] = BLANK_OUTPUT;\n      }\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, y) => {\n        if (y === inIndex) return;\n        input.sequence = 0;\n      });\n    }\n    // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n    if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n      txTmp.ins = [txTmp.ins[inIndex]];\n      txTmp.ins[0].script = ourScript;\n      // SIGHASH_ALL: only ignore input scripts\n    } else {\n      // \"blank\" others input scripts\n      txTmp.ins.forEach(input => {\n        input.script = EMPTY_BUFFER;\n      });\n      txTmp.ins[inIndex].script = ourScript;\n    }\n    // serialize and hash\n    const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);\n    buffer.writeInt32LE(hashType, buffer.length - 4);\n    txTmp.__toBuffer(buffer, 0, false);\n    return bcrypto.hash256(buffer);\n  }\n  hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex) {\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#common-signature-message\n    typeforce(types.tuple(types.UInt32, typeforce.arrayOf(types.Buffer), typeforce.arrayOf(types.Satoshi), types.UInt32), arguments);\n    if (values.length !== this.ins.length || prevOutScripts.length !== this.ins.length) {\n      throw new Error('Must supply prevout script and value for all inputs');\n    }\n    const outputType = hashType === Transaction.SIGHASH_DEFAULT ? Transaction.SIGHASH_ALL : hashType & Transaction.SIGHASH_OUTPUT_MASK;\n    const inputType = hashType & Transaction.SIGHASH_INPUT_MASK;\n    const isAnyoneCanPay = inputType === Transaction.SIGHASH_ANYONECANPAY;\n    const isNone = outputType === Transaction.SIGHASH_NONE;\n    const isSingle = outputType === Transaction.SIGHASH_SINGLE;\n    let hashPrevouts = EMPTY_BUFFER;\n    let hashAmounts = EMPTY_BUFFER;\n    let hashScriptPubKeys = EMPTY_BUFFER;\n    let hashSequences = EMPTY_BUFFER;\n    let hashOutputs = EMPTY_BUFFER;\n    if (!isAnyoneCanPay) {\n      let bufferWriter = bufferutils_1.BufferWriter.withCapacity(36 * this.ins.length);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.sha256(bufferWriter.end());\n      bufferWriter = bufferutils_1.BufferWriter.withCapacity(8 * this.ins.length);\n      values.forEach(value => bufferWriter.writeUInt64(value));\n      hashAmounts = bcrypto.sha256(bufferWriter.end());\n      bufferWriter = bufferutils_1.BufferWriter.withCapacity(prevOutScripts.map(varSliceSize).reduce((a, b) => a + b));\n      prevOutScripts.forEach(prevOutScript => bufferWriter.writeVarSlice(prevOutScript));\n      hashScriptPubKeys = bcrypto.sha256(bufferWriter.end());\n      bufferWriter = bufferutils_1.BufferWriter.withCapacity(4 * this.ins.length);\n      this.ins.forEach(txIn => bufferWriter.writeUInt32(txIn.sequence));\n      hashSequences = bcrypto.sha256(bufferWriter.end());\n    }\n    if (!(isNone || isSingle)) {\n      const txOutsSize = this.outs.map(output => 8 + varSliceSize(output.script)).reduce((a, b) => a + b);\n      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(txOutsSize);\n      this.outs.forEach(out => {\n        bufferWriter.writeUInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.sha256(bufferWriter.end());\n    } else if (isSingle && inIndex < this.outs.length) {\n      const output = this.outs[inIndex];\n      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(8 + varSliceSize(output.script));\n      bufferWriter.writeUInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.sha256(bufferWriter.end());\n    }\n    const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);\n    // Length calculation from:\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-14\n    // With extension from:\n    // https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#signature-validation\n    const sigMsgSize = 174 - (isAnyoneCanPay ? 49 : 0) - (isNone ? 32 : 0) + (annex ? 32 : 0) + (leafHash ? 37 : 0);\n    const sigMsgWriter = bufferutils_1.BufferWriter.withCapacity(sigMsgSize);\n    sigMsgWriter.writeUInt8(hashType);\n    // Transaction\n    sigMsgWriter.writeInt32(this.version);\n    sigMsgWriter.writeUInt32(this.locktime);\n    sigMsgWriter.writeSlice(hashPrevouts);\n    sigMsgWriter.writeSlice(hashAmounts);\n    sigMsgWriter.writeSlice(hashScriptPubKeys);\n    sigMsgWriter.writeSlice(hashSequences);\n    if (!(isNone || isSingle)) {\n      sigMsgWriter.writeSlice(hashOutputs);\n    }\n    // Input\n    sigMsgWriter.writeUInt8(spendType);\n    if (isAnyoneCanPay) {\n      const input = this.ins[inIndex];\n      sigMsgWriter.writeSlice(input.hash);\n      sigMsgWriter.writeUInt32(input.index);\n      sigMsgWriter.writeUInt64(values[inIndex]);\n      sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);\n      sigMsgWriter.writeUInt32(input.sequence);\n    } else {\n      sigMsgWriter.writeUInt32(inIndex);\n    }\n    if (annex) {\n      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(varSliceSize(annex));\n      bufferWriter.writeVarSlice(annex);\n      sigMsgWriter.writeSlice(bcrypto.sha256(bufferWriter.end()));\n    }\n    // Output\n    if (isSingle) {\n      sigMsgWriter.writeSlice(hashOutputs);\n    }\n    // BIP342 extension\n    if (leafHash) {\n      sigMsgWriter.writeSlice(leafHash);\n      sigMsgWriter.writeUInt8(0);\n      sigMsgWriter.writeUInt32(0xffffffff);\n    }\n    // Extra zero byte because:\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-19\n    return bcrypto.taggedHash('TapSighash', Buffer.concat([Buffer.from([0x00]), sigMsgWriter.end()]));\n  }\n  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {\n    typeforce(types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32), arguments);\n    let tbuffer = Buffer.from([]);\n    let bufferWriter;\n    let hashOutputs = ZERO;\n    let hashPrevouts = ZERO;\n    let hashSequence = ZERO;\n    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n      tbuffer = Buffer.allocUnsafe(36 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.hash256(tbuffer);\n    }\n    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY) && (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE && (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n      tbuffer = Buffer.allocUnsafe(4 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeUInt32(txIn.sequence);\n      });\n      hashSequence = bcrypto.hash256(tbuffer);\n    }\n    if ((hashType & 0x1f) !== Transaction.SIGHASH_SINGLE && (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n      const txOutsSize = this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0);\n      tbuffer = Buffer.allocUnsafe(txOutsSize);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.outs.forEach(out => {\n        bufferWriter.writeUInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.hash256(tbuffer);\n    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {\n      const output = this.outs[inIndex];\n      tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      bufferWriter.writeUInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.hash256(tbuffer);\n    }\n    tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));\n    bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n    const input = this.ins[inIndex];\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(hashPrevouts);\n    bufferWriter.writeSlice(hashSequence);\n    bufferWriter.writeSlice(input.hash);\n    bufferWriter.writeUInt32(input.index);\n    bufferWriter.writeVarSlice(prevOutScript);\n    bufferWriter.writeUInt64(value);\n    bufferWriter.writeUInt32(input.sequence);\n    bufferWriter.writeSlice(hashOutputs);\n    bufferWriter.writeUInt32(this.locktime);\n    bufferWriter.writeUInt32(hashType);\n    return bcrypto.hash256(tbuffer);\n  }\n  getHash(forWitness) {\n    // wtxid for coinbase is always 32 bytes of 0x00\n    if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);\n    return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));\n  }\n  getId() {\n    // transaction hash's are displayed in reverse order\n    return (0, bufferutils_1.reverseBuffer)(this.getHash(false)).toString('hex');\n  }\n  toBuffer(buffer, initialOffset) {\n    return this.__toBuffer(buffer, initialOffset, true);\n  }\n  toHex() {\n    return this.toBuffer(undefined, undefined).toString('hex');\n  }\n  setInputScript(index, scriptSig) {\n    typeforce(types.tuple(types.Number, types.Buffer), arguments);\n    this.ins[index].script = scriptSig;\n  }\n  setWitness(index, witness) {\n    typeforce(types.tuple(types.Number, [types.Buffer]), arguments);\n    this.ins[index].witness = witness;\n  }\n  __toBuffer(buffer, initialOffset) {\n    let _ALLOW_WITNESS = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));\n    const bufferWriter = new bufferutils_1.BufferWriter(buffer, initialOffset || 0);\n    bufferWriter.writeInt32(this.version);\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    if (hasWitnesses) {\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n    }\n    bufferWriter.writeVarInt(this.ins.length);\n    this.ins.forEach(txIn => {\n      bufferWriter.writeSlice(txIn.hash);\n      bufferWriter.writeUInt32(txIn.index);\n      bufferWriter.writeVarSlice(txIn.script);\n      bufferWriter.writeUInt32(txIn.sequence);\n    });\n    bufferWriter.writeVarInt(this.outs.length);\n    this.outs.forEach(txOut => {\n      if (isOutput(txOut)) {\n        bufferWriter.writeUInt64(txOut.value);\n      } else {\n        bufferWriter.writeSlice(txOut.valueBuffer);\n      }\n      bufferWriter.writeVarSlice(txOut.script);\n    });\n    if (hasWitnesses) {\n      this.ins.forEach(input => {\n        bufferWriter.writeVector(input.witness);\n      });\n    }\n    bufferWriter.writeUInt32(this.locktime);\n    // avoid slicing unless necessary\n    if (initialOffset !== undefined) return buffer.slice(initialOffset, bufferWriter.offset);\n    return buffer;\n  }\n}\nexports.Transaction = Transaction;\nTransaction.DEFAULT_SEQUENCE = 0xffffffff;\nTransaction.SIGHASH_DEFAULT = 0x00;\nTransaction.SIGHASH_ALL = 0x01;\nTransaction.SIGHASH_NONE = 0x02;\nTransaction.SIGHASH_SINGLE = 0x03;\nTransaction.SIGHASH_ANYONECANPAY = 0x80;\nTransaction.SIGHASH_OUTPUT_MASK = 0x03;\nTransaction.SIGHASH_INPUT_MASK = 0x80;\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00;\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01;","map":{"version":3,"names":["Object","defineProperty","exports","value","Transaction","bufferutils_1","require","bcrypto","bscript","script_1","types","typeforce","varSliceSize","someScript","length","varuint","encodingLength","vectorSize","someVector","reduce","sum","witness","EMPTY_BUFFER","Buffer","allocUnsafe","EMPTY_WITNESS","ZERO","from","ONE","VALUE_UINT64_MAX","BLANK_OUTPUT","script","valueBuffer","isOutput","out","undefined","constructor","version","locktime","ins","outs","fromBuffer","buffer","_NO_STRICT","bufferReader","BufferReader","tx","readInt32","marker","readUInt8","flag","hasWitnesses","ADVANCED_TRANSACTION_MARKER","ADVANCED_TRANSACTION_FLAG","offset","vinLen","readVarInt","i","push","hash","readSlice","index","readUInt32","readVarSlice","sequence","voutLen","readUInt64","readVector","Error","fromHex","hex","isCoinbaseHash","Hash256bit","isCoinbase","addInput","scriptSig","tuple","UInt32","maybe","arguments","Null","DEFAULT_SEQUENCE","addOutput","scriptPubKey","Satoshi","some","x","weight","base","byteLength","total","virtualSize","Math","ceil","_ALLOW_WITNESS","input","output","clone","newTx","map","txIn","txOut","hashForSignature","inIndex","prevOutScript","hashType","Number","ourScript","compile","decompile","filter","OPS","OP_CODESEPARATOR","txTmp","SIGHASH_NONE","forEach","SIGHASH_SINGLE","y","SIGHASH_ANYONECANPAY","writeInt32LE","__toBuffer","hash256","hashForWitnessV1","prevOutScripts","values","leafHash","annex","arrayOf","outputType","SIGHASH_DEFAULT","SIGHASH_ALL","SIGHASH_OUTPUT_MASK","inputType","SIGHASH_INPUT_MASK","isAnyoneCanPay","isNone","isSingle","hashPrevouts","hashAmounts","hashScriptPubKeys","hashSequences","hashOutputs","bufferWriter","BufferWriter","withCapacity","writeSlice","writeUInt32","sha256","end","writeUInt64","a","b","writeVarSlice","txOutsSize","spendType","sigMsgSize","sigMsgWriter","writeUInt8","writeInt32","taggedHash","concat","hashForWitnessV0","tbuffer","hashSequence","getHash","forWitness","alloc","getId","reverseBuffer","toString","toBuffer","initialOffset","toHex","setInputScript","setWitness","writeVarInt","writeVector","slice"],"sources":["/workspace/Planq-Dapps/vesting-portal/node_modules/bitcoinjs-lib/src/transaction.js"],"sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.Transaction = void 0;\nconst bufferutils_1 = require('./bufferutils');\nconst bcrypto = require('./crypto');\nconst bscript = require('./script');\nconst script_1 = require('./script');\nconst types = require('./types');\nconst { typeforce } = types;\nfunction varSliceSize(someScript) {\n  const length = someScript.length;\n  return bufferutils_1.varuint.encodingLength(length) + length;\n}\nfunction vectorSize(someVector) {\n  const length = someVector.length;\n  return (\n    bufferutils_1.varuint.encodingLength(length) +\n    someVector.reduce((sum, witness) => {\n      return sum + varSliceSize(witness);\n    }, 0)\n  );\n}\nconst EMPTY_BUFFER = Buffer.allocUnsafe(0);\nconst EMPTY_WITNESS = [];\nconst ZERO = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'hex',\n);\nconst ONE = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000001',\n  'hex',\n);\nconst VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');\nconst BLANK_OUTPUT = {\n  script: EMPTY_BUFFER,\n  valueBuffer: VALUE_UINT64_MAX,\n};\nfunction isOutput(out) {\n  return out.value !== undefined;\n}\nclass Transaction {\n  constructor() {\n    this.version = 1;\n    this.locktime = 0;\n    this.ins = [];\n    this.outs = [];\n  }\n  static fromBuffer(buffer, _NO_STRICT) {\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const tx = new Transaction();\n    tx.version = bufferReader.readInt32();\n    const marker = bufferReader.readUInt8();\n    const flag = bufferReader.readUInt8();\n    let hasWitnesses = false;\n    if (\n      marker === Transaction.ADVANCED_TRANSACTION_MARKER &&\n      flag === Transaction.ADVANCED_TRANSACTION_FLAG\n    ) {\n      hasWitnesses = true;\n    } else {\n      bufferReader.offset -= 2;\n    }\n    const vinLen = bufferReader.readVarInt();\n    for (let i = 0; i < vinLen; ++i) {\n      tx.ins.push({\n        hash: bufferReader.readSlice(32),\n        index: bufferReader.readUInt32(),\n        script: bufferReader.readVarSlice(),\n        sequence: bufferReader.readUInt32(),\n        witness: EMPTY_WITNESS,\n      });\n    }\n    const voutLen = bufferReader.readVarInt();\n    for (let i = 0; i < voutLen; ++i) {\n      tx.outs.push({\n        value: bufferReader.readUInt64(),\n        script: bufferReader.readVarSlice(),\n      });\n    }\n    if (hasWitnesses) {\n      for (let i = 0; i < vinLen; ++i) {\n        tx.ins[i].witness = bufferReader.readVector();\n      }\n      // was this pointless?\n      if (!tx.hasWitnesses())\n        throw new Error('Transaction has superfluous witness data');\n    }\n    tx.locktime = bufferReader.readUInt32();\n    if (_NO_STRICT) return tx;\n    if (bufferReader.offset !== buffer.length)\n      throw new Error('Transaction has unexpected data');\n    return tx;\n  }\n  static fromHex(hex) {\n    return Transaction.fromBuffer(Buffer.from(hex, 'hex'), false);\n  }\n  static isCoinbaseHash(buffer) {\n    typeforce(types.Hash256bit, buffer);\n    for (let i = 0; i < 32; ++i) {\n      if (buffer[i] !== 0) return false;\n    }\n    return true;\n  }\n  isCoinbase() {\n    return (\n      this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)\n    );\n  }\n  addInput(hash, index, sequence, scriptSig) {\n    typeforce(\n      types.tuple(\n        types.Hash256bit,\n        types.UInt32,\n        types.maybe(types.UInt32),\n        types.maybe(types.Buffer),\n      ),\n      arguments,\n    );\n    if (types.Null(sequence)) {\n      sequence = Transaction.DEFAULT_SEQUENCE;\n    }\n    // Add the input and return the input's index\n    return (\n      this.ins.push({\n        hash,\n        index,\n        script: scriptSig || EMPTY_BUFFER,\n        sequence: sequence,\n        witness: EMPTY_WITNESS,\n      }) - 1\n    );\n  }\n  addOutput(scriptPubKey, value) {\n    typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);\n    // Add the output and return the output's index\n    return (\n      this.outs.push({\n        script: scriptPubKey,\n        value,\n      }) - 1\n    );\n  }\n  hasWitnesses() {\n    return this.ins.some(x => {\n      return x.witness.length !== 0;\n    });\n  }\n  weight() {\n    const base = this.byteLength(false);\n    const total = this.byteLength(true);\n    return base * 3 + total;\n  }\n  virtualSize() {\n    return Math.ceil(this.weight() / 4);\n  }\n  byteLength(_ALLOW_WITNESS = true) {\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    return (\n      (hasWitnesses ? 10 : 8) +\n      bufferutils_1.varuint.encodingLength(this.ins.length) +\n      bufferutils_1.varuint.encodingLength(this.outs.length) +\n      this.ins.reduce((sum, input) => {\n        return sum + 40 + varSliceSize(input.script);\n      }, 0) +\n      this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0) +\n      (hasWitnesses\n        ? this.ins.reduce((sum, input) => {\n            return sum + vectorSize(input.witness);\n          }, 0)\n        : 0)\n    );\n  }\n  clone() {\n    const newTx = new Transaction();\n    newTx.version = this.version;\n    newTx.locktime = this.locktime;\n    newTx.ins = this.ins.map(txIn => {\n      return {\n        hash: txIn.hash,\n        index: txIn.index,\n        script: txIn.script,\n        sequence: txIn.sequence,\n        witness: txIn.witness,\n      };\n    });\n    newTx.outs = this.outs.map(txOut => {\n      return {\n        script: txOut.script,\n        value: txOut.value,\n      };\n    });\n    return newTx;\n  }\n  /**\n   * Hash transaction for signing a specific input.\n   *\n   * Bitcoin uses a different hash for each signed transaction input.\n   * This method copies the transaction, makes the necessary changes based on the\n   * hashType, and then hashes the result.\n   * This hash can then be used to sign the provided transaction input.\n   */\n  hashForSignature(inIndex, prevOutScript, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number),\n      arguments,\n    );\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n    if (inIndex >= this.ins.length) return ONE;\n    // ignore OP_CODESEPARATOR\n    const ourScript = bscript.compile(\n      bscript.decompile(prevOutScript).filter(x => {\n        return x !== script_1.OPS.OP_CODESEPARATOR;\n      }),\n    );\n    const txTmp = this.clone();\n    // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n    if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n      txTmp.outs = [];\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, i) => {\n        if (i === inIndex) return;\n        input.sequence = 0;\n      });\n      // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n      if (inIndex >= this.outs.length) return ONE;\n      // truncate outputs after\n      txTmp.outs.length = inIndex + 1;\n      // \"blank\" outputs before\n      for (let i = 0; i < inIndex; i++) {\n        txTmp.outs[i] = BLANK_OUTPUT;\n      }\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, y) => {\n        if (y === inIndex) return;\n        input.sequence = 0;\n      });\n    }\n    // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n    if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n      txTmp.ins = [txTmp.ins[inIndex]];\n      txTmp.ins[0].script = ourScript;\n      // SIGHASH_ALL: only ignore input scripts\n    } else {\n      // \"blank\" others input scripts\n      txTmp.ins.forEach(input => {\n        input.script = EMPTY_BUFFER;\n      });\n      txTmp.ins[inIndex].script = ourScript;\n    }\n    // serialize and hash\n    const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);\n    buffer.writeInt32LE(hashType, buffer.length - 4);\n    txTmp.__toBuffer(buffer, 0, false);\n    return bcrypto.hash256(buffer);\n  }\n  hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex) {\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#common-signature-message\n    typeforce(\n      types.tuple(\n        types.UInt32,\n        typeforce.arrayOf(types.Buffer),\n        typeforce.arrayOf(types.Satoshi),\n        types.UInt32,\n      ),\n      arguments,\n    );\n    if (\n      values.length !== this.ins.length ||\n      prevOutScripts.length !== this.ins.length\n    ) {\n      throw new Error('Must supply prevout script and value for all inputs');\n    }\n    const outputType =\n      hashType === Transaction.SIGHASH_DEFAULT\n        ? Transaction.SIGHASH_ALL\n        : hashType & Transaction.SIGHASH_OUTPUT_MASK;\n    const inputType = hashType & Transaction.SIGHASH_INPUT_MASK;\n    const isAnyoneCanPay = inputType === Transaction.SIGHASH_ANYONECANPAY;\n    const isNone = outputType === Transaction.SIGHASH_NONE;\n    const isSingle = outputType === Transaction.SIGHASH_SINGLE;\n    let hashPrevouts = EMPTY_BUFFER;\n    let hashAmounts = EMPTY_BUFFER;\n    let hashScriptPubKeys = EMPTY_BUFFER;\n    let hashSequences = EMPTY_BUFFER;\n    let hashOutputs = EMPTY_BUFFER;\n    if (!isAnyoneCanPay) {\n      let bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        36 * this.ins.length,\n      );\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.sha256(bufferWriter.end());\n      bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        8 * this.ins.length,\n      );\n      values.forEach(value => bufferWriter.writeUInt64(value));\n      hashAmounts = bcrypto.sha256(bufferWriter.end());\n      bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        prevOutScripts.map(varSliceSize).reduce((a, b) => a + b),\n      );\n      prevOutScripts.forEach(prevOutScript =>\n        bufferWriter.writeVarSlice(prevOutScript),\n      );\n      hashScriptPubKeys = bcrypto.sha256(bufferWriter.end());\n      bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        4 * this.ins.length,\n      );\n      this.ins.forEach(txIn => bufferWriter.writeUInt32(txIn.sequence));\n      hashSequences = bcrypto.sha256(bufferWriter.end());\n    }\n    if (!(isNone || isSingle)) {\n      const txOutsSize = this.outs\n        .map(output => 8 + varSliceSize(output.script))\n        .reduce((a, b) => a + b);\n      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(txOutsSize);\n      this.outs.forEach(out => {\n        bufferWriter.writeUInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.sha256(bufferWriter.end());\n    } else if (isSingle && inIndex < this.outs.length) {\n      const output = this.outs[inIndex];\n      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        8 + varSliceSize(output.script),\n      );\n      bufferWriter.writeUInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.sha256(bufferWriter.end());\n    }\n    const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);\n    // Length calculation from:\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-14\n    // With extension from:\n    // https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#signature-validation\n    const sigMsgSize =\n      174 -\n      (isAnyoneCanPay ? 49 : 0) -\n      (isNone ? 32 : 0) +\n      (annex ? 32 : 0) +\n      (leafHash ? 37 : 0);\n    const sigMsgWriter = bufferutils_1.BufferWriter.withCapacity(sigMsgSize);\n    sigMsgWriter.writeUInt8(hashType);\n    // Transaction\n    sigMsgWriter.writeInt32(this.version);\n    sigMsgWriter.writeUInt32(this.locktime);\n    sigMsgWriter.writeSlice(hashPrevouts);\n    sigMsgWriter.writeSlice(hashAmounts);\n    sigMsgWriter.writeSlice(hashScriptPubKeys);\n    sigMsgWriter.writeSlice(hashSequences);\n    if (!(isNone || isSingle)) {\n      sigMsgWriter.writeSlice(hashOutputs);\n    }\n    // Input\n    sigMsgWriter.writeUInt8(spendType);\n    if (isAnyoneCanPay) {\n      const input = this.ins[inIndex];\n      sigMsgWriter.writeSlice(input.hash);\n      sigMsgWriter.writeUInt32(input.index);\n      sigMsgWriter.writeUInt64(values[inIndex]);\n      sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);\n      sigMsgWriter.writeUInt32(input.sequence);\n    } else {\n      sigMsgWriter.writeUInt32(inIndex);\n    }\n    if (annex) {\n      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        varSliceSize(annex),\n      );\n      bufferWriter.writeVarSlice(annex);\n      sigMsgWriter.writeSlice(bcrypto.sha256(bufferWriter.end()));\n    }\n    // Output\n    if (isSingle) {\n      sigMsgWriter.writeSlice(hashOutputs);\n    }\n    // BIP342 extension\n    if (leafHash) {\n      sigMsgWriter.writeSlice(leafHash);\n      sigMsgWriter.writeUInt8(0);\n      sigMsgWriter.writeUInt32(0xffffffff);\n    }\n    // Extra zero byte because:\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-19\n    return bcrypto.taggedHash(\n      'TapSighash',\n      Buffer.concat([Buffer.from([0x00]), sigMsgWriter.end()]),\n    );\n  }\n  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32),\n      arguments,\n    );\n    let tbuffer = Buffer.from([]);\n    let bufferWriter;\n    let hashOutputs = ZERO;\n    let hashPrevouts = ZERO;\n    let hashSequence = ZERO;\n    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n      tbuffer = Buffer.allocUnsafe(36 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.hash256(tbuffer);\n    }\n    if (\n      !(hashType & Transaction.SIGHASH_ANYONECANPAY) &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      tbuffer = Buffer.allocUnsafe(4 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeUInt32(txIn.sequence);\n      });\n      hashSequence = bcrypto.hash256(tbuffer);\n    }\n    if (\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      const txOutsSize = this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0);\n      tbuffer = Buffer.allocUnsafe(txOutsSize);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.outs.forEach(out => {\n        bufferWriter.writeUInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.hash256(tbuffer);\n    } else if (\n      (hashType & 0x1f) === Transaction.SIGHASH_SINGLE &&\n      inIndex < this.outs.length\n    ) {\n      const output = this.outs[inIndex];\n      tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      bufferWriter.writeUInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.hash256(tbuffer);\n    }\n    tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));\n    bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n    const input = this.ins[inIndex];\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(hashPrevouts);\n    bufferWriter.writeSlice(hashSequence);\n    bufferWriter.writeSlice(input.hash);\n    bufferWriter.writeUInt32(input.index);\n    bufferWriter.writeVarSlice(prevOutScript);\n    bufferWriter.writeUInt64(value);\n    bufferWriter.writeUInt32(input.sequence);\n    bufferWriter.writeSlice(hashOutputs);\n    bufferWriter.writeUInt32(this.locktime);\n    bufferWriter.writeUInt32(hashType);\n    return bcrypto.hash256(tbuffer);\n  }\n  getHash(forWitness) {\n    // wtxid for coinbase is always 32 bytes of 0x00\n    if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);\n    return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));\n  }\n  getId() {\n    // transaction hash's are displayed in reverse order\n    return (0, bufferutils_1.reverseBuffer)(this.getHash(false)).toString(\n      'hex',\n    );\n  }\n  toBuffer(buffer, initialOffset) {\n    return this.__toBuffer(buffer, initialOffset, true);\n  }\n  toHex() {\n    return this.toBuffer(undefined, undefined).toString('hex');\n  }\n  setInputScript(index, scriptSig) {\n    typeforce(types.tuple(types.Number, types.Buffer), arguments);\n    this.ins[index].script = scriptSig;\n  }\n  setWitness(index, witness) {\n    typeforce(types.tuple(types.Number, [types.Buffer]), arguments);\n    this.ins[index].witness = witness;\n  }\n  __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {\n    if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));\n    const bufferWriter = new bufferutils_1.BufferWriter(\n      buffer,\n      initialOffset || 0,\n    );\n    bufferWriter.writeInt32(this.version);\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    if (hasWitnesses) {\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n    }\n    bufferWriter.writeVarInt(this.ins.length);\n    this.ins.forEach(txIn => {\n      bufferWriter.writeSlice(txIn.hash);\n      bufferWriter.writeUInt32(txIn.index);\n      bufferWriter.writeVarSlice(txIn.script);\n      bufferWriter.writeUInt32(txIn.sequence);\n    });\n    bufferWriter.writeVarInt(this.outs.length);\n    this.outs.forEach(txOut => {\n      if (isOutput(txOut)) {\n        bufferWriter.writeUInt64(txOut.value);\n      } else {\n        bufferWriter.writeSlice(txOut.valueBuffer);\n      }\n      bufferWriter.writeVarSlice(txOut.script);\n    });\n    if (hasWitnesses) {\n      this.ins.forEach(input => {\n        bufferWriter.writeVector(input.witness);\n      });\n    }\n    bufferWriter.writeUInt32(this.locktime);\n    // avoid slicing unless necessary\n    if (initialOffset !== undefined)\n      return buffer.slice(initialOffset, bufferWriter.offset);\n    return buffer;\n  }\n}\nexports.Transaction = Transaction;\nTransaction.DEFAULT_SEQUENCE = 0xffffffff;\nTransaction.SIGHASH_DEFAULT = 0x00;\nTransaction.SIGHASH_ALL = 0x01;\nTransaction.SIGHASH_NONE = 0x02;\nTransaction.SIGHASH_SINGLE = 0x03;\nTransaction.SIGHASH_ANYONECANPAY = 0x80;\nTransaction.SIGHASH_OUTPUT_MASK = 0x03;\nTransaction.SIGHASH_INPUT_MASK = 0x80;\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00;\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}