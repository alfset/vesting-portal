{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReconnectingSocket = void 0;\nconst xstream_1 = require(\"xstream\");\nconst queueingstreamingsocket_1 = require(\"./queueingstreamingsocket\");\n/**\n * A wrapper around QueueingStreamingSocket that reconnects automatically.\n */\nclass ReconnectingSocket {\n  constructor(url) {\n    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10000;\n    let reconnectedHandler = arguments.length > 2 ? arguments[2] : undefined;\n    this.unconnected = true;\n    this.disconnected = false;\n    this.timeoutIndex = 0;\n    this.reconnectTimeout = null;\n    const eventProducer = {\n      start: listener => this.eventProducerListener = listener,\n      stop: () => this.eventProducerListener = undefined\n    };\n    this.events = xstream_1.Stream.create(eventProducer);\n    this.socket = new queueingstreamingsocket_1.QueueingStreamingSocket(url, timeout, reconnectedHandler);\n    this.socket.events.subscribe({\n      next: event => {\n        if (this.eventProducerListener) {\n          this.eventProducerListener.next(event);\n        }\n      },\n      error: error => {\n        if (this.eventProducerListener) {\n          this.eventProducerListener.error(error);\n        }\n      }\n    });\n    this.connectionStatus = this.socket.connectionStatus;\n    this.connectionStatus.updates.subscribe({\n      next: status => {\n        if (status === queueingstreamingsocket_1.ConnectionStatus.Connected) {\n          this.timeoutIndex = 0;\n        }\n        if (status === queueingstreamingsocket_1.ConnectionStatus.Disconnected) {\n          if (this.reconnectTimeout) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n          }\n          this.reconnectTimeout = setTimeout(() => this.socket.reconnect(), ReconnectingSocket.calculateTimeout(this.timeoutIndex++));\n        }\n      }\n    });\n  }\n  /** Starts with a 0.1 second timeout, then doubles every attempt with a maximum timeout of 5 seconds. */\n  static calculateTimeout(index) {\n    return Math.min(2 ** index * 100, 5000);\n  }\n  connect() {\n    if (!this.unconnected) {\n      throw new Error(\"Cannot connect: socket has already connected\");\n    }\n    this.socket.connect();\n    this.unconnected = false;\n  }\n  disconnect() {\n    if (this.unconnected) {\n      throw new Error(\"Cannot disconnect: socket has not yet connected\");\n    }\n    this.socket.disconnect();\n    if (this.eventProducerListener) {\n      this.eventProducerListener.complete();\n    }\n    this.disconnected = true;\n  }\n  queueRequest(request) {\n    if (this.disconnected) {\n      throw new Error(\"Cannot queue request: socket has disconnected\");\n    }\n    this.socket.queueRequest(request);\n  }\n}\nexports.ReconnectingSocket = ReconnectingSocket;","map":{"version":3,"names":["xstream_1","require","queueingstreamingsocket_1","ReconnectingSocket","constructor","url","timeout","arguments","length","undefined","reconnectedHandler","unconnected","disconnected","timeoutIndex","reconnectTimeout","eventProducer","start","listener","eventProducerListener","stop","events","Stream","create","socket","QueueingStreamingSocket","subscribe","next","event","error","connectionStatus","updates","status","ConnectionStatus","Connected","Disconnected","clearTimeout","setTimeout","reconnect","calculateTimeout","index","Math","min","connect","Error","disconnect","complete","queueRequest","request","exports"],"sources":["../src/reconnectingsocket.ts"],"sourcesContent":[null],"mappings":";;;;;;AACA,MAAAA,SAAA,GAAAC,OAAA;AAEA,MAAAC,yBAAA,GAAAD,OAAA;AAGA;;;AAGA,MAAaE,kBAAkB;EAgB7BC,YAAmBC,GAAW,EAAmD;IAAA,IAAjDC,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAM;IAAA,IAAEG,kBAA+B,GAAAH,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;IALzE,KAAAE,WAAW,GAAG,IAAI;IAClB,KAAAC,YAAY,GAAG,KAAK;IACpB,KAAAC,YAAY,GAAG,CAAC;IAChB,KAAAC,gBAAgB,GAA0B,IAAI;IAGpD,MAAMC,aAAa,GAAkB;MACnCC,KAAK,EAAGC,QAAQ,IAAM,IAAI,CAACC,qBAAqB,GAAGD,QAAS;MAC5DE,IAAI,EAAEA,CAAA,KAAO,IAAI,CAACD,qBAAqB,GAAGT;KAC3C;IACD,IAAI,CAACW,MAAM,GAAGpB,SAAA,CAAAqB,MAAM,CAACC,MAAM,CAACP,aAAa,CAAC;IAE1C,IAAI,CAACQ,MAAM,GAAG,IAAIrB,yBAAA,CAAAsB,uBAAuB,CAACnB,GAAG,EAAEC,OAAO,EAAEI,kBAAkB,CAAC;IAC3E,IAAI,CAACa,MAAM,CAACH,MAAM,CAACK,SAAS,CAAC;MAC3BC,IAAI,EAAGC,KAAK,IAAI;QACd,IAAI,IAAI,CAACT,qBAAqB,EAAE;UAC9B,IAAI,CAACA,qBAAqB,CAACQ,IAAI,CAACC,KAAK,CAAC;;MAE1C,CAAC;MACDC,KAAK,EAAGA,KAAK,IAAI;QACf,IAAI,IAAI,CAACV,qBAAqB,EAAE;UAC9B,IAAI,CAACA,qBAAqB,CAACU,KAAK,CAACA,KAAK,CAAC;;MAE3C;KACD,CAAC;IAEF,IAAI,CAACC,gBAAgB,GAAG,IAAI,CAACN,MAAM,CAACM,gBAAgB;IACpD,IAAI,CAACA,gBAAgB,CAACC,OAAO,CAACL,SAAS,CAAC;MACtCC,IAAI,EAAGK,MAAM,IAAI;QACf,IAAIA,MAAM,KAAK7B,yBAAA,CAAA8B,gBAAgB,CAACC,SAAS,EAAE;UACzC,IAAI,CAACpB,YAAY,GAAG,CAAC;;QAEvB,IAAIkB,MAAM,KAAK7B,yBAAA,CAAA8B,gBAAgB,CAACE,YAAY,EAAE;UAC5C,IAAI,IAAI,CAACpB,gBAAgB,EAAE;YACzBqB,YAAY,CAAC,IAAI,CAACrB,gBAAgB,CAAC;YACnC,IAAI,CAACA,gBAAgB,GAAG,IAAI;;UAE9B,IAAI,CAACA,gBAAgB,GAAGsB,UAAU,CAChC,MAAM,IAAI,CAACb,MAAM,CAACc,SAAS,EAAE,EAC7BlC,kBAAkB,CAACmC,gBAAgB,CAAC,IAAI,CAACzB,YAAY,EAAE,CAAC,CACzD;;MAEL;KACD,CAAC;EACJ;EAtDA;EACQ,OAAOyB,gBAAgBA,CAACC,KAAa;IAC3C,OAAOC,IAAI,CAACC,GAAG,CAAC,CAAC,IAAIF,KAAK,GAAG,GAAG,EAAE,IAAK,CAAC;EAC1C;EAqDOG,OAAOA,CAAA;IACZ,IAAI,CAAC,IAAI,CAAC/B,WAAW,EAAE;MACrB,MAAM,IAAIgC,KAAK,CAAC,8CAA8C,CAAC;;IAEjE,IAAI,CAACpB,MAAM,CAACmB,OAAO,EAAE;IACrB,IAAI,CAAC/B,WAAW,GAAG,KAAK;EAC1B;EAEOiC,UAAUA,CAAA;IACf,IAAI,IAAI,CAACjC,WAAW,EAAE;MACpB,MAAM,IAAIgC,KAAK,CAAC,iDAAiD,CAAC;;IAEpE,IAAI,CAACpB,MAAM,CAACqB,UAAU,EAAE;IACxB,IAAI,IAAI,CAAC1B,qBAAqB,EAAE;MAC9B,IAAI,CAACA,qBAAqB,CAAC2B,QAAQ,EAAE;;IAEvC,IAAI,CAACjC,YAAY,GAAG,IAAI;EAC1B;EAEOkC,YAAYA,CAACC,OAAe;IACjC,IAAI,IAAI,CAACnC,YAAY,EAAE;MACrB,MAAM,IAAI+B,KAAK,CAAC,+CAA+C,CAAC;;IAElE,IAAI,CAACpB,MAAM,CAACuB,YAAY,CAACC,OAAO,CAAC;EACnC;;AAjFFC,OAAA,CAAA7C,kBAAA,GAAAA,kBAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}