{"ast":null,"code":"// import { useRecoilValue } from 'recoil'\nimport _ from 'lodash';\n\n// import { UTIL } from 'consts'\n\n// import AuthStore from 'store/AuthStore'\n\n// import useMantle from './useMantle'\n// import { BalanceListType } from 'types/asset'\n\nimport { useConnectedWallet } from '@terra-money/wallet-provider';\nimport { useCallback } from 'react';\nimport { terraExt } from '../nonevm/terra';\nconst jsonTryParse = value => {\n  try {\n    return JSON.parse(value);\n  } catch {\n    return undefined;\n  }\n};\n// eslint-disable-next-line @typescript-eslint/ban-types\nconst stringify = msg => JSON.stringify(msg).replace(/\"/g, '\\\\\"');\nconst bankBalanceQuery = \"\\n  query($address: String) {\\n    BankBalancesAddress(Address: $address) {\\n      Result {\\n        Amount\\n        Denom\\n      }\\n    }\\n  }\\n\";\nconst alias = _ref => {\n  let {\n    token,\n    contract,\n    msg\n  } = _ref;\n  return \"\".concat(token, \": WasmContractsContractAddressStore(\\n      ContractAddress: \\\"\").concat(contract, \"\\\"\\n      QueryMsg: \\\"\").concat(stringify(msg), \"\\\"\\n    ) {\\n      Height\\n      Result\\n    }\");\n};\nconst getTokenBalanceQuery = queries => \"\\nquery {\\n  \".concat(queries.map(alias), \"\\n}\\n\");\n\n// const TERRA_RPC = 'https://mantle.terra.dev/'\n// const TERRA_RPC = 'https://tequila-mantle.terra.dev/'\n// const TERRA_RPC = 'https://bombay-fcd.terra.dev/'\nconst TERRA_RPC = terraExt.mantle;\nconst useMantle = () => {\n  // const terraLocal = useRecoilValue(NetworkStore.terraLocal)\n  // console.log(terraLocal)\n  const fetchQuery = _ref2 => {\n    let {\n      query,\n      variables\n    } = _ref2;\n    return fetch(TERRA_RPC, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        query,\n        variables\n      })\n    }).then(res => res.json()).then(res => res.data).catch(error => error);\n  };\n  return {\n    fetchQuery\n  };\n};\nexport function useTerraBaseBalance() {\n  const connectedWallet = useConnectedWallet();\n  const {\n    fetchQuery\n  } = useMantle();\n  const getTerraBaseBalances = useCallback(async () => {\n    try {\n      var _fetchResult$BankBala;\n      const fetchResult = await fetchQuery({\n        query: bankBalanceQuery,\n        variables: JSON.stringify({\n          address: connectedWallet === null || connectedWallet === void 0 ? void 0 : connectedWallet.walletAddress\n        })\n      });\n      const resultList = (fetchResult === null || fetchResult === void 0 ? void 0 : (_fetchResult$BankBala = fetchResult.BankBalancesAddress) === null || _fetchResult$BankBala === void 0 ? void 0 : _fetchResult$BankBala.Result) || [];\n      if (_.some(resultList)) {\n        const list = {};\n        _.forEach(resultList, x => {\n          list[x.Denom] = x.Amount;\n        });\n        return list;\n      } else {\n        return {};\n      }\n    } catch (error) {\n      return {};\n    }\n  }, [bankBalanceQuery, connectedWallet]);\n  return {\n    getTerraBaseBalances\n  };\n}\nexport function useTerraTokenBalances() {\n  const connectedWallet = useConnectedWallet();\n  const {\n    fetchQuery\n  } = useMantle();\n  const getTerraTokenBalances = useCallback(async _ref3 => {\n    let {\n      terraWhiteList\n    } = _ref3;\n    const aliasResult = getTokenBalanceQuery(Object.values(terraWhiteList).map(_ref4 => {\n      let {\n        token\n      } = _ref4;\n      return {\n        token,\n        contract: token,\n        msg: {\n          balance: {\n            address: connectedWallet === null || connectedWallet === void 0 ? void 0 : connectedWallet.walletAddress\n          }\n        }\n      };\n    }));\n    try {\n      const fetchResult = await fetchQuery({\n        query: aliasResult\n      });\n      if (_.some(fetchResult)) {\n        const list = {};\n        _.forEach(fetchResult, (x, key) => {\n          if (x) {\n            const res = jsonTryParse(x.Result);\n            if (res) list[key] = res.balance;\n          }\n        });\n        return list;\n      } else {\n        return {};\n      }\n    } catch (error) {\n      return {};\n    }\n  }, [connectedWallet, getTokenBalanceQuery]);\n  return {\n    getTerraTokenBalances\n  };\n}\nconst useTerraBalance = () => {\n  // const loginUser = useRecoilValue(AuthStore.loginUser)\n  const connectedWallet = useConnectedWallet();\n  const {\n    fetchQuery\n  } = useMantle();\n  const getTerraTokenBalances = useCallback(async _ref5 => {\n    let {\n      terraWhiteList,\n      account\n    } = _ref5;\n    const useAccount = account ? account : connectedWallet === null || connectedWallet === void 0 ? void 0 : connectedWallet.walletAddress;\n    if (!useAccount) return {};\n    const aliasResult = getTokenBalanceQuery(Object.values(terraWhiteList).map(_ref6 => {\n      let {\n        token\n      } = _ref6;\n      return {\n        token,\n        contract: token,\n        msg: {\n          balance: {\n            address: useAccount\n          }\n        }\n      };\n    }));\n    try {\n      const fetchResult = await fetchQuery({\n        query: aliasResult\n      });\n      if (_.some(fetchResult)) {\n        const list = {};\n        _.forEach(fetchResult, (x, key) => {\n          if (x) {\n            const res = jsonTryParse(x.Result);\n            if (res) list[key] = res.balance;\n          }\n        });\n        return list;\n      } else {\n        return {};\n      }\n    } catch (error) {\n      return {};\n    }\n  }, [connectedWallet, getTokenBalanceQuery]);\n  // console.log(connectedWallet)\n  // const getTerraBankBalances = async (): Promise<BalanceListType> => {\n  const getTerraBankBalances = useCallback(async account => {\n    const useAccount = account ? account : connectedWallet === null || connectedWallet === void 0 ? void 0 : connectedWallet.walletAddress;\n    if (!useAccount) return {};\n    try {\n      var _fetchResult$BankBala2;\n      const fetchResult = await fetchQuery({\n        query: bankBalanceQuery,\n        variables: JSON.stringify({\n          address: useAccount\n        })\n      });\n      const resultList = (fetchResult === null || fetchResult === void 0 ? void 0 : (_fetchResult$BankBala2 = fetchResult.BankBalancesAddress) === null || _fetchResult$BankBala2 === void 0 ? void 0 : _fetchResult$BankBala2.Result) || [];\n      if (_.some(resultList)) {\n        const list = {};\n        _.forEach(resultList, x => {\n          list[x.Denom] = x.Amount;\n        });\n        return list;\n      } else {\n        return {};\n      }\n    } catch (error) {\n      return {};\n    }\n  }, [bankBalanceQuery, connectedWallet]);\n  const getTerraBalances = useCallback(async _ref7 => {\n    let {\n      terraWhiteList,\n      account\n    } = _ref7;\n    const bank = await getTerraBankBalances(account);\n    const token = await getTerraTokenBalances({\n      terraWhiteList,\n      account\n    });\n    // console.log(account)\n    // console.log(terraWhiteList)\n    // console.log(bank)\n    // console.log(token)\n    return {\n      ...bank,\n      ...token\n    };\n  }, [getTerraBankBalances, getTerraTokenBalances, connectedWallet]);\n  return {\n    getTerraBalances\n  };\n};\nexport default useTerraBalance;","map":{"version":3,"names":["_","useConnectedWallet","useCallback","terraExt","jsonTryParse","value","JSON","parse","undefined","stringify","msg","replace","bankBalanceQuery","alias","_ref","token","contract","concat","getTokenBalanceQuery","queries","map","TERRA_RPC","mantle","useMantle","fetchQuery","_ref2","query","variables","fetch","method","headers","body","then","res","json","data","catch","error","useTerraBaseBalance","connectedWallet","getTerraBaseBalances","_fetchResult$BankBala","fetchResult","address","walletAddress","resultList","BankBalancesAddress","Result","some","list","forEach","x","Denom","Amount","useTerraTokenBalances","getTerraTokenBalances","_ref3","terraWhiteList","aliasResult","Object","values","_ref4","balance","key","useTerraBalance","_ref5","account","useAccount","_ref6","getTerraBankBalances","_fetchResult$BankBala2","getTerraBalances","_ref7","bank"],"sources":["/workspace/Planq-Dapps/vesting-portal/src/hooks/useTerraBalance.ts"],"sourcesContent":["// import { useRecoilValue } from 'recoil'\nimport _ from 'lodash'\n\n// import { UTIL } from 'consts'\n\n// import AuthStore from 'store/AuthStore'\n\n// import useMantle from './useMantle'\n// import { BalanceListType } from 'types/asset'\n\nimport { useConnectedWallet } from '@terra-money/wallet-provider'\nimport { useCallback } from 'react'\nimport {terraExt} from '../nonevm/terra'\n\nconst jsonTryParse = <T>(value: string): T | undefined => {\n  try {\n    return JSON.parse(value) as T\n  } catch {\n    return undefined\n  }\n}\n\ntype BalanceListType = Record<\n  string, // tokenAddress\n  string // balance\n>\n\ninterface Query {\n  token: string\n  contract: string\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  msg: object\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nconst stringify = (msg: object): string =>\n  JSON.stringify(msg).replace(/\"/g, '\\\\\"')\n\nconst bankBalanceQuery = `\n  query($address: String) {\n    BankBalancesAddress(Address: $address) {\n      Result {\n        Amount\n        Denom\n      }\n    }\n  }\n`\n\nconst alias = ({ token, contract, msg }: Query): string =>\n  `${token}: WasmContractsContractAddressStore(\n      ContractAddress: \"${contract}\"\n      QueryMsg: \"${stringify(msg)}\"\n    ) {\n      Height\n      Result\n    }`\n\nconst getTokenBalanceQuery = (queries: Query[]): string => `\nquery {\n  ${queries.map(alias)}\n}\n`\n\n// const TERRA_RPC = 'https://mantle.terra.dev/'\n// const TERRA_RPC = 'https://tequila-mantle.terra.dev/'\n// const TERRA_RPC = 'https://bombay-fcd.terra.dev/'\nconst TERRA_RPC = terraExt.mantle\n\nconst useMantle = (): {\n  fetchQuery: ({\n    query,\n    variables,\n  }: {\n    query: string\n    variables?: string\n  }) => Promise<any> | undefined\n} => {\n  // const terraLocal = useRecoilValue(NetworkStore.terraLocal)\n  // console.log(terraLocal)\n  const fetchQuery = ({\n    query,\n    variables,\n  }: {\n    query: string\n    variables?: string\n  }): Promise<any> | undefined =>\n    fetch(TERRA_RPC, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ query, variables }),\n    })\n      .then((res) => res.json())\n      .then((res) => res.data)\n      .catch((error) => error)\n\n  return {\n    fetchQuery,\n  }\n}\n\nexport function useTerraBaseBalance () {\n  const connectedWallet = useConnectedWallet()\n  const { fetchQuery } = useMantle()\n  const getTerraBaseBalances = useCallback(async (): Promise<BalanceListType> => {\n    try {\n      const fetchResult = await fetchQuery({\n        query: bankBalanceQuery,\n        variables: JSON.stringify({ address: connectedWallet?.walletAddress }),\n      })\n      const resultList: {\n        Amount: string\n        Denom: string\n      }[] = fetchResult?.BankBalancesAddress?.Result || []\n      if (_.some(resultList)) {\n        const list: BalanceListType = {}\n        _.forEach(resultList, (x) => {\n          list[x.Denom] = x.Amount\n        })\n        return list\n      } else {\n        return {}\n      }\n    } catch (error) {\n      return {}\n    }\n\n  }, [bankBalanceQuery, connectedWallet])\n  return { getTerraBaseBalances }\n}\n\nexport function useTerraTokenBalances () {\n  const connectedWallet = useConnectedWallet()\n  const { fetchQuery } = useMantle()\n  const getTerraTokenBalances = useCallback(async ({\n    terraWhiteList,\n  }: {\n    terraWhiteList: { token: string }[]\n  }): Promise<BalanceListType> => {\n    const aliasResult = getTokenBalanceQuery(\n      Object.values(terraWhiteList).map(({ token }) => ({\n        token,\n        contract: token,\n        msg: { balance: { address: connectedWallet?.walletAddress } },\n      }))\n    )\n    try {\n      \n      const fetchResult: Record<\n        string,\n        { Height: string; Result: string }\n      > = await fetchQuery({\n        query: aliasResult,\n      })\n  \n      if (_.some(fetchResult)) {\n        const list: BalanceListType = {}\n        _.forEach(fetchResult, (x, key) => {\n          if (x) {\n            const res = jsonTryParse<{ balance: string }>(x.Result)\n            if (res) list[key] = res.balance\n          }\n        })\n        return list\n      } else {\n        return {}\n      }\n    } catch (error) {\n      return {}\n    }\n  }, [connectedWallet, getTokenBalanceQuery])\n\n  return {getTerraTokenBalances}\n}\n\nconst useTerraBalance = (): {\n  getTerraBalances: ({\n    terraWhiteList,\n    account\n  }: {\n    terraWhiteList: {\n      token: string\n    }[],\n    account?:any\n  }) => Promise<BalanceListType>\n} => {\n  // const loginUser = useRecoilValue(AuthStore.loginUser)\n  const connectedWallet = useConnectedWallet()\n  const { fetchQuery } = useMantle()\n\n  const getTerraTokenBalances = useCallback(async ({\n    terraWhiteList,\n    account\n  }: {\n    terraWhiteList: { token: string }[]\n    account?:any\n  }): Promise<BalanceListType> => {\n    const useAccount = account ? account : connectedWallet?.walletAddress\n    if (!useAccount) return {}\n    const aliasResult = getTokenBalanceQuery(\n      Object.values(terraWhiteList).map(({ token }) => ({\n        token,\n        contract: token,\n        msg: { balance: { address: useAccount } },\n      }))\n    )\n    try {\n      \n      const fetchResult: Record<\n        string,\n        { Height: string; Result: string }\n      > = await fetchQuery({\n        query: aliasResult,\n      })\n  \n      if (_.some(fetchResult)) {\n        const list: BalanceListType = {}\n        _.forEach(fetchResult, (x, key) => {\n          if (x) {\n            const res = jsonTryParse<{ balance: string }>(x.Result)\n            if (res) list[key] = res.balance\n          }\n        })\n        return list\n      } else {\n        return {}\n      }\n    } catch (error) {\n      return {}\n    }\n  }, [connectedWallet, getTokenBalanceQuery])\n  // console.log(connectedWallet)\n  // const getTerraBankBalances = async (): Promise<BalanceListType> => {\n  const getTerraBankBalances = useCallback(async (account?:any): Promise<BalanceListType> => {\n    const useAccount = account ? account : connectedWallet?.walletAddress\n    if (!useAccount) return {}\n    try {\n      \n      const fetchResult = await fetchQuery({\n        query: bankBalanceQuery,\n        variables: JSON.stringify({ address: useAccount }),\n      })\n      const resultList: {\n        Amount: string\n        Denom: string\n      }[] = fetchResult?.BankBalancesAddress?.Result || []\n  \n      if (_.some(resultList)) {\n        const list: BalanceListType = {}\n        _.forEach(resultList, (x) => {\n          list[x.Denom] = x.Amount\n        })\n        return list\n      } else {\n        return {}\n      }\n    } catch (error) {\n      return {}\n    }\n  }, [bankBalanceQuery, connectedWallet])\n\n  const getTerraBalances = useCallback(async ({\n    terraWhiteList,\n    account\n  }: {\n    terraWhiteList: { token: string }[],\n    account?: any\n  }): Promise<BalanceListType> => {\n    const bank = await getTerraBankBalances(account)\n    const token = await getTerraTokenBalances({ terraWhiteList, account })\n    // console.log(account)\n    // console.log(terraWhiteList)\n    // console.log(bank)\n    // console.log(token)\n    return {\n      ...bank,\n      ...token,\n    }\n  }, [getTerraBankBalances, getTerraTokenBalances, connectedWallet])\n\n  return { getTerraBalances }\n}\n\nexport default useTerraBalance\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}