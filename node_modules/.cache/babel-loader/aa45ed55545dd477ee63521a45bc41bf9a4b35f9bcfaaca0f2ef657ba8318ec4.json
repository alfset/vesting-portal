{"ast":null,"code":"const mailbox = () => {\n  const queue = [];\n  let next;\n  return {\n    async deliver(msg) {\n      queue.push(msg);\n      if (next) {\n        next(queue.shift());\n        next = undefined;\n      }\n    },\n    receive() {\n      return new Promise(function innerReceive(resolve) {\n        const msg = queue.shift();\n        if (msg) return resolve(msg);\n        next = resolve;\n      });\n    }\n  };\n};\nlet promise;\nconst _queueMicrotask = cb => (promise || (promise = Promise.resolve())).then(cb).catch(err => setTimeout(() => {\n  throw err;\n}, 0));\nconst INIT = \"INIT\";\nconst SUBSCRIBE = \"SUBSCRIBE\";\nconst UNSUBSCRIBE = \"UNSUBSCRIBE\";\nconst UPDATED = \"UPDATED\";\nconst SNAPSHOT = \"SNAPSHOT\";\nconst EXIT = \"EXIT\";\nconst TERMINATE = \"TERMINATE\";\nconst root = typeof self === \"object\" && self.self === self && self || typeof global === \"object\" && global.global === global && global || typeof window === \"object\" && window.window === window && window || {\n  FCL_REGISTRY: null\n};\nroot.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;\nconst FCL_REGISTRY = root.FCL_REGISTRY;\nlet pid = 0b0;\nconst DEFAULT_TIMEOUT = 5000;\nfunction send(addr, tag, data) {\n  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n    expectReply: false\n  };\n  return new Promise((resolve, reject) => {\n    const expectReply = opts.expectReply || false;\n    const timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;\n    if (expectReply && timeout) {\n      setTimeout(() => reject(new Error(\"Timeout: \".concat(timeout, \"ms passed without a response.\"))), timeout);\n    }\n    const payload = {\n      to: addr,\n      from: opts.from,\n      tag,\n      data,\n      timeout,\n      reply: resolve,\n      reject\n    };\n    try {\n      if (FCL_REGISTRY[addr]) {\n        FCL_REGISTRY[addr].mailbox.deliver(payload);\n      }\n      if (!expectReply) {\n        resolve(true);\n      }\n    } catch (error) {\n      console.error(\"FCL.Actor -- Could Not Deliver Message\", payload, FCL_REGISTRY[addr], error);\n      reject(error);\n    }\n  });\n}\nconst kill = addr => {\n  delete FCL_REGISTRY[addr];\n};\nconst fromHandlers = handlers => async ctx => {\n  if (typeof handlers[INIT] === \"function\") await handlers[INIT](ctx);\n  __loop: while (1) {\n    const letter = await ctx.receive();\n    try {\n      var _handlers$letter$tag;\n      if (letter.tag === EXIT) {\n        if (typeof handlers[TERMINATE] === \"function\") {\n          await handlers[TERMINATE](ctx, letter, letter.data || {});\n        }\n        break __loop;\n      }\n      await ((_handlers$letter$tag = handlers[letter.tag]) === null || _handlers$letter$tag === void 0 ? void 0 : _handlers$letter$tag.call(handlers, ctx, letter, letter.data || {}));\n    } catch (error) {\n      console.error(\"\".concat(ctx.self(), \" Error\"), letter, error);\n    } finally {\n      continue __loop;\n    }\n  }\n};\nconst parseAddr = addr => {\n  if (addr == null) {\n    return String(++pid);\n  }\n  return String(addr);\n};\nconst spawn = function (fnOrHandlers) {\n  let rawAddr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  const addr = parseAddr(rawAddr);\n  if (FCL_REGISTRY[addr] != null) return addr;\n  FCL_REGISTRY[addr] = {\n    addr,\n    mailbox: mailbox(),\n    subs: new Set(),\n    kvs: {},\n    error: null\n  };\n  const ctx = createCtx(addr);\n  let fn;\n  if (typeof fnOrHandlers === \"object\") fn = fromHandlers(fnOrHandlers);else fn = fnOrHandlers;\n  _queueMicrotask(async () => {\n    await fn(ctx);\n    kill(addr);\n  });\n  return addr;\n};\nconst createCtx = addr => ({\n  self: () => addr,\n  receive: () => FCL_REGISTRY[addr].mailbox.receive(),\n  send: function (to, tag, data) {\n    let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    if (to == null) return;\n    opts.from = addr;\n    return send(to, tag, data, opts);\n  },\n  sendSelf: function (tag, data) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (FCL_REGISTRY[addr]) send(addr, tag, data, opts);\n  },\n  broadcast: function (tag, data) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    opts.from = addr;\n    for (const to of FCL_REGISTRY[addr].subs) send(to, tag, data, opts);\n  },\n  subscribe: sub => sub != null && FCL_REGISTRY[addr].subs.add(sub),\n  unsubscribe: sub => sub != null && FCL_REGISTRY[addr].subs.delete(sub),\n  subscriberCount: () => FCL_REGISTRY[addr].subs.size,\n  hasSubs: () => !!FCL_REGISTRY[addr].subs.size,\n  put: (key, value) => {\n    if (key != null) FCL_REGISTRY[addr].kvs[key] = value;\n  },\n  get: function (key) {\n    let fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    const value = FCL_REGISTRY[addr].kvs[key];\n    return value == null ? fallback : value;\n  },\n  delete: key => {\n    delete FCL_REGISTRY[addr].kvs[key];\n  },\n  update: (key, fn) => {\n    if (key != null) FCL_REGISTRY[addr].kvs[key] = fn(FCL_REGISTRY[addr].kvs[key]);\n  },\n  keys: () => {\n    return Object.keys(FCL_REGISTRY[addr].kvs);\n  },\n  all: () => {\n    return FCL_REGISTRY[addr].kvs;\n  },\n  where: pattern => {\n    return Object.keys(FCL_REGISTRY[addr].kvs).reduce((acc, key) => {\n      return pattern.test(key) ? {\n        ...acc,\n        [key]: FCL_REGISTRY[addr].kvs[key]\n      } : acc;\n    }, {});\n  },\n  merge: function () {\n    let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    Object.keys(data).forEach(key => FCL_REGISTRY[addr].kvs[key] = data[key]);\n  },\n  fatalError: error => {\n    FCL_REGISTRY[addr].error = error;\n    for (const to of FCL_REGISTRY[addr].subs) send(to, UPDATED);\n  }\n});\n\n// Returns an unsubscribe function\n// A SUBSCRIBE handler will need to be created to handle the subscription event\n//\n//  [SUBSCRIBE]: (ctx, letter) => {\n//    ctx.subscribe(letter.from)\n//    ctx.send(letter.from, UPDATED, ctx.all())\n//  }\n//\nfunction subscriber(address, spawnFn, callback) {\n  spawnFn(address);\n  const self = spawn(async ctx => {\n    ctx.send(address, SUBSCRIBE);\n    while (1) {\n      const letter = await ctx.receive();\n      const error = FCL_REGISTRY[address].error;\n      if (letter.tag === EXIT) {\n        ctx.send(address, UNSUBSCRIBE);\n        return;\n      }\n      if (error) {\n        callback(null, error);\n        ctx.send(address, UNSUBSCRIBE);\n        return;\n      }\n      callback(letter.data, null);\n    }\n  });\n  return () => send(self, EXIT);\n}\n\n// Returns a promise that returns a result\n// A SNAPSHOT handler will need to be created to handle the snapshot event\n//\n//  [SNAPSHOT]: (ctx, letter) => {\n//    letter.reply(ctx.all())\n//  }\n//\nfunction snapshoter(address, spawnFn) {\n  spawnFn(address);\n  return send(address, SNAPSHOT, null, {\n    expectReply: true,\n    timeout: 0\n  });\n}\nexport { EXIT, INIT, SNAPSHOT, SUBSCRIBE, TERMINATE, UNSUBSCRIBE, UPDATED, kill, send, snapshoter, spawn, subscriber };","map":{"version":3,"names":["mailbox","queue","next","deliver","msg","push","shift","undefined","receive","Promise","innerReceive","resolve","promise","_queueMicrotask","cb","then","catch","err","setTimeout","INIT","SUBSCRIBE","UNSUBSCRIBE","UPDATED","SNAPSHOT","EXIT","TERMINATE","root","self","global","window","FCL_REGISTRY","pid","DEFAULT_TIMEOUT","send","addr","tag","data","opts","arguments","length","expectReply","reject","timeout","Error","concat","payload","to","from","reply","error","console","kill","fromHandlers","handlers","ctx","__loop","letter","_handlers$letter$tag","call","parseAddr","String","spawn","fnOrHandlers","rawAddr","subs","Set","kvs","createCtx","fn","sendSelf","broadcast","subscribe","sub","add","unsubscribe","delete","subscriberCount","size","hasSubs","put","key","value","get","fallback","update","keys","Object","all","where","pattern","reduce","acc","test","merge","forEach","fatalError","subscriber","address","spawnFn","callback","snapshoter"],"sources":["../src/mailbox/index.ts","../src/index.ts"],"sourcesContent":["export interface IMailbox<T> {\n  deliver(msg: T): Promise<void>\n  receive(): Promise<T>\n}\nexport const mailbox = <T>(): IMailbox<T> => {\n  const queue: T[] = []\n  let next: ((msg: T) => void) | undefined\n\n  return {\n    async deliver(msg: T) {\n      queue.push(msg)\n      if (next) {\n        next(queue.shift() as T)\n        next = undefined\n      }\n    },\n\n    receive(): Promise<T> {\n      return new Promise<T>(function innerReceive(resolve) {\n        const msg = queue.shift()\n        if (msg) return resolve(msg)\n        next = resolve\n      })\n    },\n  }\n}\n","import {mailbox as createMailbox, type IMailbox} from \"./mailbox\"\n\nlet promise: any\nconst _queueMicrotask = (cb: any) =>\n  (promise || (promise = Promise.resolve())).then(cb).catch((err: any) =>\n    setTimeout(() => {\n      throw err\n    }, 0)\n  )\n\nexport const INIT = \"INIT\"\nexport const SUBSCRIBE = \"SUBSCRIBE\"\nexport const UNSUBSCRIBE = \"UNSUBSCRIBE\"\nexport const UPDATED = \"UPDATED\"\nexport const SNAPSHOT = \"SNAPSHOT\"\nexport const EXIT = \"EXIT\"\nexport const TERMINATE = \"TERMINATE\"\nconst DUMP = \"DUMP\"\nconst INC = \"INC\"\nconst KEYS = \"KEYS\"\n\ninterface IRegistryRecord {\n  addr: string\n  mailbox: IMailbox<Letter>\n  subs: Set<string>\n  kvs: Record<string, any>\n  error: any\n}\ninterface IRoot {\n  FCL_REGISTRY: Record<string, IRegistryRecord> | null\n}\n\nexport type ActorContext = ReturnType<typeof createCtx>\n\nexport type Letter = {\n  to: string\n  from?: string\n  tag: string\n  data: any\n  timeout: number\n  reply: (data: any) => void\n  reject: (error: any) => void\n}\nexport type HandlerFn = (\n  ctx: ActorContext,\n  letter: Letter,\n  data: any\n) => Promise<void> | void\nexport type SpawnFn = (address?: string) => void\nexport interface ActorHandlers {\n  [INIT]?: (ctx: ActorContext) => Promise<void> | void\n  [SUBSCRIBE]?: HandlerFn\n  [UNSUBSCRIBE]?: HandlerFn\n  [UPDATED]?: HandlerFn\n  [SNAPSHOT]?: HandlerFn\n  [EXIT]?: HandlerFn\n  [TERMINATE]?: HandlerFn\n  [DUMP]?: HandlerFn\n  [INC]?: HandlerFn\n  [KEYS]?: HandlerFn\n  [key: string]: HandlerFn | undefined\n}\n\nconst root: IRoot = (typeof self === \"object\" &&\n  self.self === self &&\n  (self as unknown as IRoot)) ||\n  (typeof global === \"object\" &&\n    global.global === global &&\n    (global as unknown as IRoot)) ||\n  (typeof window === \"object\" &&\n    window.window === window &&\n    (window as unknown as IRoot)) || {FCL_REGISTRY: null}\n\nroot.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY\n\nconst FCL_REGISTRY = root.FCL_REGISTRY\nlet pid = 0b0\n\nconst DEFAULT_TIMEOUT = 5000\n\nexport function send<T>(\n  addr: string,\n  tag: string,\n  data?: Record<string, any> | null,\n  opts?: {expectReply?: true; timeout?: number; from?: string}\n): Promise<T>\nexport function send(\n  addr: string,\n  tag: string,\n  data?: Record<string, any> | null,\n  opts?: {expectReply?: false; timeout?: number; from?: string}\n): Promise<boolean>\nexport function send<T>(\n  addr: string,\n  tag: string,\n  data?: Record<string, any> | null,\n  opts: {expectReply?: boolean; timeout?: number; from?: string} = {\n    expectReply: false,\n  }\n): Promise<T | boolean> {\n  return new Promise<T | boolean>((resolve, reject) => {\n    const expectReply = opts.expectReply || false\n    const timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT\n\n    if (expectReply && timeout) {\n      setTimeout(\n        () =>\n          reject(new Error(`Timeout: ${timeout}ms passed without a response.`)),\n        timeout\n      )\n    }\n\n    const payload = {\n      to: addr,\n      from: opts.from,\n      tag,\n      data,\n      timeout,\n      reply: resolve,\n      reject,\n    }\n\n    try {\n      if (FCL_REGISTRY[addr]) {\n        FCL_REGISTRY[addr].mailbox.deliver(payload)\n      }\n      if (!expectReply) {\n        resolve(true)\n      }\n    } catch (error) {\n      console.error(\n        \"FCL.Actor -- Could Not Deliver Message\",\n        payload,\n        FCL_REGISTRY[addr],\n        error\n      )\n      reject(error)\n    }\n  })\n}\n\nexport const kill = (addr: string) => {\n  delete FCL_REGISTRY[addr]\n}\n\nconst fromHandlers =\n  <Handlers extends ActorHandlers>(handlers: Handlers) =>\n  async (ctx: ActorContext) => {\n    if (typeof handlers[INIT] === \"function\") await handlers[INIT](ctx)\n    __loop: while (1) {\n      const letter = await ctx.receive()\n      try {\n        if (letter.tag === EXIT) {\n          if (typeof handlers[TERMINATE] === \"function\") {\n            await handlers[TERMINATE](ctx, letter, letter.data || {})\n          }\n          break __loop\n        }\n        await handlers[letter.tag as any]?.(ctx, letter, letter.data || {})\n      } catch (error) {\n        console.error(`${ctx.self()} Error`, letter, error)\n      } finally {\n        continue __loop\n      }\n    }\n  }\n\nconst parseAddr = (addr: string | number | null): string => {\n  if (addr == null) {\n    return String(++pid)\n  }\n  return String(addr)\n}\n\nexport const spawn = <Handlers extends ActorHandlers>(\n  fnOrHandlers: ((ctx: ActorContext) => Promise<void>) | Handlers,\n  rawAddr: string | number | null = null\n) => {\n  const addr = parseAddr(rawAddr)\n  if (FCL_REGISTRY[addr] != null) return addr\n\n  FCL_REGISTRY[addr] = {\n    addr,\n    mailbox: createMailbox(),\n    subs: new Set(),\n    kvs: {},\n    error: null,\n  }\n\n  const ctx = createCtx(addr)\n\n  let fn: (ctx: ActorContext) => Promise<void>\n  if (typeof fnOrHandlers === \"object\")\n    fn = fromHandlers<Handlers>(fnOrHandlers)\n  else fn = fnOrHandlers\n\n  _queueMicrotask(async () => {\n    await fn(ctx)\n    kill(addr)\n  })\n\n  return addr\n}\n\nconst createCtx = (addr: string) => ({\n  self: () => addr,\n  receive: () => FCL_REGISTRY[addr].mailbox.receive(),\n  send: (\n    to: string | null | undefined,\n    tag: string,\n    data?: any,\n    opts: Record<string, any> = {}\n  ) => {\n    if (to == null) return\n    opts.from = addr\n    return send(to, tag, data, opts)\n  },\n  sendSelf: (tag: string, data?: any, opts: Record<string, any> = {}) => {\n    if (FCL_REGISTRY[addr]) send(addr, tag, data, opts)\n  },\n  broadcast: (tag: string, data: any, opts: Record<string, any> = {}) => {\n    opts.from = addr\n    for (const to of FCL_REGISTRY[addr].subs) send(to, tag, data, opts)\n  },\n  subscribe: (sub?: string | null) =>\n    sub != null && FCL_REGISTRY[addr].subs.add(sub),\n  unsubscribe: (sub?: string | null) =>\n    sub != null && FCL_REGISTRY[addr].subs.delete(sub),\n  subscriberCount: () => FCL_REGISTRY[addr].subs.size,\n  hasSubs: () => !!FCL_REGISTRY[addr].subs.size,\n  put: <T>(key: string, value: T) => {\n    if (key != null) FCL_REGISTRY[addr].kvs[key] = value\n  },\n  get: <T>(key: string, fallback: T | undefined = undefined) => {\n    const value = FCL_REGISTRY[addr].kvs[key]\n    return value == null ? fallback : value\n  },\n  delete: (key: string) => {\n    delete FCL_REGISTRY[addr].kvs[key]\n  },\n  update: <T, U>(key: string, fn: (x: T) => U) => {\n    if (key != null)\n      FCL_REGISTRY[addr].kvs[key] = fn(FCL_REGISTRY[addr].kvs[key])\n  },\n  keys: () => {\n    return Object.keys(FCL_REGISTRY[addr].kvs)\n  },\n  all: () => {\n    return FCL_REGISTRY[addr].kvs\n  },\n  where: (pattern: RegExp) => {\n    return Object.keys(FCL_REGISTRY[addr].kvs).reduce((acc, key) => {\n      return pattern.test(key)\n        ? {...acc, [key]: FCL_REGISTRY[addr].kvs[key]}\n        : acc\n    }, {})\n  },\n  merge: (data: Record<string, any> = {}) => {\n    Object.keys(data).forEach(key => (FCL_REGISTRY[addr].kvs[key] = data[key]))\n  },\n  fatalError: (error: Error) => {\n    FCL_REGISTRY[addr].error = error\n    for (const to of FCL_REGISTRY[addr].subs) send(to, UPDATED)\n  },\n})\n\n// Returns an unsubscribe function\n// A SUBSCRIBE handler will need to be created to handle the subscription event\n//\n//  [SUBSCRIBE]: (ctx, letter) => {\n//    ctx.subscribe(letter.from)\n//    ctx.send(letter.from, UPDATED, ctx.all())\n//  }\n//\nexport function subscriber<T>(\n  address: string,\n  spawnFn: SpawnFn,\n  callback: (data: T | null, error: Error | null) => void\n) {\n  spawnFn(address)\n  const self = spawn(async (ctx: ActorContext) => {\n    ctx.send(address, SUBSCRIBE)\n    while (1) {\n      const letter = await ctx.receive()\n      const error = FCL_REGISTRY[address].error\n      if (letter.tag === EXIT) {\n        ctx.send(address, UNSUBSCRIBE)\n        return\n      }\n      if (error) {\n        callback(null, error)\n        ctx.send(address, UNSUBSCRIBE)\n        return\n      }\n\n      callback(letter.data, null)\n    }\n  })\n  return () => send(self, EXIT)\n}\n\n// Returns a promise that returns a result\n// A SNAPSHOT handler will need to be created to handle the snapshot event\n//\n//  [SNAPSHOT]: (ctx, letter) => {\n//    letter.reply(ctx.all())\n//  }\n//\nexport function snapshoter<T>(address: string, spawnFn: SpawnFn) {\n  spawnFn(address)\n  return send<T>(address, SNAPSHOT, null, {\n    expectReply: true,\n    timeout: 0,\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}