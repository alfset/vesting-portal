{"ast":null,"code":"/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n  constructor(failure, failures) {\n    let cached;\n    const {\n      message,\n      explanation,\n      ...rest\n    } = failure;\n    const {\n      path\n    } = failure;\n    const msg = path.length === 0 ? message : \"At path: \".concat(path.join('.'), \" -- \").concat(message);\n    super(explanation !== null && explanation !== void 0 ? explanation : msg);\n    if (explanation != null) this.cause = msg;\n    Object.assign(this, rest);\n    this.name = this.constructor.name;\n    this.failures = () => {\n      var _cached;\n      return (_cached = cached) !== null && _cached !== void 0 ? _cached : cached = [failure, ...failures()];\n    };\n  }\n}\n\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n  return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isObject(x) {\n  return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isPlainObject(x) {\n  if (Object.prototype.toString.call(x) !== '[object Object]') {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(x);\n  return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\nfunction print(value) {\n  if (typeof value === 'symbol') {\n    return value.toString();\n  }\n  return typeof value === 'string' ? JSON.stringify(value) : \"\".concat(value);\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\nfunction shiftIterator(input) {\n  const {\n    done,\n    value\n  } = input.next();\n  return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\nfunction toFailure(result, context, struct, value) {\n  if (result === true) {\n    return;\n  } else if (result === false) {\n    result = {};\n  } else if (typeof result === 'string') {\n    result = {\n      message: result\n    };\n  }\n  const {\n    path,\n    branch\n  } = context;\n  const {\n    type\n  } = struct;\n  const {\n    refinement,\n    message = \"Expected a value of type `\".concat(type, \"`\").concat(refinement ? \" with refinement `\".concat(refinement, \"`\") : '', \", but received: `\").concat(print(value), \"`\")\n  } = result;\n  return {\n    value,\n    type,\n    refinement,\n    key: path[path.length - 1],\n    path,\n    branch,\n    ...result,\n    message\n  };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\nfunction* toFailures(result, context, struct, value) {\n  if (!isIterable(result)) {\n    result = [result];\n  }\n  for (const r of result) {\n    const failure = toFailure(r, context, struct, value);\n    if (failure) {\n      yield failure;\n    }\n  }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\nfunction run(value, struct) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return function* () {\n    const {\n      path = [],\n      branch = [value],\n      coerce = false,\n      mask = false\n    } = options;\n    const ctx = {\n      path,\n      branch\n    };\n    if (coerce) {\n      value = struct.coercer(value, ctx);\n      if (mask && struct.type !== 'type' && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {\n        for (const key in value) {\n          if (struct.schema[key] === undefined) {\n            delete value[key];\n          }\n        }\n      }\n    }\n    let status = 'valid';\n    for (const failure of struct.validator(value, ctx)) {\n      failure.explanation = options.message;\n      status = 'not_valid';\n      yield [failure, undefined];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)) {\n      const ts = run(v, s, {\n        path: k === undefined ? path : [...path, k],\n        branch: k === undefined ? branch : [...branch, v],\n        coerce,\n        mask,\n        message: options.message\n      });\n      for (const t of ts) {\n        if (t[0]) {\n          status = t[0].refinement != null ? 'not_refined' : 'not_valid';\n          yield [t[0], undefined];\n        } else if (coerce) {\n          v = t[1];\n          if (k === undefined) {\n            value = v;\n          } else if (value instanceof Map) {\n            value.set(k, v);\n          } else if (value instanceof Set) {\n            value.add(v);\n          } else if (isObject(value)) {\n            if (v !== undefined || k in value) value[k] = v;\n          }\n        }\n      }\n    }\n    if (status !== 'not_valid') {\n      for (const failure of struct.refiner(value, ctx)) {\n        failure.explanation = options.message;\n        status = 'not_refined';\n        yield [failure, undefined];\n      }\n    }\n    if (status === 'valid') {\n      yield [undefined, value];\n    }\n  }();\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nclass Struct {\n  constructor(props) {\n    const {\n      type,\n      schema,\n      validator,\n      refiner,\n      coercer = value => value,\n      entries = function* () {}\n    } = props;\n    this.type = type;\n    this.schema = schema;\n    this.entries = entries;\n    this.coercer = coercer;\n    if (validator) {\n      this.validator = (value, context) => {\n        const result = validator(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.validator = () => [];\n    }\n    if (refiner) {\n      this.refiner = (value, context) => {\n        const result = refiner(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.refiner = () => [];\n    }\n  }\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n  assert(value, message) {\n    return assert(value, this, message);\n  }\n  /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */\n  create(value, message) {\n    return create(value, this, message);\n  }\n  /**\n   * Check if a value passes the struct's validation.\n   */\n  is(value) {\n    return is(value, this);\n  }\n  /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */\n  mask(value, message) {\n    return mask(value, this, message);\n  }\n  /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */\n  validate(value) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return validate(value, this, options);\n  }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\nfunction assert(value, struct, message) {\n  const result = validate(value, struct, {\n    message\n  });\n  if (result[0]) {\n    throw result[0];\n  }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\nfunction create(value, struct, message) {\n  const result = validate(value, struct, {\n    coerce: true,\n    message\n  });\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\nfunction mask(value, struct, message) {\n  const result = validate(value, struct, {\n    coerce: true,\n    mask: true,\n    message\n  });\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Check if a value passes a struct.\n */\nfunction is(value, struct) {\n  const result = validate(value, struct);\n  return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\nfunction validate(value, struct) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const tuples = run(value, struct, options);\n  const tuple = shiftIterator(tuples);\n  if (tuple[0]) {\n    const error = new StructError(tuple[0], function* () {\n      for (const t of tuples) {\n        if (t[0]) {\n          yield t[0];\n        }\n      }\n    });\n    return [error, undefined];\n  } else {\n    const v = tuple[1];\n    return [undefined, v];\n  }\n}\nfunction assign() {\n  for (var _len = arguments.length, Structs = new Array(_len), _key = 0; _key < _len; _key++) {\n    Structs[_key] = arguments[_key];\n  }\n  const isType = Structs[0].type === 'type';\n  const schemas = Structs.map(s => s.schema);\n  const schema = Object.assign({}, ...schemas);\n  return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\nfunction define(name, validator) {\n  return new Struct({\n    type: name,\n    schema: null,\n    validator\n  });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\nfunction deprecated(struct, log) {\n  return new Struct({\n    ...struct,\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    validator(value, ctx) {\n      if (value === undefined) {\n        return true;\n      } else {\n        log(value, ctx);\n        return struct.validator(value, ctx);\n      }\n    }\n  });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\nfunction dynamic(fn) {\n  return new Struct({\n    type: 'dynamic',\n    schema: null,\n    *entries(value, ctx) {\n      const struct = fn(value, ctx);\n      yield* struct.entries(value, ctx);\n    },\n    validator(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.validator(value, ctx);\n    },\n    coercer(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.coercer(value, ctx);\n    },\n    refiner(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.refiner(value, ctx);\n    }\n  });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\nfunction lazy(fn) {\n  let struct;\n  return new Struct({\n    type: 'lazy',\n    schema: null,\n    *entries(value, ctx) {\n      var _struct;\n      (_struct = struct) !== null && _struct !== void 0 ? _struct : struct = fn();\n      yield* struct.entries(value, ctx);\n    },\n    validator(value, ctx) {\n      var _struct2;\n      (_struct2 = struct) !== null && _struct2 !== void 0 ? _struct2 : struct = fn();\n      return struct.validator(value, ctx);\n    },\n    coercer(value, ctx) {\n      var _struct3;\n      (_struct3 = struct) !== null && _struct3 !== void 0 ? _struct3 : struct = fn();\n      return struct.coercer(value, ctx);\n    },\n    refiner(value, ctx) {\n      var _struct4;\n      (_struct4 = struct) !== null && _struct4 !== void 0 ? _struct4 : struct = fn();\n      return struct.refiner(value, ctx);\n    }\n  });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\nfunction omit(struct, keys) {\n  const {\n    schema\n  } = struct;\n  const subschema = {\n    ...schema\n  };\n  for (const key of keys) {\n    delete subschema[key];\n  }\n  switch (struct.type) {\n    case 'type':\n      return type(subschema);\n    default:\n      return object(subschema);\n  }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\nfunction partial(struct) {\n  const schema = struct instanceof Struct ? {\n    ...struct.schema\n  } : {\n    ...struct\n  };\n  for (const key in schema) {\n    schema[key] = optional(schema[key]);\n  }\n  return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\nfunction pick(struct, keys) {\n  const {\n    schema\n  } = struct;\n  const subschema = {};\n  for (const key of keys) {\n    subschema[key] = schema[key];\n  }\n  return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\nfunction struct(name, validator) {\n  console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n  return define(name, validator);\n}\n\n/**\n * Ensure that any value passes validation.\n */\nfunction any() {\n  return define('any', () => true);\n}\nfunction array(Element) {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n    *entries(value) {\n      if (Element && Array.isArray(value)) {\n        for (const [i, v] of value.entries()) {\n          yield [i, v, Element];\n        }\n      }\n    },\n    coercer(value) {\n      return Array.isArray(value) ? value.slice() : value;\n    },\n    validator(value) {\n      return Array.isArray(value) || \"Expected an array value, but received: \".concat(print(value));\n    }\n  });\n}\n/**\n * Ensure that a value is a bigint.\n */\nfunction bigint() {\n  return define('bigint', value => {\n    return typeof value === 'bigint';\n  });\n}\n/**\n * Ensure that a value is a boolean.\n */\nfunction boolean() {\n  return define('boolean', value => {\n    return typeof value === 'boolean';\n  });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\nfunction date() {\n  return define('date', value => {\n    return value instanceof Date && !isNaN(value.getTime()) || \"Expected a valid `Date` object, but received: \".concat(print(value));\n  });\n}\nfunction enums(values) {\n  const schema = {};\n  const description = values.map(v => print(v)).join();\n  for (const key of values) {\n    schema[key] = key;\n  }\n  return new Struct({\n    type: 'enums',\n    schema,\n    validator(value) {\n      return values.includes(value) || \"Expected one of `\".concat(description, \"`, but received: \").concat(print(value));\n    }\n  });\n}\n/**\n * Ensure that a value is a function.\n */\nfunction func() {\n  return define('func', value => {\n    return typeof value === 'function' || \"Expected a function, but received: \".concat(print(value));\n  });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\nfunction instance(Class) {\n  return define('instance', value => {\n    return value instanceof Class || \"Expected a `\".concat(Class.name, \"` instance, but received: \").concat(print(value));\n  });\n}\n/**\n * Ensure that a value is an integer.\n */\nfunction integer() {\n  return define('integer', value => {\n    return typeof value === 'number' && !isNaN(value) && Number.isInteger(value) || \"Expected an integer, but received: \".concat(print(value));\n  });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */\nfunction intersection(Structs) {\n  return new Struct({\n    type: 'intersection',\n    schema: null,\n    *entries(value, ctx) {\n      for (const S of Structs) {\n        yield* S.entries(value, ctx);\n      }\n    },\n    *validator(value, ctx) {\n      for (const S of Structs) {\n        yield* S.validator(value, ctx);\n      }\n    },\n    *refiner(value, ctx) {\n      for (const S of Structs) {\n        yield* S.refiner(value, ctx);\n      }\n    }\n  });\n}\nfunction literal(constant) {\n  const description = print(constant);\n  const t = typeof constant;\n  return new Struct({\n    type: 'literal',\n    schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n    validator(value) {\n      return value === constant || \"Expected the literal `\".concat(description, \"`, but received: \").concat(print(value));\n    }\n  });\n}\nfunction map(Key, Value) {\n  return new Struct({\n    type: 'map',\n    schema: null,\n    *entries(value) {\n      if (Key && Value && value instanceof Map) {\n        for (const [k, v] of value.entries()) {\n          yield [k, k, Key];\n          yield [k, v, Value];\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Map ? new Map(value) : value;\n    },\n    validator(value) {\n      return value instanceof Map || \"Expected a `Map` object, but received: \".concat(print(value));\n    }\n  });\n}\n/**\n * Ensure that no value ever passes validation.\n */\nfunction never() {\n  return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\nfunction nullable(struct) {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) => value === null || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === null || struct.refiner(value, ctx)\n  });\n}\n/**\n * Ensure that a value is a number.\n */\nfunction number() {\n  return define('number', value => {\n    return typeof value === 'number' && !isNaN(value) || \"Expected a number, but received: \".concat(print(value));\n  });\n}\nfunction object(schema) {\n  const knowns = schema ? Object.keys(schema) : [];\n  const Never = never();\n  return new Struct({\n    type: 'object',\n    schema: schema ? schema : null,\n    *entries(value) {\n      if (schema && isObject(value)) {\n        const unknowns = new Set(Object.keys(value));\n        for (const key of knowns) {\n          unknowns.delete(key);\n          yield [key, value[key], schema[key]];\n        }\n        for (const key of unknowns) {\n          yield [key, value[key], Never];\n        }\n      }\n    },\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \".concat(print(value));\n    },\n    coercer(value) {\n      return isObject(value) ? {\n        ...value\n      } : value;\n    }\n  });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\nfunction optional(struct) {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx)\n  });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\nfunction record(Key, Value) {\n  return new Struct({\n    type: 'record',\n    schema: null,\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k in value) {\n          const v = value[k];\n          yield [k, k, Key];\n          yield [k, v, Value];\n        }\n      }\n    },\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \".concat(print(value));\n    }\n  });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\nfunction regexp() {\n  return define('regexp', value => {\n    return value instanceof RegExp;\n  });\n}\nfunction set(Element) {\n  return new Struct({\n    type: 'set',\n    schema: null,\n    *entries(value) {\n      if (Element && value instanceof Set) {\n        for (const v of value) {\n          yield [v, v, Element];\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Set ? new Set(value) : value;\n    },\n    validator(value) {\n      return value instanceof Set || \"Expected a `Set` object, but received: \".concat(print(value));\n    }\n  });\n}\n/**\n * Ensure that a value is a string.\n */\nfunction string() {\n  return define('string', value => {\n    return typeof value === 'string' || \"Expected a string, but received: \".concat(print(value));\n  });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\nfunction tuple(Structs) {\n  const Never = never();\n  return new Struct({\n    type: 'tuple',\n    schema: null,\n    *entries(value) {\n      if (Array.isArray(value)) {\n        const length = Math.max(Structs.length, value.length);\n        for (let i = 0; i < length; i++) {\n          yield [i, value[i], Structs[i] || Never];\n        }\n      }\n    },\n    validator(value) {\n      return Array.isArray(value) || \"Expected an array, but received: \".concat(print(value));\n    }\n  });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\nfunction type(schema) {\n  const keys = Object.keys(schema);\n  return new Struct({\n    type: 'type',\n    schema,\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k of keys) {\n          yield [k, value[k], schema[k]];\n        }\n      }\n    },\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \".concat(print(value));\n    },\n    coercer(value) {\n      return isObject(value) ? {\n        ...value\n      } : value;\n    }\n  });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */\nfunction union(Structs) {\n  const description = Structs.map(s => s.type).join(' | ');\n  return new Struct({\n    type: 'union',\n    schema: null,\n    coercer(value) {\n      for (const S of Structs) {\n        const [error, coerced] = S.validate(value, {\n          coerce: true\n        });\n        if (!error) {\n          return coerced;\n        }\n      }\n      return value;\n    },\n    validator(value, ctx) {\n      const failures = [];\n      for (const S of Structs) {\n        const [...tuples] = run(value, S, ctx);\n        const [first] = tuples;\n        if (!first[0]) {\n          return [];\n        } else {\n          for (const [failure] of tuples) {\n            if (failure) {\n              failures.push(failure);\n            }\n          }\n        }\n      }\n      return [\"Expected the value to satisfy a union of `\".concat(description, \"`, but received: \").concat(print(value)), ...failures];\n    }\n  });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\nfunction unknown() {\n  return define('unknown', () => true);\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationâ€”for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction coerce(struct, condition, coercer) {\n  return new Struct({\n    ...struct,\n    coercer: (value, ctx) => {\n      return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n    }\n  });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction defaulted(struct, fallback) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return coerce(struct, unknown(), x => {\n    const f = typeof fallback === 'function' ? fallback() : fallback;\n    if (x === undefined) {\n      return f;\n    }\n    if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n      const ret = {\n        ...x\n      };\n      let changed = false;\n      for (const key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key];\n          changed = true;\n        }\n      }\n      if (changed) {\n        return ret;\n      }\n    }\n    return x;\n  });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction trimmed(struct) {\n  return coerce(struct, string(), x => x.trim());\n}\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\nfunction empty(struct) {\n  return refine(struct, 'empty', value => {\n    const size = getSize(value);\n    return size === 0 || \"Expected an empty \".concat(struct.type, \" but received one with a size of `\").concat(size, \"`\");\n  });\n}\nfunction getSize(value) {\n  if (value instanceof Map || value instanceof Set) {\n    return value.size;\n  } else {\n    return value.length;\n  }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\nfunction max(struct, threshold) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    exclusive\n  } = options;\n  return refine(struct, 'max', value => {\n    return exclusive ? value < threshold : value <= threshold || \"Expected a \".concat(struct.type, \" less than \").concat(exclusive ? '' : 'or equal to ').concat(threshold, \" but received `\").concat(value, \"`\");\n  });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\nfunction min(struct, threshold) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    exclusive\n  } = options;\n  return refine(struct, 'min', value => {\n    return exclusive ? value > threshold : value >= threshold || \"Expected a \".concat(struct.type, \" greater than \").concat(exclusive ? '' : 'or equal to ').concat(threshold, \" but received `\").concat(value, \"`\");\n  });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */\nfunction nonempty(struct) {\n  return refine(struct, 'nonempty', value => {\n    const size = getSize(value);\n    return size > 0 || \"Expected a nonempty \".concat(struct.type, \" but received an empty one\");\n  });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\nfunction pattern(struct, regexp) {\n  return refine(struct, 'pattern', value => {\n    return regexp.test(value) || \"Expected a \".concat(struct.type, \" matching `/\").concat(regexp.source, \"/` but received \\\"\").concat(value, \"\\\"\");\n  });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\nfunction size(struct, min) {\n  let max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : min;\n  const expected = \"Expected a \".concat(struct.type);\n  const of = min === max ? \"of `\".concat(min, \"`\") : \"between `\".concat(min, \"` and `\").concat(max, \"`\");\n  return refine(struct, 'size', value => {\n    if (typeof value === 'number' || value instanceof Date) {\n      return min <= value && value <= max || \"\".concat(expected, \" \").concat(of, \" but received `\").concat(value, \"`\");\n    } else if (value instanceof Map || value instanceof Set) {\n      const {\n        size\n      } = value;\n      return min <= size && size <= max || \"\".concat(expected, \" with a size \").concat(of, \" but received one with a size of `\").concat(size, \"`\");\n    } else {\n      const {\n        length\n      } = value;\n      return min <= length && length <= max || \"\".concat(expected, \" with a length \").concat(of, \" but received one with a length of `\").concat(length, \"`\");\n    }\n  });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\nfunction refine(struct, name, refiner) {\n  return new Struct({\n    ...struct,\n    *refiner(value, ctx) {\n      yield* struct.refiner(value, ctx);\n      const result = refiner(value, ctx);\n      const failures = toFailures(result, ctx, struct, value);\n      for (const failure of failures) {\n        yield {\n          ...failure,\n          refinement: name\n        };\n      }\n    }\n  });\n}\nexport { Struct, StructError, any, array, assert, assign, bigint, boolean, coerce, create, date, defaulted, define, deprecated, dynamic, empty, enums, func, instance, integer, intersection, is, lazy, literal, map, mask, max, min, never, nonempty, nullable, number, object, omit, optional, partial, pattern, pick, record, refine, regexp, set, size, string, struct, trimmed, tuple, type, union, unknown, validate };","map":{"version":3,"names":["StructError","TypeError","constructor","failure","failures","cached","message","explanation","rest","path","msg","length","concat","join","cause","Object","assign","name","_cached","isIterable","x","isObject","Symbol","iterator","isPlainObject","prototype","toString","call","getPrototypeOf","print","value","JSON","stringify","shiftIterator","input","done","next","undefined","toFailure","result","context","struct","branch","type","refinement","key","toFailures","r","run","options","arguments","coerce","mask","ctx","coercer","schema","Array","isArray","status","validator","k","v","s","entries","ts","t","Map","set","Set","add","refiner","Struct","props","assert","create","is","validate","tuples","tuple","error","_len","Structs","_key","isType","schemas","map","object","define","deprecated","log","dynamic","fn","lazy","_struct","_struct2","_struct3","_struct4","omit","keys","subschema","partial","optional","pick","console","warn","any","array","Element","i","slice","bigint","boolean","date","Date","isNaN","getTime","enums","values","description","includes","func","instance","Class","integer","Number","isInteger","intersection","S","literal","constant","Key","Value","never","nullable","number","knowns","Never","unknowns","delete","record","regexp","RegExp","string","Math","max","union","coerced","first","push","unknown","condition","defaulted","fallback","f","strict","ret","changed","trimmed","trim","empty","refine","size","getSize","threshold","exclusive","min","nonempty","pattern","test","source","expected","of"],"sources":["../src/error.ts","../src/utils.ts","../src/struct.ts","../src/structs/utilities.ts","../src/structs/types.ts","../src/structs/coercions.ts","../src/structs/refinements.ts"],"sourcesContent":[null,null,null,null,null,null,null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}