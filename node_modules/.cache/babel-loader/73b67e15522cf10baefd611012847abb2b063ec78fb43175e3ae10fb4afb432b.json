{"ast":null,"code":"import { createReducer } from '@reduxjs/toolkit';\nimport { addMulticallListeners, addUseChainId, errorFetchingMulticallResults, fetchingMulticallResults, removeMulticallListeners, toCallKey, updateMulticallResults } from './actions';\nconst initialState = {\n  callResults: {}\n};\nexport default createReducer(initialState, builder => builder.addCase(addMulticallListeners, (state, _ref) => {\n  var _listeners$chainId;\n  let {\n    payload: {\n      calls,\n      chainId,\n      options: {\n        blocksPerFetch = 1\n      } = {}\n    }\n  } = _ref;\n  const listeners = state.callListeners ? state.callListeners : state.callListeners = {};\n  listeners[chainId] = (_listeners$chainId = listeners[chainId]) !== null && _listeners$chainId !== void 0 ? _listeners$chainId : {};\n  calls.forEach(call => {\n    var _listeners$chainId$ca, _listeners$chainId$ca2;\n    const callKey = toCallKey(call);\n    listeners[chainId][callKey] = (_listeners$chainId$ca = listeners[chainId][callKey]) !== null && _listeners$chainId$ca !== void 0 ? _listeners$chainId$ca : {};\n    listeners[chainId][callKey][blocksPerFetch] = ((_listeners$chainId$ca2 = listeners[chainId][callKey][blocksPerFetch]) !== null && _listeners$chainId$ca2 !== void 0 ? _listeners$chainId$ca2 : 0) + 1;\n  });\n}).addCase(addUseChainId, (state, _ref2) => {\n  let {\n    payload: {\n      chainId\n    }\n  } = _ref2;\n  state.useChainId = chainId;\n}).addCase(removeMulticallListeners, (state, _ref3) => {\n  let {\n    payload: {\n      chainId,\n      calls,\n      options: {\n        blocksPerFetch = 1\n      } = {}\n    }\n  } = _ref3;\n  const listeners = state.callListeners ? state.callListeners : state.callListeners = {};\n  if (!listeners[chainId]) return;\n  calls.forEach(call => {\n    const callKey = toCallKey(call);\n    if (!listeners[chainId][callKey]) return;\n    if (!listeners[chainId][callKey][blocksPerFetch]) return;\n    if (listeners[chainId][callKey][blocksPerFetch] === 1) {\n      delete listeners[chainId][callKey][blocksPerFetch];\n    } else {\n      listeners[chainId][callKey][blocksPerFetch]--;\n    }\n  });\n}).addCase(fetchingMulticallResults, (state, _ref4) => {\n  var _state$callResults$ch;\n  let {\n    payload: {\n      chainId,\n      fetchingBlockNumber,\n      calls\n    }\n  } = _ref4;\n  state.callResults[chainId] = (_state$callResults$ch = state.callResults[chainId]) !== null && _state$callResults$ch !== void 0 ? _state$callResults$ch : {};\n  calls.forEach(call => {\n    const callKey = toCallKey(call);\n    const current = state.callResults[chainId][callKey];\n    if (!current) {\n      state.callResults[chainId][callKey] = {\n        fetchingBlockNumber\n      };\n    } else {\n      var _current$fetchingBloc;\n      if (((_current$fetchingBloc = current.fetchingBlockNumber) !== null && _current$fetchingBloc !== void 0 ? _current$fetchingBloc : 0) >= fetchingBlockNumber) return;\n      state.callResults[chainId][callKey].fetchingBlockNumber = fetchingBlockNumber;\n    }\n  });\n}).addCase(errorFetchingMulticallResults, (state, _ref5) => {\n  var _state$callResults$ch2;\n  let {\n    payload: {\n      fetchingBlockNumber,\n      chainId,\n      calls\n    }\n  } = _ref5;\n  state.callResults[chainId] = (_state$callResults$ch2 = state.callResults[chainId]) !== null && _state$callResults$ch2 !== void 0 ? _state$callResults$ch2 : {};\n  calls.forEach(call => {\n    const callKey = toCallKey(call);\n    const current = state.callResults[chainId][callKey];\n    if (!current) return; // only should be dispatched if we are already fetching\n    if (current.fetchingBlockNumber === fetchingBlockNumber) {\n      delete current.fetchingBlockNumber;\n      current.data = null;\n      current.blockNumber = fetchingBlockNumber;\n    }\n  });\n}).addCase(updateMulticallResults, (state, _ref6) => {\n  var _state$callResults$ch3;\n  let {\n    payload: {\n      chainId,\n      results,\n      blockNumber\n    }\n  } = _ref6;\n  state.callResults[chainId] = (_state$callResults$ch3 = state.callResults[chainId]) !== null && _state$callResults$ch3 !== void 0 ? _state$callResults$ch3 : {};\n  Object.keys(results).forEach(callKey => {\n    var _current$blockNumber;\n    const current = state.callResults[chainId][callKey];\n    if (((_current$blockNumber = current === null || current === void 0 ? void 0 : current.blockNumber) !== null && _current$blockNumber !== void 0 ? _current$blockNumber : 0) > blockNumber) return;\n    state.callResults[chainId][callKey] = {\n      data: results[callKey],\n      blockNumber\n    };\n  });\n}));","map":{"version":3,"names":["createReducer","addMulticallListeners","addUseChainId","errorFetchingMulticallResults","fetchingMulticallResults","removeMulticallListeners","toCallKey","updateMulticallResults","initialState","callResults","builder","addCase","state","_ref","_listeners$chainId","payload","calls","chainId","options","blocksPerFetch","listeners","callListeners","forEach","call","_listeners$chainId$ca","_listeners$chainId$ca2","callKey","_ref2","useChainId","_ref3","_ref4","_state$callResults$ch","fetchingBlockNumber","current","_current$fetchingBloc","_ref5","_state$callResults$ch2","data","blockNumber","_ref6","_state$callResults$ch3","results","Object","keys","_current$blockNumber"],"sources":["/workspace/Planq-Dapps/vesting-portal/src/state/multicall/reducer.ts"],"sourcesContent":["import { createReducer } from '@reduxjs/toolkit'\nimport {\n  addMulticallListeners,\n  addUseChainId,\n  errorFetchingMulticallResults,\n  fetchingMulticallResults,\n  removeMulticallListeners,\n  toCallKey,\n  updateMulticallResults\n} from './actions'\n\nexport interface MulticallState {\n  callListeners?: {\n    // on a per-chain basis\n    [chainId: number]: {\n      // stores for each call key the listeners' preferences\n      [callKey: string]: {\n        // stores how many listeners there are per each blocks per fetch preference\n        [blocksPerFetch: number]: number\n      }\n    }\n  }\n\n  callResults: {\n    [chainId: number]: {\n      [callKey: string]: {\n        data?: string | null\n        blockNumber?: number\n        fetchingBlockNumber?: number\n      }\n    }\n  }\n\n  useChainId?: any\n}\n\nconst initialState: MulticallState = {\n  callResults: {}\n}\n\nexport default createReducer(initialState, builder =>\n  builder\n    .addCase(addMulticallListeners, (state, { payload: { calls, chainId, options: { blocksPerFetch = 1 } = {} } }) => {\n      const listeners: MulticallState['callListeners'] = state.callListeners\n        ? state.callListeners\n        : (state.callListeners = {})\n      listeners[chainId] = listeners[chainId] ?? {}\n      calls.forEach(call => {\n        const callKey = toCallKey(call)\n        listeners[chainId][callKey] = listeners[chainId][callKey] ?? {}\n        listeners[chainId][callKey][blocksPerFetch] = (listeners[chainId][callKey][blocksPerFetch] ?? 0) + 1\n      })\n    })\n    .addCase(addUseChainId, (state, { payload: { chainId }}) => {\n      state.useChainId = chainId\n    })\n    .addCase(\n      removeMulticallListeners,\n      (state, { payload: { chainId, calls, options: { blocksPerFetch = 1 } = {} } }) => {\n        const listeners: MulticallState['callListeners'] = state.callListeners\n          ? state.callListeners\n          : (state.callListeners = {})\n\n        if (!listeners[chainId]) return\n        calls.forEach(call => {\n          const callKey = toCallKey(call)\n          if (!listeners[chainId][callKey]) return\n          if (!listeners[chainId][callKey][blocksPerFetch]) return\n\n          if (listeners[chainId][callKey][blocksPerFetch] === 1) {\n            delete listeners[chainId][callKey][blocksPerFetch]\n          } else {\n            listeners[chainId][callKey][blocksPerFetch]--\n          }\n        })\n      }\n    )\n    .addCase(fetchingMulticallResults, (state, { payload: { chainId, fetchingBlockNumber, calls } }) => {\n      state.callResults[chainId] = state.callResults[chainId] ?? {}\n      calls.forEach(call => {\n        const callKey = toCallKey(call)\n        const current = state.callResults[chainId][callKey]\n        if (!current) {\n          state.callResults[chainId][callKey] = {\n            fetchingBlockNumber\n          }\n        } else {\n          if ((current.fetchingBlockNumber ?? 0) >= fetchingBlockNumber) return\n          state.callResults[chainId][callKey].fetchingBlockNumber = fetchingBlockNumber\n        }\n      })\n    })\n    .addCase(errorFetchingMulticallResults, (state, { payload: { fetchingBlockNumber, chainId, calls } }) => {\n      state.callResults[chainId] = state.callResults[chainId] ?? {}\n      calls.forEach(call => {\n        const callKey = toCallKey(call)\n        const current = state.callResults[chainId][callKey]\n        if (!current) return // only should be dispatched if we are already fetching\n        if (current.fetchingBlockNumber === fetchingBlockNumber) {\n          delete current.fetchingBlockNumber\n          current.data = null\n          current.blockNumber = fetchingBlockNumber\n        }\n      })\n    })\n    .addCase(updateMulticallResults, (state, { payload: { chainId, results, blockNumber } }) => {\n      state.callResults[chainId] = state.callResults[chainId] ?? {}\n      Object.keys(results).forEach(callKey => {\n        const current = state.callResults[chainId][callKey]\n        if ((current?.blockNumber ?? 0) > blockNumber) return\n        state.callResults[chainId][callKey] = {\n          data: results[callKey],\n          blockNumber\n        }\n      })\n    })\n)\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}