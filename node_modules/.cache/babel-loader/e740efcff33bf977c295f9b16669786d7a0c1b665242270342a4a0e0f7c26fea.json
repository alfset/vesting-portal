{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.Psbt = void 0;\nconst bip174_1 = require('bip174');\nconst varuint = require('bip174/src/lib/converter/varint');\nconst utils_1 = require('bip174/src/lib/utils');\nconst address_1 = require('./address');\nconst bufferutils_1 = require('./bufferutils');\nconst networks_1 = require('./networks');\nconst payments = require('./payments');\nconst bip341_1 = require('./payments/bip341');\nconst bscript = require('./script');\nconst transaction_1 = require('./transaction');\nconst bip371_1 = require('./psbt/bip371');\nconst psbtutils_1 = require('./psbt/psbtutils');\n/**\n * These are the default arguments for a Psbt instance.\n */\nconst DEFAULT_OPTS = {\n  /**\n   * A bitcoinjs Network object. This is only used if you pass an `address`\n   * parameter to addOutput. Otherwise it is not needed and can be left default.\n   */\n  network: networks_1.bitcoin,\n  /**\n   * When extractTransaction is called, the fee rate is checked.\n   * THIS IS NOT TO BE RELIED ON.\n   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.\n   */\n  maximumFeeRate: 5000 // satoshi per byte\n};\n/**\n * Psbt class can parse and generate a PSBT binary based off of the BIP174.\n * There are 6 roles that this class fulfills. (Explained in BIP174)\n *\n * Creator: This can be done with `new Psbt()`\n * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,\n *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to\n *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,\n *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`\n *   addInput requires hash: Buffer | string; and index: number; as attributes\n *   and can also include any attributes that are used in updateInput method.\n *   addOutput requires script: Buffer; and value: number; and likewise can include\n *   data for updateOutput.\n *   For a list of what attributes should be what types. Check the bip174 library.\n *   Also, check the integration tests for some examples of usage.\n * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input\n *   information for your pubkey or pubkeyhash, and only sign inputs where it finds\n *   your info. Or you can explicitly sign a specific input with signInput and\n *   signInputAsync. For the async methods you can create a SignerAsync object\n *   and use something like a hardware wallet to sign with. (You must implement this)\n * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`\n *   the psbt calling combine will always have precedence when a conflict occurs.\n *   Combine checks if the internal bitcoin transaction is the same, so be sure that\n *   all sequences, version, locktime, etc. are the same before combining.\n * Input Finalizer: This role is fairly important. Not only does it need to construct\n *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.\n *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`\n *   Running any finalize method will delete any data in the input(s) that are no longer\n *   needed due to the finalized scripts containing the information.\n * Transaction Extractor: This role will perform some checks before returning a\n *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.\n */\nclass Psbt {\n  static fromBase64(data) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const buffer = Buffer.from(data, 'base64');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromHex(data) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const buffer = Buffer.from(data, 'hex');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromBuffer(buffer) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);\n    const psbt = new Psbt(opts, psbtBase);\n    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);\n    return psbt;\n  }\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new bip174_1.Psbt(new PsbtTransaction());\n    this.data = data;\n    // set defaults\n    this.opts = Object.assign({}, DEFAULT_OPTS, opts);\n    this.__CACHE = {\n      __NON_WITNESS_UTXO_TX_CACHE: [],\n      __NON_WITNESS_UTXO_BUF_CACHE: [],\n      __TX_IN_CACHE: {},\n      __TX: this.data.globalMap.unsignedTx.tx,\n      // Psbt's predecesor (TransactionBuilder - now removed) behavior\n      // was to not confirm input values  before signing.\n      // Even though we highly encourage people to get\n      // the full parent transaction to verify values, the ability to\n      // sign non-segwit inputs without the full transaction was often\n      // requested. So the only way to activate is to use @ts-ignore.\n      // We will disable exporting the Psbt when unsafe sign is active.\n      // because it is not BIP174 compliant.\n      __UNSAFE_SIGN_NONSEGWIT: false\n    };\n    if (this.data.inputs.length === 0) this.setVersion(2);\n    // Make data hidden when enumerating\n    const dpew = (obj, attr, enumerable, writable) => Object.defineProperty(obj, attr, {\n      enumerable,\n      writable\n    });\n    dpew(this, '__CACHE', false, true);\n    dpew(this, 'opts', false, true);\n  }\n  get inputCount() {\n    return this.data.inputs.length;\n  }\n  get version() {\n    return this.__CACHE.__TX.version;\n  }\n  set version(version) {\n    this.setVersion(version);\n  }\n  get locktime() {\n    return this.__CACHE.__TX.locktime;\n  }\n  set locktime(locktime) {\n    this.setLocktime(locktime);\n  }\n  get txInputs() {\n    return this.__CACHE.__TX.ins.map(input => ({\n      hash: (0, bufferutils_1.cloneBuffer)(input.hash),\n      index: input.index,\n      sequence: input.sequence\n    }));\n  }\n  get txOutputs() {\n    return this.__CACHE.__TX.outs.map(output => {\n      let address;\n      try {\n        address = (0, address_1.fromOutputScript)(output.script, this.opts.network);\n      } catch (_) {}\n      return {\n        script: (0, bufferutils_1.cloneBuffer)(output.script),\n        value: output.value,\n        address\n      };\n    });\n  }\n  combine() {\n    for (var _len = arguments.length, those = new Array(_len), _key = 0; _key < _len; _key++) {\n      those[_key] = arguments[_key];\n    }\n    this.data.combine(...those.map(o => o.data));\n    return this;\n  }\n  clone() {\n    // TODO: more efficient cloning\n    const res = Psbt.fromBuffer(this.data.toBuffer());\n    res.opts = JSON.parse(JSON.stringify(this.opts));\n    return res;\n  }\n  setMaximumFeeRate(satoshiPerByte) {\n    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw\n    this.opts.maximumFeeRate = satoshiPerByte;\n  }\n  setVersion(version) {\n    check32Bit(version);\n    checkInputsForPartialSig(this.data.inputs, 'setVersion');\n    const c = this.__CACHE;\n    c.__TX.version = version;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setLocktime(locktime) {\n    check32Bit(locktime);\n    checkInputsForPartialSig(this.data.inputs, 'setLocktime');\n    const c = this.__CACHE;\n    c.__TX.locktime = locktime;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setInputSequence(inputIndex, sequence) {\n    check32Bit(sequence);\n    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');\n    const c = this.__CACHE;\n    if (c.__TX.ins.length <= inputIndex) {\n      throw new Error('Input index too high');\n    }\n    c.__TX.ins[inputIndex].sequence = sequence;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addInputs(inputDatas) {\n    inputDatas.forEach(inputData => this.addInput(inputData));\n    return this;\n  }\n  addInput(inputData) {\n    if (arguments.length > 1 || !inputData || inputData.hash === undefined || inputData.index === undefined) {\n      throw new Error(\"Invalid arguments for Psbt.addInput. \" + \"Requires single object with at least [hash] and [index]\");\n    }\n    (0, bip371_1.checkTaprootInputFields)(inputData, inputData, 'addInput');\n    checkInputsForPartialSig(this.data.inputs, 'addInput');\n    if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);\n    const c = this.__CACHE;\n    this.data.addInput(inputData);\n    const txIn = c.__TX.ins[c.__TX.ins.length - 1];\n    checkTxInputCache(c, txIn);\n    const inputIndex = this.data.inputs.length - 1;\n    const input = this.data.inputs[inputIndex];\n    if (input.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, input, inputIndex);\n    }\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addOutputs(outputDatas) {\n    outputDatas.forEach(outputData => this.addOutput(outputData));\n    return this;\n  }\n  addOutput(outputData) {\n    if (arguments.length > 1 || !outputData || outputData.value === undefined || outputData.address === undefined && outputData.script === undefined) {\n      throw new Error(\"Invalid arguments for Psbt.addOutput. \" + \"Requires single object with at least [script or address] and [value]\");\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addOutput');\n    const {\n      address\n    } = outputData;\n    if (typeof address === 'string') {\n      const {\n        network\n      } = this.opts;\n      const script = (0, address_1.toOutputScript)(address, network);\n      outputData = Object.assign(outputData, {\n        script\n      });\n    }\n    (0, bip371_1.checkTaprootOutputFields)(outputData, outputData, 'addOutput');\n    const c = this.__CACHE;\n    this.data.addOutput(outputData);\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  extractTransaction(disableFeeCheck) {\n    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');\n    const c = this.__CACHE;\n    if (!disableFeeCheck) {\n      checkFees(this, c, this.opts);\n    }\n    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;\n    const tx = c.__TX.clone();\n    inputFinalizeGetAmts(this.data.inputs, tx, c, true);\n    return tx;\n  }\n  getFeeRate() {\n    return getTxCacheValue('__FEE_RATE', 'fee rate', this.data.inputs, this.__CACHE);\n  }\n  getFee() {\n    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);\n  }\n  finalizeAllInputs() {\n    (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one\n    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));\n    return this;\n  }\n  finalizeInput(inputIndex, finalScriptsFunc) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input)) return this._finalizeTaprootInput(inputIndex, input, undefined, finalScriptsFunc);\n    return this._finalizeInput(inputIndex, input, finalScriptsFunc);\n  }\n  finalizeTaprootInput(inputIndex, tapLeafHashToFinalize) {\n    let finalScriptsFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : bip371_1.tapScriptFinalizer;\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input)) return this._finalizeTaprootInput(inputIndex, input, tapLeafHashToFinalize, finalScriptsFunc);\n    throw new Error(\"Cannot finalize input #\".concat(inputIndex, \". Not Taproot.\"));\n  }\n  _finalizeInput(inputIndex, input) {\n    let finalScriptsFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getFinalScripts;\n    const {\n      script,\n      isP2SH,\n      isP2WSH,\n      isSegwit\n    } = getScriptFromInput(inputIndex, input, this.__CACHE);\n    if (!script) throw new Error(\"No script found for input #\".concat(inputIndex));\n    checkPartialSigSighashes(input);\n    const {\n      finalScriptSig,\n      finalScriptWitness\n    } = finalScriptsFunc(inputIndex, input, script, isSegwit, isP2SH, isP2WSH);\n    if (finalScriptSig) this.data.updateInput(inputIndex, {\n      finalScriptSig\n    });\n    if (finalScriptWitness) this.data.updateInput(inputIndex, {\n      finalScriptWitness\n    });\n    if (!finalScriptSig && !finalScriptWitness) throw new Error(\"Unknown error finalizing input #\".concat(inputIndex));\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  _finalizeTaprootInput(inputIndex, input, tapLeafHashToFinalize) {\n    let finalScriptsFunc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : bip371_1.tapScriptFinalizer;\n    if (!input.witnessUtxo) throw new Error(\"Cannot finalize input #\".concat(inputIndex, \". Missing withness utxo.\"));\n    // Check key spend first. Increased privacy and reduced block space.\n    if (input.tapKeySig) {\n      const payment = payments.p2tr({\n        output: input.witnessUtxo.script,\n        signature: input.tapKeySig\n      });\n      const finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(payment.witness);\n      this.data.updateInput(inputIndex, {\n        finalScriptWitness\n      });\n    } else {\n      const {\n        finalScriptWitness\n      } = finalScriptsFunc(inputIndex, input, tapLeafHashToFinalize);\n      this.data.updateInput(inputIndex, {\n        finalScriptWitness\n      });\n    }\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  getInputType(inputIndex) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);\n    const result = getMeaningfulScript(script, inputIndex, 'input', input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig), input.witnessScript || redeemFromFinalWitnessScript(input.finalScriptWitness));\n    const type = result.type === 'raw' ? '' : result.type + '-';\n    const mainType = classifyScript(result.meaningfulScript);\n    return type + mainType;\n  }\n  inputHasPubkey(inputIndex, pubkey) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);\n  }\n  inputHasHDKey(inputIndex, root) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine);\n  }\n  outputHasPubkey(outputIndex, pubkey) {\n    const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);\n    return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);\n  }\n  outputHasHDKey(outputIndex, root) {\n    const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine);\n  }\n  validateSignaturesOfAllInputs(validator) {\n    (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one\n    const results = range(this.data.inputs.length).map(idx => this.validateSignaturesOfInput(idx, validator));\n    return results.reduce((final, res) => res === true && final, true);\n  }\n  validateSignaturesOfInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    if ((0, bip371_1.isTaprootInput)(input)) return this.validateSignaturesOfTaprootInput(inputIndex, validator, pubkey);\n    return this._validateSignaturesOfInput(inputIndex, validator, pubkey);\n  }\n  _validateSignaturesOfInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const partialSig = (input || {}).partialSig;\n    if (!input || !partialSig || partialSig.length < 1) throw new Error('No signatures to validate');\n    if (typeof validator !== 'function') throw new Error('Need validator function to validate signatures');\n    const mySigs = pubkey ? partialSig.filter(sig => sig.pubkey.equals(pubkey)) : partialSig;\n    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');\n    const results = [];\n    let hashCache;\n    let scriptCache;\n    let sighashCache;\n    for (const pSig of mySigs) {\n      const sig = bscript.signature.decode(pSig.signature);\n      const {\n        hash,\n        script\n      } = sighashCache !== sig.hashType ? getHashForSig(inputIndex, Object.assign({}, input, {\n        sighashType: sig.hashType\n      }), this.__CACHE, true) : {\n        hash: hashCache,\n        script: scriptCache\n      };\n      sighashCache = sig.hashType;\n      hashCache = hash;\n      scriptCache = script;\n      checkScriptForPubkey(pSig.pubkey, script, 'verify');\n      results.push(validator(pSig.pubkey, hash, sig.signature));\n    }\n    return results.every(res => res === true);\n  }\n  validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const tapKeySig = (input || {}).tapKeySig;\n    const tapScriptSig = (input || {}).tapScriptSig;\n    if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length)) throw new Error('No signatures to validate');\n    if (typeof validator !== 'function') throw new Error('Need validator function to validate signatures');\n    pubkey = pubkey && (0, bip371_1.toXOnly)(pubkey);\n    const allHashses = pubkey ? getTaprootHashesForSig(inputIndex, input, this.data.inputs, pubkey, this.__CACHE) : getAllTaprootHashesForSig(inputIndex, input, this.data.inputs, this.__CACHE);\n    if (!allHashses.length) throw new Error('No signatures for this pubkey');\n    const tapKeyHash = allHashses.find(h => !h.leafHash);\n    let validationResultCount = 0;\n    if (tapKeySig && tapKeyHash) {\n      const isValidTapkeySig = validator(tapKeyHash.pubkey, tapKeyHash.hash, trimTaprootSig(tapKeySig));\n      if (!isValidTapkeySig) return false;\n      validationResultCount++;\n    }\n    if (tapScriptSig) {\n      for (const tapSig of tapScriptSig) {\n        const tapSigHash = allHashses.find(h => tapSig.pubkey.equals(h.pubkey));\n        if (tapSigHash) {\n          const isValidTapScriptSig = validator(tapSig.pubkey, tapSigHash.hash, trimTaprootSig(tapSig.signature));\n          if (!isValidTapScriptSig) return false;\n          validationResultCount++;\n        }\n      }\n    }\n    return validationResultCount > 0;\n  }\n  signAllInputsHD(hdKeyPair) {\n    let sighashTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [transaction_1.Transaction.SIGHASH_ALL];\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInputHD(i, hdKeyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsHDAsync(hdKeyPair) {\n    let sighashTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [transaction_1.Transaction.SIGHASH_ALL];\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const results = [];\n      const promises = [];\n      for (const i of range(this.data.inputs.length)) {\n        promises.push(this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(() => {\n          results.push(true);\n        }, () => {\n          results.push(false);\n        }));\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInputHD(inputIndex, hdKeyPair) {\n    let sighashTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [transaction_1.Transaction.SIGHASH_ALL];\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));\n    return this;\n  }\n  signInputHDAsync(inputIndex, hdKeyPair) {\n    let sighashTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [transaction_1.Transaction.SIGHASH_ALL];\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n      const promises = signers.map(signer => this.signInputAsync(inputIndex, signer, sighashTypes));\n      return Promise.all(promises).then(() => {\n        resolve();\n      }).catch(reject);\n    });\n  }\n  signAllInputs(keyPair, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input');\n    // TODO: Add a pubkey/pubkeyhash cache to each input\n    // as input information is added, then eventually\n    // optimize this method.\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInput(i, keyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsAsync(keyPair, sighashTypes) {\n    return new Promise((resolve, reject) => {\n      if (!keyPair || !keyPair.publicKey) return reject(new Error('Need Signer to sign input'));\n      // TODO: Add a pubkey/pubkeyhash cache to each input\n      // as input information is added, then eventually\n      // optimize this method.\n      const results = [];\n      const promises = [];\n      for (const [i] of this.data.inputs.entries()) {\n        promises.push(this.signInputAsync(i, keyPair, sighashTypes).then(() => {\n          results.push(true);\n        }, () => {\n          results.push(false);\n        }));\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInput(inputIndex, keyPair, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input');\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input)) {\n      return this._signTaprootInput(inputIndex, input, keyPair, undefined, sighashTypes);\n    }\n    return this._signInput(inputIndex, keyPair, sighashTypes);\n  }\n  signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input');\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input)) return this._signTaprootInput(inputIndex, input, keyPair, tapLeafHashToSign, sighashTypes);\n    throw new Error(\"Input #\".concat(inputIndex, \" is not of type Taproot.\"));\n  }\n  _signInput(inputIndex, keyPair) {\n    let sighashTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [transaction_1.Transaction.SIGHASH_ALL];\n    const {\n      hash,\n      sighashType\n    } = getHashAndSighashType(this.data.inputs, inputIndex, keyPair.publicKey, this.__CACHE, sighashTypes);\n    const partialSig = [{\n      pubkey: keyPair.publicKey,\n      signature: bscript.signature.encode(keyPair.sign(hash), sighashType)\n    }];\n    this.data.updateInput(inputIndex, {\n      partialSig\n    });\n    return this;\n  }\n  _signTaprootInput(inputIndex, input, keyPair, tapLeafHashToSign) {\n    let allowedSighashTypes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [transaction_1.Transaction.SIGHASH_DEFAULT];\n    const hashesForSig = this.checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes);\n    const tapKeySig = hashesForSig.filter(h => !h.leafHash).map(h => (0, bip371_1.serializeTaprootSignature)(keyPair.signSchnorr(h.hash), input.sighashType))[0];\n    const tapScriptSig = hashesForSig.filter(h => !!h.leafHash).map(h => ({\n      pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),\n      signature: (0, bip371_1.serializeTaprootSignature)(keyPair.signSchnorr(h.hash), input.sighashType),\n      leafHash: h.leafHash\n    }));\n    if (tapKeySig) {\n      this.data.updateInput(inputIndex, {\n        tapKeySig\n      });\n    }\n    if (tapScriptSig.length) {\n      this.data.updateInput(inputIndex, {\n        tapScriptSig\n      });\n    }\n    return this;\n  }\n  signInputAsync(inputIndex, keyPair, sighashTypes) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input');\n      const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n      if ((0, bip371_1.isTaprootInput)(input)) return this._signTaprootInputAsync(inputIndex, input, keyPair, undefined, sighashTypes);\n      return this._signInputAsync(inputIndex, keyPair, sighashTypes);\n    });\n  }\n  signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input');\n      const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n      if ((0, bip371_1.isTaprootInput)(input)) return this._signTaprootInputAsync(inputIndex, input, keyPair, tapLeafHash, sighashTypes);\n      throw new Error(\"Input #\".concat(inputIndex, \" is not of type Taproot.\"));\n    });\n  }\n  _signInputAsync(inputIndex, keyPair) {\n    let sighashTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [transaction_1.Transaction.SIGHASH_ALL];\n    const {\n      hash,\n      sighashType\n    } = getHashAndSighashType(this.data.inputs, inputIndex, keyPair.publicKey, this.__CACHE, sighashTypes);\n    return Promise.resolve(keyPair.sign(hash)).then(signature => {\n      const partialSig = [{\n        pubkey: keyPair.publicKey,\n        signature: bscript.signature.encode(signature, sighashType)\n      }];\n      this.data.updateInput(inputIndex, {\n        partialSig\n      });\n    });\n  }\n  async _signTaprootInputAsync(inputIndex, input, keyPair, tapLeafHash) {\n    let sighashTypes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [transaction_1.Transaction.SIGHASH_DEFAULT];\n    const hashesForSig = this.checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHash, sighashTypes);\n    const signaturePromises = [];\n    const tapKeyHash = hashesForSig.filter(h => !h.leafHash)[0];\n    if (tapKeyHash) {\n      const tapKeySigPromise = Promise.resolve(keyPair.signSchnorr(tapKeyHash.hash)).then(sig => {\n        return {\n          tapKeySig: (0, bip371_1.serializeTaprootSignature)(sig, input.sighashType)\n        };\n      });\n      signaturePromises.push(tapKeySigPromise);\n    }\n    const tapScriptHashes = hashesForSig.filter(h => !!h.leafHash);\n    if (tapScriptHashes.length) {\n      const tapScriptSigPromises = tapScriptHashes.map(tsh => {\n        return Promise.resolve(keyPair.signSchnorr(tsh.hash)).then(signature => {\n          const tapScriptSig = [{\n            pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),\n            signature: (0, bip371_1.serializeTaprootSignature)(signature, input.sighashType),\n            leafHash: tsh.leafHash\n          }];\n          return {\n            tapScriptSig\n          };\n        });\n      });\n      signaturePromises.push(...tapScriptSigPromises);\n    }\n    return Promise.all(signaturePromises).then(results => {\n      results.forEach(v => this.data.updateInput(inputIndex, v));\n    });\n  }\n  checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes) {\n    if (typeof keyPair.signSchnorr !== 'function') throw new Error(\"Need Schnorr Signer to sign taproot input #\".concat(inputIndex, \".\"));\n    const hashesForSig = getTaprootHashesForSig(inputIndex, input, this.data.inputs, keyPair.publicKey, this.__CACHE, tapLeafHashToSign, allowedSighashTypes);\n    if (!hashesForSig || !hashesForSig.length) throw new Error(\"Can not sign for input #\".concat(inputIndex, \" with the key \").concat(keyPair.publicKey.toString('hex')));\n    return hashesForSig;\n  }\n  toBuffer() {\n    checkCache(this.__CACHE);\n    return this.data.toBuffer();\n  }\n  toHex() {\n    checkCache(this.__CACHE);\n    return this.data.toHex();\n  }\n  toBase64() {\n    checkCache(this.__CACHE);\n    return this.data.toBase64();\n  }\n  updateGlobal(updateData) {\n    this.data.updateGlobal(updateData);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);\n    (0, bip371_1.checkTaprootInputFields)(this.data.inputs[inputIndex], updateData, 'updateInput');\n    this.data.updateInput(inputIndex, updateData);\n    if (updateData.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, this.data.inputs[inputIndex], inputIndex);\n    }\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    const outputData = this.data.outputs[outputIndex];\n    (0, bip371_1.checkTaprootOutputFields)(outputData, updateData, 'updateOutput');\n    this.data.updateOutput(outputIndex, updateData);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    this.data.addUnknownKeyValToGlobal(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    this.data.addUnknownKeyValToInput(inputIndex, keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n}\nexports.Psbt = Psbt;\n/**\n * This function is needed to pass to the bip174 base class's fromBuffer.\n * It takes the \"transaction buffer\" portion of the psbt buffer and returns a\n * Transaction (From the bip174 library) interface.\n */\nconst transactionFromBuffer = buffer => new PsbtTransaction(buffer);\n/**\n * This class implements the Transaction interface from bip174 library.\n * It contains a bitcoinjs-lib Transaction object.\n */\nclass PsbtTransaction {\n  constructor() {\n    let buffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    this.tx = transaction_1.Transaction.fromBuffer(buffer);\n    checkTxEmpty(this.tx);\n    Object.defineProperty(this, 'tx', {\n      enumerable: false,\n      writable: true\n    });\n  }\n  getInputOutputCounts() {\n    return {\n      inputCount: this.tx.ins.length,\n      outputCount: this.tx.outs.length\n    };\n  }\n  addInput(input) {\n    if (input.hash === undefined || input.index === undefined || !Buffer.isBuffer(input.hash) && typeof input.hash !== 'string' || typeof input.index !== 'number') {\n      throw new Error('Error adding input.');\n    }\n    const hash = typeof input.hash === 'string' ? (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash, 'hex')) : input.hash;\n    this.tx.addInput(hash, input.index, input.sequence);\n  }\n  addOutput(output) {\n    if (output.script === undefined || output.value === undefined || !Buffer.isBuffer(output.script) || typeof output.value !== 'number') {\n      throw new Error('Error adding output.');\n    }\n    this.tx.addOutput(output.script, output.value);\n  }\n  toBuffer() {\n    return this.tx.toBuffer();\n  }\n}\nfunction canFinalize(input, script, scriptType) {\n  switch (scriptType) {\n    case 'pubkey':\n    case 'pubkeyhash':\n    case 'witnesspubkeyhash':\n      return hasSigs(1, input.partialSig);\n    case 'multisig':\n      const p2ms = payments.p2ms({\n        output: script\n      });\n      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);\n    default:\n      return false;\n  }\n}\nfunction checkCache(cache) {\n  if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {\n    throw new Error('Not BIP174 compliant, can not export');\n  }\n}\nfunction hasSigs(neededSigs, partialSig, pubkeys) {\n  if (!partialSig) return false;\n  let sigs;\n  if (pubkeys) {\n    sigs = pubkeys.map(pkey => {\n      const pubkey = compressPubkey(pkey);\n      return partialSig.find(pSig => pSig.pubkey.equals(pubkey));\n    }).filter(v => !!v);\n  } else {\n    sigs = partialSig;\n  }\n  if (sigs.length > neededSigs) throw new Error('Too many signatures');\n  return sigs.length === neededSigs;\n}\nfunction isFinalized(input) {\n  return !!input.finalScriptSig || !!input.finalScriptWitness;\n}\nfunction bip32DerivationIsMine(root) {\n  return d => {\n    if (!d.masterFingerprint.equals(root.fingerprint)) return false;\n    if (!root.derivePath(d.path).publicKey.equals(d.pubkey)) return false;\n    return true;\n  };\n}\nfunction check32Bit(num) {\n  if (typeof num !== 'number' || num !== Math.floor(num) || num > 0xffffffff || num < 0) {\n    throw new Error('Invalid 32 bit integer');\n  }\n}\nfunction checkFees(psbt, cache, opts) {\n  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();\n  const vsize = cache.__EXTRACTED_TX.virtualSize();\n  const satoshis = feeRate * vsize;\n  if (feeRate >= opts.maximumFeeRate) {\n    throw new Error(\"Warning: You are paying around \".concat((satoshis / 1e8).toFixed(8), \" in \") + \"fees, which is \".concat(feeRate, \" satoshi per byte for a transaction \") + \"with a VSize of \".concat(vsize, \" bytes (segwit counted as 0.25 byte per \") + \"byte). Use setMaximumFeeRate method to raise your threshold, or \" + \"pass true to the first arg of extractTransaction.\");\n  }\n}\nfunction checkInputsForPartialSig(inputs, action) {\n  inputs.forEach(input => {\n    const throws = (0, bip371_1.isTaprootInput)(input) ? (0, bip371_1.checkTaprootInputForSigs)(input, action) : (0, psbtutils_1.checkInputForSig)(input, action);\n    if (throws) throw new Error('Can not modify transaction, signatures exist.');\n  });\n}\nfunction checkPartialSigSighashes(input) {\n  if (!input.sighashType || !input.partialSig) return;\n  const {\n    partialSig,\n    sighashType\n  } = input;\n  partialSig.forEach(pSig => {\n    const {\n      hashType\n    } = bscript.signature.decode(pSig.signature);\n    if (sighashType !== hashType) {\n      throw new Error('Signature sighash does not match input sighash type');\n    }\n  });\n}\nfunction checkScriptForPubkey(pubkey, script, action) {\n  if (!(0, psbtutils_1.pubkeyInScript)(pubkey, script)) {\n    throw new Error(\"Can not \".concat(action, \" for this input with the key \").concat(pubkey.toString('hex')));\n  }\n}\nfunction checkTxEmpty(tx) {\n  const isEmpty = tx.ins.every(input => input.script && input.script.length === 0 && input.witness && input.witness.length === 0);\n  if (!isEmpty) {\n    throw new Error('Format Error: Transaction ScriptSigs are not empty');\n  }\n}\nfunction checkTxForDupeIns(tx, cache) {\n  tx.ins.forEach(input => {\n    checkTxInputCache(cache, input);\n  });\n}\nfunction checkTxInputCache(cache, input) {\n  const key = (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash)).toString('hex') + ':' + input.index;\n  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');\n  cache.__TX_IN_CACHE[key] = 1;\n}\nfunction scriptCheckerFactory(payment, paymentScriptName) {\n  return (inputIndex, scriptPubKey, redeemScript, ioType) => {\n    const redeemScriptOutput = payment({\n      redeem: {\n        output: redeemScript\n      }\n    }).output;\n    if (!scriptPubKey.equals(redeemScriptOutput)) {\n      throw new Error(\"\".concat(paymentScriptName, \" for \").concat(ioType, \" #\").concat(inputIndex, \" doesn't match the scriptPubKey in the prevout\"));\n    }\n  };\n}\nconst checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');\nconst checkWitnessScript = scriptCheckerFactory(payments.p2wsh, 'Witness script');\nfunction getTxCacheValue(key, name, inputs, c) {\n  if (!inputs.every(isFinalized)) throw new Error(\"PSBT must be finalized to calculate \".concat(name));\n  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;\n  if (key === '__FEE' && c.__FEE) return c.__FEE;\n  let tx;\n  let mustFinalize = true;\n  if (c.__EXTRACTED_TX) {\n    tx = c.__EXTRACTED_TX;\n    mustFinalize = false;\n  } else {\n    tx = c.__TX.clone();\n  }\n  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);\n  if (key === '__FEE_RATE') return c.__FEE_RATE;else if (key === '__FEE') return c.__FEE;\n}\nfunction getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {\n  const scriptType = classifyScript(script);\n  if (!canFinalize(input, script, scriptType)) throw new Error(\"Can not finalize input #\".concat(inputIndex));\n  return prepareFinalScripts(script, scriptType, input.partialSig, isSegwit, isP2SH, isP2WSH);\n}\nfunction prepareFinalScripts(script, scriptType, partialSig, isSegwit, isP2SH, isP2WSH) {\n  let finalScriptSig;\n  let finalScriptWitness;\n  // Wow, the payments API is very handy\n  const payment = getPayment(script, scriptType, partialSig);\n  const p2wsh = !isP2WSH ? null : payments.p2wsh({\n    redeem: payment\n  });\n  const p2sh = !isP2SH ? null : payments.p2sh({\n    redeem: p2wsh || payment\n  });\n  if (isSegwit) {\n    if (p2wsh) {\n      finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(p2wsh.witness);\n    } else {\n      finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(payment.witness);\n    }\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    }\n  } else {\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    } else {\n      finalScriptSig = payment.input;\n    }\n  }\n  return {\n    finalScriptSig,\n    finalScriptWitness\n  };\n}\nfunction getHashAndSighashType(inputs, inputIndex, pubkey, cache, sighashTypes) {\n  const input = (0, utils_1.checkForInput)(inputs, inputIndex);\n  const {\n    hash,\n    sighashType,\n    script\n  } = getHashForSig(inputIndex, input, cache, false, sighashTypes);\n  checkScriptForPubkey(pubkey, script, 'sign');\n  return {\n    hash,\n    sighashType\n  };\n}\nfunction getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {\n  const unsignedTx = cache.__TX;\n  const sighashType = input.sighashType || transaction_1.Transaction.SIGHASH_ALL;\n  checkSighashTypeAllowed(sighashType, sighashTypes);\n  let hash;\n  let prevout;\n  if (input.nonWitnessUtxo) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);\n    const prevoutHash = unsignedTx.ins[inputIndex].hash;\n    const utxoHash = nonWitnessUtxoTx.getHash();\n    // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout\n    if (!prevoutHash.equals(utxoHash)) {\n      throw new Error(\"Non-witness UTXO hash for input #\".concat(inputIndex, \" doesn't match the hash specified in the prevout\"));\n    }\n    const prevoutIndex = unsignedTx.ins[inputIndex].index;\n    prevout = nonWitnessUtxoTx.outs[prevoutIndex];\n  } else if (input.witnessUtxo) {\n    prevout = input.witnessUtxo;\n  } else {\n    throw new Error('Need a Utxo input item for signing');\n  }\n  const {\n    meaningfulScript,\n    type\n  } = getMeaningfulScript(prevout.script, inputIndex, 'input', input.redeemScript, input.witnessScript);\n  if (['p2sh-p2wsh', 'p2wsh'].indexOf(type) >= 0) {\n    hash = unsignedTx.hashForWitnessV0(inputIndex, meaningfulScript, prevout.value, sighashType);\n  } else if ((0, psbtutils_1.isP2WPKH)(meaningfulScript)) {\n    // P2WPKH uses the P2PKH template for prevoutScript when signing\n    const signingScript = payments.p2pkh({\n      hash: meaningfulScript.slice(2)\n    }).output;\n    hash = unsignedTx.hashForWitnessV0(inputIndex, signingScript, prevout.value, sighashType);\n  } else {\n    // non-segwit\n    if (input.nonWitnessUtxo === undefined && cache.__UNSAFE_SIGN_NONSEGWIT === false) throw new Error(\"Input #\".concat(inputIndex, \" has witnessUtxo but non-segwit script: \") + \"\".concat(meaningfulScript.toString('hex')));\n    if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false) console.warn('Warning: Signing non-segwit inputs without the full parent transaction ' + 'means there is a chance that a miner could feed you incorrect information ' + \"to trick you into paying large fees. This behavior is the same as Psbt's predecesor \" + '(TransactionBuilder - now removed) when signing non-segwit scripts. You are not ' + 'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' + 'BIP174 compliant.\\n*********************\\nPROCEED WITH CAUTION!\\n' + '*********************');\n    hash = unsignedTx.hashForSignature(inputIndex, meaningfulScript, sighashType);\n  }\n  return {\n    script: meaningfulScript,\n    sighashType,\n    hash\n  };\n}\nfunction getAllTaprootHashesForSig(inputIndex, input, inputs, cache) {\n  const allPublicKeys = [];\n  if (input.tapInternalKey) {\n    const key = getPrevoutTaprootKey(inputIndex, input, cache);\n    if (key) {\n      allPublicKeys.push(key);\n    }\n  }\n  if (input.tapScriptSig) {\n    const tapScriptPubkeys = input.tapScriptSig.map(tss => tss.pubkey);\n    allPublicKeys.push(...tapScriptPubkeys);\n  }\n  const allHashes = allPublicKeys.map(pubicKey => getTaprootHashesForSig(inputIndex, input, inputs, pubicKey, cache));\n  return allHashes.flat();\n}\nfunction getPrevoutTaprootKey(inputIndex, input, cache) {\n  const {\n    script\n  } = getScriptAndAmountFromUtxo(inputIndex, input, cache);\n  return (0, psbtutils_1.isP2TR)(script) ? script.subarray(2, 34) : null;\n}\nfunction trimTaprootSig(signature) {\n  return signature.length === 64 ? signature : signature.subarray(0, 64);\n}\nfunction getTaprootHashesForSig(inputIndex, input, inputs, pubkey, cache, tapLeafHashToSign, allowedSighashTypes) {\n  const unsignedTx = cache.__TX;\n  const sighashType = input.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;\n  checkSighashTypeAllowed(sighashType, allowedSighashTypes);\n  const prevOuts = inputs.map((i, index) => getScriptAndAmountFromUtxo(index, i, cache));\n  const signingScripts = prevOuts.map(o => o.script);\n  const values = prevOuts.map(o => o.value);\n  const hashes = [];\n  if (input.tapInternalKey && !tapLeafHashToSign) {\n    const outputKey = getPrevoutTaprootKey(inputIndex, input, cache) || Buffer.from([]);\n    if ((0, bip371_1.toXOnly)(pubkey).equals(outputKey)) {\n      const tapKeyHash = unsignedTx.hashForWitnessV1(inputIndex, signingScripts, values, sighashType);\n      hashes.push({\n        pubkey,\n        hash: tapKeyHash\n      });\n    }\n  }\n  const tapLeafHashes = (input.tapLeafScript || []).filter(tapLeaf => (0, psbtutils_1.pubkeyInScript)(pubkey, tapLeaf.script)).map(tapLeaf => {\n    const hash = (0, bip341_1.tapleafHash)({\n      output: tapLeaf.script,\n      version: tapLeaf.leafVersion\n    });\n    return Object.assign({\n      hash\n    }, tapLeaf);\n  }).filter(tapLeaf => !tapLeafHashToSign || tapLeafHashToSign.equals(tapLeaf.hash)).map(tapLeaf => {\n    const tapScriptHash = unsignedTx.hashForWitnessV1(inputIndex, signingScripts, values, transaction_1.Transaction.SIGHASH_DEFAULT, tapLeaf.hash);\n    return {\n      pubkey,\n      hash: tapScriptHash,\n      leafHash: tapLeaf.hash\n    };\n  });\n  return hashes.concat(tapLeafHashes);\n}\nfunction checkSighashTypeAllowed(sighashType, sighashTypes) {\n  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {\n    const str = sighashTypeToString(sighashType);\n    throw new Error(\"Sighash type is not allowed. Retry the sign method passing the \" + \"sighashTypes array of whitelisted types. Sighash type: \".concat(str));\n  }\n}\nfunction getPayment(script, scriptType, partialSig) {\n  let payment;\n  switch (scriptType) {\n    case 'multisig':\n      const sigs = getSortedSigs(script, partialSig);\n      payment = payments.p2ms({\n        output: script,\n        signatures: sigs\n      });\n      break;\n    case 'pubkey':\n      payment = payments.p2pk({\n        output: script,\n        signature: partialSig[0].signature\n      });\n      break;\n    case 'pubkeyhash':\n      payment = payments.p2pkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature\n      });\n      break;\n    case 'witnesspubkeyhash':\n      payment = payments.p2wpkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature\n      });\n      break;\n  }\n  return payment;\n}\nfunction getScriptFromInput(inputIndex, input, cache) {\n  const unsignedTx = cache.__TX;\n  const res = {\n    script: null,\n    isSegwit: false,\n    isP2SH: false,\n    isP2WSH: false\n  };\n  res.isP2SH = !!input.redeemScript;\n  res.isP2WSH = !!input.witnessScript;\n  if (input.witnessScript) {\n    res.script = input.witnessScript;\n  } else if (input.redeemScript) {\n    res.script = input.redeemScript;\n  } else {\n    if (input.nonWitnessUtxo) {\n      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);\n      const prevoutIndex = unsignedTx.ins[inputIndex].index;\n      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;\n    } else if (input.witnessUtxo) {\n      res.script = input.witnessUtxo.script;\n    }\n  }\n  if (input.witnessScript || (0, psbtutils_1.isP2WPKH)(res.script)) {\n    res.isSegwit = true;\n  }\n  return res;\n}\nfunction getSignersFromHD(inputIndex, inputs, hdKeyPair) {\n  const input = (0, utils_1.checkForInput)(inputs, inputIndex);\n  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {\n    throw new Error('Need bip32Derivation to sign with HD');\n  }\n  const myDerivations = input.bip32Derivation.map(bipDv => {\n    if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {\n      return bipDv;\n    } else {\n      return;\n    }\n  }).filter(v => !!v);\n  if (myDerivations.length === 0) {\n    throw new Error('Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint');\n  }\n  const signers = myDerivations.map(bipDv => {\n    const node = hdKeyPair.derivePath(bipDv.path);\n    if (!bipDv.pubkey.equals(node.publicKey)) {\n      throw new Error('pubkey did not match bip32Derivation');\n    }\n    return node;\n  });\n  return signers;\n}\nfunction getSortedSigs(script, partialSig) {\n  const p2ms = payments.p2ms({\n    output: script\n  });\n  // for each pubkey in order of p2ms script\n  return p2ms.pubkeys.map(pk => {\n    // filter partialSig array by pubkey being equal\n    return (partialSig.filter(ps => {\n      return ps.pubkey.equals(pk);\n    })[0] || {}).signature;\n    // Any pubkey without a match will return undefined\n    // this last filter removes all the undefined items in the array.\n  }).filter(v => !!v);\n}\nfunction scriptWitnessToWitnessStack(buffer) {\n  let offset = 0;\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n  function readVarInt() {\n    const vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n  function readVector() {\n    const count = readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(readVarSlice());\n    return vector;\n  }\n  return readVector();\n}\nfunction sighashTypeToString(sighashType) {\n  let text = sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? 'SIGHASH_ANYONECANPAY | ' : '';\n  const sigMod = sighashType & 0x1f;\n  switch (sigMod) {\n    case transaction_1.Transaction.SIGHASH_ALL:\n      text += 'SIGHASH_ALL';\n      break;\n    case transaction_1.Transaction.SIGHASH_SINGLE:\n      text += 'SIGHASH_SINGLE';\n      break;\n    case transaction_1.Transaction.SIGHASH_NONE:\n      text += 'SIGHASH_NONE';\n      break;\n  }\n  return text;\n}\nfunction addNonWitnessTxCache(cache, input, inputIndex) {\n  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;\n  const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);\n  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;\n  const self = cache;\n  const selfIndex = inputIndex;\n  delete input.nonWitnessUtxo;\n  Object.defineProperty(input, 'nonWitnessUtxo', {\n    enumerable: true,\n    get() {\n      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];\n      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];\n      if (buf !== undefined) {\n        return buf;\n      } else {\n        const newBuf = txCache.toBuffer();\n        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;\n        return newBuf;\n      }\n    },\n    set(data) {\n      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;\n    }\n  });\n}\nfunction inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {\n  let inputAmount = 0;\n  inputs.forEach((input, idx) => {\n    if (mustFinalize && input.finalScriptSig) tx.ins[idx].script = input.finalScriptSig;\n    if (mustFinalize && input.finalScriptWitness) {\n      tx.ins[idx].witness = scriptWitnessToWitnessStack(input.finalScriptWitness);\n    }\n    if (input.witnessUtxo) {\n      inputAmount += input.witnessUtxo.value;\n    } else if (input.nonWitnessUtxo) {\n      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);\n      const vout = tx.ins[idx].index;\n      const out = nwTx.outs[vout];\n      inputAmount += out.value;\n    }\n  });\n  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);\n  const fee = inputAmount - outputAmount;\n  if (fee < 0) {\n    throw new Error('Outputs are spending more than Inputs');\n  }\n  const bytes = tx.virtualSize();\n  cache.__FEE = fee;\n  cache.__EXTRACTED_TX = tx;\n  cache.__FEE_RATE = Math.floor(fee / bytes);\n}\nfunction nonWitnessUtxoTxFromCache(cache, input, inputIndex) {\n  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;\n  if (!c[inputIndex]) {\n    addNonWitnessTxCache(cache, input, inputIndex);\n  }\n  return c[inputIndex];\n}\nfunction getScriptFromUtxo(inputIndex, input, cache) {\n  const {\n    script\n  } = getScriptAndAmountFromUtxo(inputIndex, input, cache);\n  return script;\n}\nfunction getScriptAndAmountFromUtxo(inputIndex, input, cache) {\n  if (input.witnessUtxo !== undefined) {\n    return {\n      script: input.witnessUtxo.script,\n      value: input.witnessUtxo.value\n    };\n  } else if (input.nonWitnessUtxo !== undefined) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);\n    const o = nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index];\n    return {\n      script: o.script,\n      value: o.value\n    };\n  } else {\n    throw new Error(\"Can't find pubkey in input without Utxo data\");\n  }\n}\nfunction pubkeyInInput(pubkey, input, inputIndex, cache) {\n  const script = getScriptFromUtxo(inputIndex, input, cache);\n  const {\n    meaningfulScript\n  } = getMeaningfulScript(script, inputIndex, 'input', input.redeemScript, input.witnessScript);\n  return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);\n}\nfunction pubkeyInOutput(pubkey, output, outputIndex, cache) {\n  const script = cache.__TX.outs[outputIndex].script;\n  const {\n    meaningfulScript\n  } = getMeaningfulScript(script, outputIndex, 'output', output.redeemScript, output.witnessScript);\n  return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);\n}\nfunction redeemFromFinalScriptSig(finalScript) {\n  if (!finalScript) return;\n  const decomp = bscript.decompile(finalScript);\n  if (!decomp) return;\n  const lastItem = decomp[decomp.length - 1];\n  if (!Buffer.isBuffer(lastItem) || isPubkeyLike(lastItem) || isSigLike(lastItem)) return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction redeemFromFinalWitnessScript(finalScript) {\n  if (!finalScript) return;\n  const decomp = scriptWitnessToWitnessStack(finalScript);\n  const lastItem = decomp[decomp.length - 1];\n  if (isPubkeyLike(lastItem)) return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction compressPubkey(pubkey) {\n  if (pubkey.length === 65) {\n    const parity = pubkey[64] & 1;\n    const newKey = pubkey.slice(0, 33);\n    newKey[0] = 2 | parity;\n    return newKey;\n  }\n  return pubkey.slice();\n}\nfunction isPubkeyLike(buf) {\n  return buf.length === 33 && bscript.isCanonicalPubKey(buf);\n}\nfunction isSigLike(buf) {\n  return bscript.isCanonicalScriptSignature(buf);\n}\nfunction getMeaningfulScript(script, index, ioType, redeemScript, witnessScript) {\n  const isP2SH = (0, psbtutils_1.isP2SHScript)(script);\n  const isP2SHP2WSH = isP2SH && redeemScript && (0, psbtutils_1.isP2WSHScript)(redeemScript);\n  const isP2WSH = (0, psbtutils_1.isP2WSHScript)(script);\n  if (isP2SH && redeemScript === undefined) throw new Error('scriptPubkey is P2SH but redeemScript missing');\n  if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined) throw new Error('scriptPubkey or redeemScript is P2WSH but witnessScript missing');\n  let meaningfulScript;\n  if (isP2SHP2WSH) {\n    meaningfulScript = witnessScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n    checkWitnessScript(index, redeemScript, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2WSH) {\n    meaningfulScript = witnessScript;\n    checkWitnessScript(index, script, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2SH) {\n    meaningfulScript = redeemScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n  } else {\n    meaningfulScript = script;\n  }\n  return {\n    meaningfulScript,\n    type: isP2SHP2WSH ? 'p2sh-p2wsh' : isP2SH ? 'p2sh' : isP2WSH ? 'p2wsh' : 'raw'\n  };\n}\nfunction checkInvalidP2WSH(script) {\n  if ((0, psbtutils_1.isP2WPKH)(script) || (0, psbtutils_1.isP2SHScript)(script)) {\n    throw new Error('P2WPKH or P2SH can not be contained within P2WSH');\n  }\n}\nfunction classifyScript(script) {\n  if ((0, psbtutils_1.isP2WPKH)(script)) return 'witnesspubkeyhash';\n  if ((0, psbtutils_1.isP2PKH)(script)) return 'pubkeyhash';\n  if ((0, psbtutils_1.isP2MS)(script)) return 'multisig';\n  if ((0, psbtutils_1.isP2PK)(script)) return 'pubkey';\n  return 'nonstandard';\n}\nfunction range(n) {\n  return [...Array(n).keys()];\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","Psbt","bip174_1","require","varuint","utils_1","address_1","bufferutils_1","networks_1","payments","bip341_1","bscript","transaction_1","bip371_1","psbtutils_1","DEFAULT_OPTS","network","bitcoin","maximumFeeRate","fromBase64","data","opts","arguments","length","undefined","buffer","Buffer","from","fromBuffer","fromHex","psbtBase","transactionFromBuffer","psbt","checkTxForDupeIns","__CACHE","__TX","constructor","PsbtTransaction","assign","__NON_WITNESS_UTXO_TX_CACHE","__NON_WITNESS_UTXO_BUF_CACHE","__TX_IN_CACHE","globalMap","unsignedTx","tx","__UNSAFE_SIGN_NONSEGWIT","inputs","setVersion","dpew","obj","attr","enumerable","writable","inputCount","version","locktime","setLocktime","txInputs","ins","map","input","hash","cloneBuffer","index","sequence","txOutputs","outs","output","address","fromOutputScript","script","_","combine","_len","those","Array","_key","o","clone","res","toBuffer","JSON","parse","stringify","setMaximumFeeRate","satoshiPerByte","check32Bit","checkInputsForPartialSig","c","__EXTRACTED_TX","setInputSequence","inputIndex","Error","addInputs","inputDatas","forEach","inputData","addInput","checkTaprootInputFields","witnessScript","checkInvalidP2WSH","txIn","checkTxInputCache","nonWitnessUtxo","addNonWitnessTxCache","__FEE","__FEE_RATE","addOutputs","outputDatas","outputData","addOutput","toOutputScript","checkTaprootOutputFields","extractTransaction","disableFeeCheck","every","isFinalized","checkFees","inputFinalizeGetAmts","getFeeRate","getTxCacheValue","getFee","finalizeAllInputs","checkForInput","range","idx","finalizeInput","finalScriptsFunc","isTaprootInput","_finalizeTaprootInput","_finalizeInput","finalizeTaprootInput","tapLeafHashToFinalize","tapScriptFinalizer","concat","getFinalScripts","isP2SH","isP2WSH","isSegwit","getScriptFromInput","checkPartialSigSighashes","finalScriptSig","finalScriptWitness","updateInput","clearFinalizedInput","witnessUtxo","tapKeySig","payment","p2tr","signature","witnessStackToScriptWitness","witness","getInputType","getScriptFromUtxo","result","getMeaningfulScript","redeemScript","redeemFromFinalScriptSig","redeemFromFinalWitnessScript","type","mainType","classifyScript","meaningfulScript","inputHasPubkey","pubkey","pubkeyInInput","inputHasHDKey","root","derivationIsMine","bip32DerivationIsMine","bip32Derivation","some","outputHasPubkey","outputIndex","checkForOutput","outputs","pubkeyInOutput","outputHasHDKey","validateSignaturesOfAllInputs","validator","results","validateSignaturesOfInput","reduce","final","validateSignaturesOfTaprootInput","_validateSignaturesOfInput","partialSig","mySigs","filter","sig","equals","hashCache","scriptCache","sighashCache","pSig","decode","hashType","getHashForSig","sighashType","checkScriptForPubkey","push","tapScriptSig","toXOnly","allHashses","getTaprootHashesForSig","getAllTaprootHashesForSig","tapKeyHash","find","h","leafHash","validationResultCount","isValidTapkeySig","trimTaprootSig","tapSig","tapSigHash","isValidTapScriptSig","signAllInputsHD","hdKeyPair","sighashTypes","Transaction","SIGHASH_ALL","publicKey","fingerprint","i","signInputHD","err","v","signAllInputsHDAsync","Promise","resolve","reject","promises","signInputHDAsync","then","all","signers","getSignersFromHD","signer","signInput","signInputAsync","catch","signAllInputs","keyPair","signAllInputsAsync","entries","_signTaprootInput","_signInput","signTaprootInput","tapLeafHashToSign","getHashAndSighashType","encode","sign","allowedSighashTypes","SIGHASH_DEFAULT","hashesForSig","checkTaprootHashesForSig","serializeTaprootSignature","signSchnorr","_signTaprootInputAsync","_signInputAsync","signTaprootInputAsync","tapLeafHash","signaturePromises","tapKeySigPromise","tapScriptHashes","tapScriptSigPromises","tsh","toString","checkCache","toHex","toBase64","updateGlobal","updateData","updateOutput","addUnknownKeyValToGlobal","keyVal","addUnknownKeyValToInput","addUnknownKeyValToOutput","checkTxEmpty","getInputOutputCounts","outputCount","isBuffer","reverseBuffer","canFinalize","scriptType","hasSigs","p2ms","m","pubkeys","cache","neededSigs","sigs","pkey","compressPubkey","d","masterFingerprint","derivePath","path","num","Math","floor","feeRate","vsize","virtualSize","satoshis","toFixed","action","throws","checkTaprootInputForSigs","checkInputForSig","pubkeyInScript","isEmpty","key","scriptCheckerFactory","paymentScriptName","scriptPubKey","ioType","redeemScriptOutput","redeem","checkRedeemScript","p2sh","checkWitnessScript","p2wsh","name","mustFinalize","prepareFinalScripts","getPayment","forValidate","checkSighashTypeAllowed","prevout","nonWitnessUtxoTx","nonWitnessUtxoTxFromCache","prevoutHash","utxoHash","getHash","prevoutIndex","indexOf","hashForWitnessV0","isP2WPKH","signingScript","p2pkh","slice","console","warn","hashForSignature","allPublicKeys","tapInternalKey","getPrevoutTaprootKey","tapScriptPubkeys","tss","allHashes","pubicKey","flat","getScriptAndAmountFromUtxo","isP2TR","subarray","prevOuts","signingScripts","values","hashes","outputKey","hashForWitnessV1","tapLeafHashes","tapLeafScript","tapLeaf","tapleafHash","leafVersion","tapScriptHash","str","sighashTypeToString","getSortedSigs","signatures","p2pk","p2wpkh","myDerivations","bipDv","node","pk","ps","scriptWitnessToWitnessStack","offset","readSlice","n","readVarInt","vi","bytes","readVarSlice","readVector","count","vector","text","SIGHASH_ANYONECANPAY","sigMod","SIGHASH_SINGLE","SIGHASH_NONE","self","selfIndex","get","buf","txCache","newBuf","set","inputAmount","nwTx","vout","out","outputAmount","total","fee","finalScript","decomp","decompile","lastItem","isPubkeyLike","isSigLike","sDecomp","parity","newKey","isCanonicalPubKey","isCanonicalScriptSignature","isP2SHScript","isP2SHP2WSH","isP2WSHScript","isP2PKH","isP2MS","isP2PK","keys"],"sources":["/workspace/Planq-Dapps/vesting-portal/node_modules/bitcoinjs-lib/src/psbt.js"],"sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.Psbt = void 0;\nconst bip174_1 = require('bip174');\nconst varuint = require('bip174/src/lib/converter/varint');\nconst utils_1 = require('bip174/src/lib/utils');\nconst address_1 = require('./address');\nconst bufferutils_1 = require('./bufferutils');\nconst networks_1 = require('./networks');\nconst payments = require('./payments');\nconst bip341_1 = require('./payments/bip341');\nconst bscript = require('./script');\nconst transaction_1 = require('./transaction');\nconst bip371_1 = require('./psbt/bip371');\nconst psbtutils_1 = require('./psbt/psbtutils');\n/**\n * These are the default arguments for a Psbt instance.\n */\nconst DEFAULT_OPTS = {\n  /**\n   * A bitcoinjs Network object. This is only used if you pass an `address`\n   * parameter to addOutput. Otherwise it is not needed and can be left default.\n   */\n  network: networks_1.bitcoin,\n  /**\n   * When extractTransaction is called, the fee rate is checked.\n   * THIS IS NOT TO BE RELIED ON.\n   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.\n   */\n  maximumFeeRate: 5000, // satoshi per byte\n};\n/**\n * Psbt class can parse and generate a PSBT binary based off of the BIP174.\n * There are 6 roles that this class fulfills. (Explained in BIP174)\n *\n * Creator: This can be done with `new Psbt()`\n * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,\n *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to\n *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,\n *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`\n *   addInput requires hash: Buffer | string; and index: number; as attributes\n *   and can also include any attributes that are used in updateInput method.\n *   addOutput requires script: Buffer; and value: number; and likewise can include\n *   data for updateOutput.\n *   For a list of what attributes should be what types. Check the bip174 library.\n *   Also, check the integration tests for some examples of usage.\n * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input\n *   information for your pubkey or pubkeyhash, and only sign inputs where it finds\n *   your info. Or you can explicitly sign a specific input with signInput and\n *   signInputAsync. For the async methods you can create a SignerAsync object\n *   and use something like a hardware wallet to sign with. (You must implement this)\n * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`\n *   the psbt calling combine will always have precedence when a conflict occurs.\n *   Combine checks if the internal bitcoin transaction is the same, so be sure that\n *   all sequences, version, locktime, etc. are the same before combining.\n * Input Finalizer: This role is fairly important. Not only does it need to construct\n *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.\n *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`\n *   Running any finalize method will delete any data in the input(s) that are no longer\n *   needed due to the finalized scripts containing the information.\n * Transaction Extractor: This role will perform some checks before returning a\n *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.\n */\nclass Psbt {\n  static fromBase64(data, opts = {}) {\n    const buffer = Buffer.from(data, 'base64');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromHex(data, opts = {}) {\n    const buffer = Buffer.from(data, 'hex');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromBuffer(buffer, opts = {}) {\n    const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);\n    const psbt = new Psbt(opts, psbtBase);\n    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);\n    return psbt;\n  }\n  constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {\n    this.data = data;\n    // set defaults\n    this.opts = Object.assign({}, DEFAULT_OPTS, opts);\n    this.__CACHE = {\n      __NON_WITNESS_UTXO_TX_CACHE: [],\n      __NON_WITNESS_UTXO_BUF_CACHE: [],\n      __TX_IN_CACHE: {},\n      __TX: this.data.globalMap.unsignedTx.tx,\n      // Psbt's predecesor (TransactionBuilder - now removed) behavior\n      // was to not confirm input values  before signing.\n      // Even though we highly encourage people to get\n      // the full parent transaction to verify values, the ability to\n      // sign non-segwit inputs without the full transaction was often\n      // requested. So the only way to activate is to use @ts-ignore.\n      // We will disable exporting the Psbt when unsafe sign is active.\n      // because it is not BIP174 compliant.\n      __UNSAFE_SIGN_NONSEGWIT: false,\n    };\n    if (this.data.inputs.length === 0) this.setVersion(2);\n    // Make data hidden when enumerating\n    const dpew = (obj, attr, enumerable, writable) =>\n      Object.defineProperty(obj, attr, {\n        enumerable,\n        writable,\n      });\n    dpew(this, '__CACHE', false, true);\n    dpew(this, 'opts', false, true);\n  }\n  get inputCount() {\n    return this.data.inputs.length;\n  }\n  get version() {\n    return this.__CACHE.__TX.version;\n  }\n  set version(version) {\n    this.setVersion(version);\n  }\n  get locktime() {\n    return this.__CACHE.__TX.locktime;\n  }\n  set locktime(locktime) {\n    this.setLocktime(locktime);\n  }\n  get txInputs() {\n    return this.__CACHE.__TX.ins.map(input => ({\n      hash: (0, bufferutils_1.cloneBuffer)(input.hash),\n      index: input.index,\n      sequence: input.sequence,\n    }));\n  }\n  get txOutputs() {\n    return this.__CACHE.__TX.outs.map(output => {\n      let address;\n      try {\n        address = (0, address_1.fromOutputScript)(\n          output.script,\n          this.opts.network,\n        );\n      } catch (_) {}\n      return {\n        script: (0, bufferutils_1.cloneBuffer)(output.script),\n        value: output.value,\n        address,\n      };\n    });\n  }\n  combine(...those) {\n    this.data.combine(...those.map(o => o.data));\n    return this;\n  }\n  clone() {\n    // TODO: more efficient cloning\n    const res = Psbt.fromBuffer(this.data.toBuffer());\n    res.opts = JSON.parse(JSON.stringify(this.opts));\n    return res;\n  }\n  setMaximumFeeRate(satoshiPerByte) {\n    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw\n    this.opts.maximumFeeRate = satoshiPerByte;\n  }\n  setVersion(version) {\n    check32Bit(version);\n    checkInputsForPartialSig(this.data.inputs, 'setVersion');\n    const c = this.__CACHE;\n    c.__TX.version = version;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setLocktime(locktime) {\n    check32Bit(locktime);\n    checkInputsForPartialSig(this.data.inputs, 'setLocktime');\n    const c = this.__CACHE;\n    c.__TX.locktime = locktime;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setInputSequence(inputIndex, sequence) {\n    check32Bit(sequence);\n    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');\n    const c = this.__CACHE;\n    if (c.__TX.ins.length <= inputIndex) {\n      throw new Error('Input index too high');\n    }\n    c.__TX.ins[inputIndex].sequence = sequence;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addInputs(inputDatas) {\n    inputDatas.forEach(inputData => this.addInput(inputData));\n    return this;\n  }\n  addInput(inputData) {\n    if (\n      arguments.length > 1 ||\n      !inputData ||\n      inputData.hash === undefined ||\n      inputData.index === undefined\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addInput. ` +\n          `Requires single object with at least [hash] and [index]`,\n      );\n    }\n    (0, bip371_1.checkTaprootInputFields)(inputData, inputData, 'addInput');\n    checkInputsForPartialSig(this.data.inputs, 'addInput');\n    if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);\n    const c = this.__CACHE;\n    this.data.addInput(inputData);\n    const txIn = c.__TX.ins[c.__TX.ins.length - 1];\n    checkTxInputCache(c, txIn);\n    const inputIndex = this.data.inputs.length - 1;\n    const input = this.data.inputs[inputIndex];\n    if (input.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, input, inputIndex);\n    }\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addOutputs(outputDatas) {\n    outputDatas.forEach(outputData => this.addOutput(outputData));\n    return this;\n  }\n  addOutput(outputData) {\n    if (\n      arguments.length > 1 ||\n      !outputData ||\n      outputData.value === undefined ||\n      (outputData.address === undefined && outputData.script === undefined)\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addOutput. ` +\n          `Requires single object with at least [script or address] and [value]`,\n      );\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addOutput');\n    const { address } = outputData;\n    if (typeof address === 'string') {\n      const { network } = this.opts;\n      const script = (0, address_1.toOutputScript)(address, network);\n      outputData = Object.assign(outputData, { script });\n    }\n    (0, bip371_1.checkTaprootOutputFields)(outputData, outputData, 'addOutput');\n    const c = this.__CACHE;\n    this.data.addOutput(outputData);\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  extractTransaction(disableFeeCheck) {\n    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');\n    const c = this.__CACHE;\n    if (!disableFeeCheck) {\n      checkFees(this, c, this.opts);\n    }\n    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;\n    const tx = c.__TX.clone();\n    inputFinalizeGetAmts(this.data.inputs, tx, c, true);\n    return tx;\n  }\n  getFeeRate() {\n    return getTxCacheValue(\n      '__FEE_RATE',\n      'fee rate',\n      this.data.inputs,\n      this.__CACHE,\n    );\n  }\n  getFee() {\n    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);\n  }\n  finalizeAllInputs() {\n    (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one\n    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));\n    return this;\n  }\n  finalizeInput(inputIndex, finalScriptsFunc) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this._finalizeTaprootInput(\n        inputIndex,\n        input,\n        undefined,\n        finalScriptsFunc,\n      );\n    return this._finalizeInput(inputIndex, input, finalScriptsFunc);\n  }\n  finalizeTaprootInput(\n    inputIndex,\n    tapLeafHashToFinalize,\n    finalScriptsFunc = bip371_1.tapScriptFinalizer,\n  ) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this._finalizeTaprootInput(\n        inputIndex,\n        input,\n        tapLeafHashToFinalize,\n        finalScriptsFunc,\n      );\n    throw new Error(`Cannot finalize input #${inputIndex}. Not Taproot.`);\n  }\n  _finalizeInput(inputIndex, input, finalScriptsFunc = getFinalScripts) {\n    const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(\n      inputIndex,\n      input,\n      this.__CACHE,\n    );\n    if (!script) throw new Error(`No script found for input #${inputIndex}`);\n    checkPartialSigSighashes(input);\n    const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(\n      inputIndex,\n      input,\n      script,\n      isSegwit,\n      isP2SH,\n      isP2WSH,\n    );\n    if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });\n    if (finalScriptWitness)\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    if (!finalScriptSig && !finalScriptWitness)\n      throw new Error(`Unknown error finalizing input #${inputIndex}`);\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  _finalizeTaprootInput(\n    inputIndex,\n    input,\n    tapLeafHashToFinalize,\n    finalScriptsFunc = bip371_1.tapScriptFinalizer,\n  ) {\n    if (!input.witnessUtxo)\n      throw new Error(\n        `Cannot finalize input #${inputIndex}. Missing withness utxo.`,\n      );\n    // Check key spend first. Increased privacy and reduced block space.\n    if (input.tapKeySig) {\n      const payment = payments.p2tr({\n        output: input.witnessUtxo.script,\n        signature: input.tapKeySig,\n      });\n      const finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(\n        payment.witness,\n      );\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    } else {\n      const { finalScriptWitness } = finalScriptsFunc(\n        inputIndex,\n        input,\n        tapLeafHashToFinalize,\n      );\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    }\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  getInputType(inputIndex) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);\n    const result = getMeaningfulScript(\n      script,\n      inputIndex,\n      'input',\n      input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),\n      input.witnessScript ||\n        redeemFromFinalWitnessScript(input.finalScriptWitness),\n    );\n    const type = result.type === 'raw' ? '' : result.type + '-';\n    const mainType = classifyScript(result.meaningfulScript);\n    return type + mainType;\n  }\n  inputHasPubkey(inputIndex, pubkey) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);\n  }\n  inputHasHDKey(inputIndex, root) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  outputHasPubkey(outputIndex, pubkey) {\n    const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);\n    return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);\n  }\n  outputHasHDKey(outputIndex, root) {\n    const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  validateSignaturesOfAllInputs(validator) {\n    (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one\n    const results = range(this.data.inputs.length).map(idx =>\n      this.validateSignaturesOfInput(idx, validator),\n    );\n    return results.reduce((final, res) => res === true && final, true);\n  }\n  validateSignaturesOfInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this.validateSignaturesOfTaprootInput(\n        inputIndex,\n        validator,\n        pubkey,\n      );\n    return this._validateSignaturesOfInput(inputIndex, validator, pubkey);\n  }\n  _validateSignaturesOfInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const partialSig = (input || {}).partialSig;\n    if (!input || !partialSig || partialSig.length < 1)\n      throw new Error('No signatures to validate');\n    if (typeof validator !== 'function')\n      throw new Error('Need validator function to validate signatures');\n    const mySigs = pubkey\n      ? partialSig.filter(sig => sig.pubkey.equals(pubkey))\n      : partialSig;\n    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');\n    const results = [];\n    let hashCache;\n    let scriptCache;\n    let sighashCache;\n    for (const pSig of mySigs) {\n      const sig = bscript.signature.decode(pSig.signature);\n      const { hash, script } =\n        sighashCache !== sig.hashType\n          ? getHashForSig(\n              inputIndex,\n              Object.assign({}, input, { sighashType: sig.hashType }),\n              this.__CACHE,\n              true,\n            )\n          : { hash: hashCache, script: scriptCache };\n      sighashCache = sig.hashType;\n      hashCache = hash;\n      scriptCache = script;\n      checkScriptForPubkey(pSig.pubkey, script, 'verify');\n      results.push(validator(pSig.pubkey, hash, sig.signature));\n    }\n    return results.every(res => res === true);\n  }\n  validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const tapKeySig = (input || {}).tapKeySig;\n    const tapScriptSig = (input || {}).tapScriptSig;\n    if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length))\n      throw new Error('No signatures to validate');\n    if (typeof validator !== 'function')\n      throw new Error('Need validator function to validate signatures');\n    pubkey = pubkey && (0, bip371_1.toXOnly)(pubkey);\n    const allHashses = pubkey\n      ? getTaprootHashesForSig(\n          inputIndex,\n          input,\n          this.data.inputs,\n          pubkey,\n          this.__CACHE,\n        )\n      : getAllTaprootHashesForSig(\n          inputIndex,\n          input,\n          this.data.inputs,\n          this.__CACHE,\n        );\n    if (!allHashses.length) throw new Error('No signatures for this pubkey');\n    const tapKeyHash = allHashses.find(h => !h.leafHash);\n    let validationResultCount = 0;\n    if (tapKeySig && tapKeyHash) {\n      const isValidTapkeySig = validator(\n        tapKeyHash.pubkey,\n        tapKeyHash.hash,\n        trimTaprootSig(tapKeySig),\n      );\n      if (!isValidTapkeySig) return false;\n      validationResultCount++;\n    }\n    if (tapScriptSig) {\n      for (const tapSig of tapScriptSig) {\n        const tapSigHash = allHashses.find(h => tapSig.pubkey.equals(h.pubkey));\n        if (tapSigHash) {\n          const isValidTapScriptSig = validator(\n            tapSig.pubkey,\n            tapSigHash.hash,\n            trimTaprootSig(tapSig.signature),\n          );\n          if (!isValidTapScriptSig) return false;\n          validationResultCount++;\n        }\n      }\n    }\n    return validationResultCount > 0;\n  }\n  signAllInputsHD(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInputHD(i, hdKeyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsHDAsync(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const results = [];\n      const promises = [];\n      for (const i of range(this.data.inputs.length)) {\n        promises.push(\n          this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInputHD(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));\n    return this;\n  }\n  signInputHDAsync(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n      const promises = signers.map(signer =>\n        this.signInputAsync(inputIndex, signer, sighashTypes),\n      );\n      return Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n  signAllInputs(keyPair, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    // TODO: Add a pubkey/pubkeyhash cache to each input\n    // as input information is added, then eventually\n    // optimize this method.\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInput(i, keyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsAsync(keyPair, sighashTypes) {\n    return new Promise((resolve, reject) => {\n      if (!keyPair || !keyPair.publicKey)\n        return reject(new Error('Need Signer to sign input'));\n      // TODO: Add a pubkey/pubkeyhash cache to each input\n      // as input information is added, then eventually\n      // optimize this method.\n      const results = [];\n      const promises = [];\n      for (const [i] of this.data.inputs.entries()) {\n        promises.push(\n          this.signInputAsync(i, keyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInput(inputIndex, keyPair, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input)) {\n      return this._signTaprootInput(\n        inputIndex,\n        input,\n        keyPair,\n        undefined,\n        sighashTypes,\n      );\n    }\n    return this._signInput(inputIndex, keyPair, sighashTypes);\n  }\n  signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this._signTaprootInput(\n        inputIndex,\n        input,\n        keyPair,\n        tapLeafHashToSign,\n        sighashTypes,\n      );\n    throw new Error(`Input #${inputIndex} is not of type Taproot.`);\n  }\n  _signInput(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n    );\n    const partialSig = [\n      {\n        pubkey: keyPair.publicKey,\n        signature: bscript.signature.encode(keyPair.sign(hash), sighashType),\n      },\n    ];\n    this.data.updateInput(inputIndex, { partialSig });\n    return this;\n  }\n  _signTaprootInput(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHashToSign,\n    allowedSighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT],\n  ) {\n    const hashesForSig = this.checkTaprootHashesForSig(\n      inputIndex,\n      input,\n      keyPair,\n      tapLeafHashToSign,\n      allowedSighashTypes,\n    );\n    const tapKeySig = hashesForSig\n      .filter(h => !h.leafHash)\n      .map(h =>\n        (0, bip371_1.serializeTaprootSignature)(\n          keyPair.signSchnorr(h.hash),\n          input.sighashType,\n        ),\n      )[0];\n    const tapScriptSig = hashesForSig\n      .filter(h => !!h.leafHash)\n      .map(h => ({\n        pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),\n        signature: (0, bip371_1.serializeTaprootSignature)(\n          keyPair.signSchnorr(h.hash),\n          input.sighashType,\n        ),\n        leafHash: h.leafHash,\n      }));\n    if (tapKeySig) {\n      this.data.updateInput(inputIndex, { tapKeySig });\n    }\n    if (tapScriptSig.length) {\n      this.data.updateInput(inputIndex, { tapScriptSig });\n    }\n    return this;\n  }\n  signInputAsync(inputIndex, keyPair, sighashTypes) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n      if ((0, bip371_1.isTaprootInput)(input))\n        return this._signTaprootInputAsync(\n          inputIndex,\n          input,\n          keyPair,\n          undefined,\n          sighashTypes,\n        );\n      return this._signInputAsync(inputIndex, keyPair, sighashTypes);\n    });\n  }\n  signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n      if ((0, bip371_1.isTaprootInput)(input))\n        return this._signTaprootInputAsync(\n          inputIndex,\n          input,\n          keyPair,\n          tapLeafHash,\n          sighashTypes,\n        );\n      throw new Error(`Input #${inputIndex} is not of type Taproot.`);\n    });\n  }\n  _signInputAsync(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n    );\n    return Promise.resolve(keyPair.sign(hash)).then(signature => {\n      const partialSig = [\n        {\n          pubkey: keyPair.publicKey,\n          signature: bscript.signature.encode(signature, sighashType),\n        },\n      ];\n      this.data.updateInput(inputIndex, { partialSig });\n    });\n  }\n  async _signTaprootInputAsync(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHash,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT],\n  ) {\n    const hashesForSig = this.checkTaprootHashesForSig(\n      inputIndex,\n      input,\n      keyPair,\n      tapLeafHash,\n      sighashTypes,\n    );\n    const signaturePromises = [];\n    const tapKeyHash = hashesForSig.filter(h => !h.leafHash)[0];\n    if (tapKeyHash) {\n      const tapKeySigPromise = Promise.resolve(\n        keyPair.signSchnorr(tapKeyHash.hash),\n      ).then(sig => {\n        return {\n          tapKeySig: (0, bip371_1.serializeTaprootSignature)(\n            sig,\n            input.sighashType,\n          ),\n        };\n      });\n      signaturePromises.push(tapKeySigPromise);\n    }\n    const tapScriptHashes = hashesForSig.filter(h => !!h.leafHash);\n    if (tapScriptHashes.length) {\n      const tapScriptSigPromises = tapScriptHashes.map(tsh => {\n        return Promise.resolve(keyPair.signSchnorr(tsh.hash)).then(\n          signature => {\n            const tapScriptSig = [\n              {\n                pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),\n                signature: (0, bip371_1.serializeTaprootSignature)(\n                  signature,\n                  input.sighashType,\n                ),\n                leafHash: tsh.leafHash,\n              },\n            ];\n            return { tapScriptSig };\n          },\n        );\n      });\n      signaturePromises.push(...tapScriptSigPromises);\n    }\n    return Promise.all(signaturePromises).then(results => {\n      results.forEach(v => this.data.updateInput(inputIndex, v));\n    });\n  }\n  checkTaprootHashesForSig(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHashToSign,\n    allowedSighashTypes,\n  ) {\n    if (typeof keyPair.signSchnorr !== 'function')\n      throw new Error(\n        `Need Schnorr Signer to sign taproot input #${inputIndex}.`,\n      );\n    const hashesForSig = getTaprootHashesForSig(\n      inputIndex,\n      input,\n      this.data.inputs,\n      keyPair.publicKey,\n      this.__CACHE,\n      tapLeafHashToSign,\n      allowedSighashTypes,\n    );\n    if (!hashesForSig || !hashesForSig.length)\n      throw new Error(\n        `Can not sign for input #${inputIndex} with the key ${keyPair.publicKey.toString(\n          'hex',\n        )}`,\n      );\n    return hashesForSig;\n  }\n  toBuffer() {\n    checkCache(this.__CACHE);\n    return this.data.toBuffer();\n  }\n  toHex() {\n    checkCache(this.__CACHE);\n    return this.data.toHex();\n  }\n  toBase64() {\n    checkCache(this.__CACHE);\n    return this.data.toBase64();\n  }\n  updateGlobal(updateData) {\n    this.data.updateGlobal(updateData);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);\n    (0, bip371_1.checkTaprootInputFields)(\n      this.data.inputs[inputIndex],\n      updateData,\n      'updateInput',\n    );\n    this.data.updateInput(inputIndex, updateData);\n    if (updateData.nonWitnessUtxo) {\n      addNonWitnessTxCache(\n        this.__CACHE,\n        this.data.inputs[inputIndex],\n        inputIndex,\n      );\n    }\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    const outputData = this.data.outputs[outputIndex];\n    (0, bip371_1.checkTaprootOutputFields)(\n      outputData,\n      updateData,\n      'updateOutput',\n    );\n    this.data.updateOutput(outputIndex, updateData);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    this.data.addUnknownKeyValToGlobal(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    this.data.addUnknownKeyValToInput(inputIndex, keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n}\nexports.Psbt = Psbt;\n/**\n * This function is needed to pass to the bip174 base class's fromBuffer.\n * It takes the \"transaction buffer\" portion of the psbt buffer and returns a\n * Transaction (From the bip174 library) interface.\n */\nconst transactionFromBuffer = buffer => new PsbtTransaction(buffer);\n/**\n * This class implements the Transaction interface from bip174 library.\n * It contains a bitcoinjs-lib Transaction object.\n */\nclass PsbtTransaction {\n  constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {\n    this.tx = transaction_1.Transaction.fromBuffer(buffer);\n    checkTxEmpty(this.tx);\n    Object.defineProperty(this, 'tx', {\n      enumerable: false,\n      writable: true,\n    });\n  }\n  getInputOutputCounts() {\n    return {\n      inputCount: this.tx.ins.length,\n      outputCount: this.tx.outs.length,\n    };\n  }\n  addInput(input) {\n    if (\n      input.hash === undefined ||\n      input.index === undefined ||\n      (!Buffer.isBuffer(input.hash) && typeof input.hash !== 'string') ||\n      typeof input.index !== 'number'\n    ) {\n      throw new Error('Error adding input.');\n    }\n    const hash =\n      typeof input.hash === 'string'\n        ? (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash, 'hex'))\n        : input.hash;\n    this.tx.addInput(hash, input.index, input.sequence);\n  }\n  addOutput(output) {\n    if (\n      output.script === undefined ||\n      output.value === undefined ||\n      !Buffer.isBuffer(output.script) ||\n      typeof output.value !== 'number'\n    ) {\n      throw new Error('Error adding output.');\n    }\n    this.tx.addOutput(output.script, output.value);\n  }\n  toBuffer() {\n    return this.tx.toBuffer();\n  }\n}\nfunction canFinalize(input, script, scriptType) {\n  switch (scriptType) {\n    case 'pubkey':\n    case 'pubkeyhash':\n    case 'witnesspubkeyhash':\n      return hasSigs(1, input.partialSig);\n    case 'multisig':\n      const p2ms = payments.p2ms({ output: script });\n      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);\n    default:\n      return false;\n  }\n}\nfunction checkCache(cache) {\n  if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {\n    throw new Error('Not BIP174 compliant, can not export');\n  }\n}\nfunction hasSigs(neededSigs, partialSig, pubkeys) {\n  if (!partialSig) return false;\n  let sigs;\n  if (pubkeys) {\n    sigs = pubkeys\n      .map(pkey => {\n        const pubkey = compressPubkey(pkey);\n        return partialSig.find(pSig => pSig.pubkey.equals(pubkey));\n      })\n      .filter(v => !!v);\n  } else {\n    sigs = partialSig;\n  }\n  if (sigs.length > neededSigs) throw new Error('Too many signatures');\n  return sigs.length === neededSigs;\n}\nfunction isFinalized(input) {\n  return !!input.finalScriptSig || !!input.finalScriptWitness;\n}\nfunction bip32DerivationIsMine(root) {\n  return d => {\n    if (!d.masterFingerprint.equals(root.fingerprint)) return false;\n    if (!root.derivePath(d.path).publicKey.equals(d.pubkey)) return false;\n    return true;\n  };\n}\nfunction check32Bit(num) {\n  if (\n    typeof num !== 'number' ||\n    num !== Math.floor(num) ||\n    num > 0xffffffff ||\n    num < 0\n  ) {\n    throw new Error('Invalid 32 bit integer');\n  }\n}\nfunction checkFees(psbt, cache, opts) {\n  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();\n  const vsize = cache.__EXTRACTED_TX.virtualSize();\n  const satoshis = feeRate * vsize;\n  if (feeRate >= opts.maximumFeeRate) {\n    throw new Error(\n      `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +\n        `fees, which is ${feeRate} satoshi per byte for a transaction ` +\n        `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +\n        `byte). Use setMaximumFeeRate method to raise your threshold, or ` +\n        `pass true to the first arg of extractTransaction.`,\n    );\n  }\n}\nfunction checkInputsForPartialSig(inputs, action) {\n  inputs.forEach(input => {\n    const throws = (0, bip371_1.isTaprootInput)(input)\n      ? (0, bip371_1.checkTaprootInputForSigs)(input, action)\n      : (0, psbtutils_1.checkInputForSig)(input, action);\n    if (throws)\n      throw new Error('Can not modify transaction, signatures exist.');\n  });\n}\nfunction checkPartialSigSighashes(input) {\n  if (!input.sighashType || !input.partialSig) return;\n  const { partialSig, sighashType } = input;\n  partialSig.forEach(pSig => {\n    const { hashType } = bscript.signature.decode(pSig.signature);\n    if (sighashType !== hashType) {\n      throw new Error('Signature sighash does not match input sighash type');\n    }\n  });\n}\nfunction checkScriptForPubkey(pubkey, script, action) {\n  if (!(0, psbtutils_1.pubkeyInScript)(pubkey, script)) {\n    throw new Error(\n      `Can not ${action} for this input with the key ${pubkey.toString('hex')}`,\n    );\n  }\n}\nfunction checkTxEmpty(tx) {\n  const isEmpty = tx.ins.every(\n    input =>\n      input.script &&\n      input.script.length === 0 &&\n      input.witness &&\n      input.witness.length === 0,\n  );\n  if (!isEmpty) {\n    throw new Error('Format Error: Transaction ScriptSigs are not empty');\n  }\n}\nfunction checkTxForDupeIns(tx, cache) {\n  tx.ins.forEach(input => {\n    checkTxInputCache(cache, input);\n  });\n}\nfunction checkTxInputCache(cache, input) {\n  const key =\n    (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash)).toString('hex') +\n    ':' +\n    input.index;\n  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');\n  cache.__TX_IN_CACHE[key] = 1;\n}\nfunction scriptCheckerFactory(payment, paymentScriptName) {\n  return (inputIndex, scriptPubKey, redeemScript, ioType) => {\n    const redeemScriptOutput = payment({\n      redeem: { output: redeemScript },\n    }).output;\n    if (!scriptPubKey.equals(redeemScriptOutput)) {\n      throw new Error(\n        `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`,\n      );\n    }\n  };\n}\nconst checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');\nconst checkWitnessScript = scriptCheckerFactory(\n  payments.p2wsh,\n  'Witness script',\n);\nfunction getTxCacheValue(key, name, inputs, c) {\n  if (!inputs.every(isFinalized))\n    throw new Error(`PSBT must be finalized to calculate ${name}`);\n  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;\n  if (key === '__FEE' && c.__FEE) return c.__FEE;\n  let tx;\n  let mustFinalize = true;\n  if (c.__EXTRACTED_TX) {\n    tx = c.__EXTRACTED_TX;\n    mustFinalize = false;\n  } else {\n    tx = c.__TX.clone();\n  }\n  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);\n  if (key === '__FEE_RATE') return c.__FEE_RATE;\n  else if (key === '__FEE') return c.__FEE;\n}\nfunction getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {\n  const scriptType = classifyScript(script);\n  if (!canFinalize(input, script, scriptType))\n    throw new Error(`Can not finalize input #${inputIndex}`);\n  return prepareFinalScripts(\n    script,\n    scriptType,\n    input.partialSig,\n    isSegwit,\n    isP2SH,\n    isP2WSH,\n  );\n}\nfunction prepareFinalScripts(\n  script,\n  scriptType,\n  partialSig,\n  isSegwit,\n  isP2SH,\n  isP2WSH,\n) {\n  let finalScriptSig;\n  let finalScriptWitness;\n  // Wow, the payments API is very handy\n  const payment = getPayment(script, scriptType, partialSig);\n  const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });\n  const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });\n  if (isSegwit) {\n    if (p2wsh) {\n      finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(\n        p2wsh.witness,\n      );\n    } else {\n      finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(\n        payment.witness,\n      );\n    }\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    }\n  } else {\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    } else {\n      finalScriptSig = payment.input;\n    }\n  }\n  return {\n    finalScriptSig,\n    finalScriptWitness,\n  };\n}\nfunction getHashAndSighashType(\n  inputs,\n  inputIndex,\n  pubkey,\n  cache,\n  sighashTypes,\n) {\n  const input = (0, utils_1.checkForInput)(inputs, inputIndex);\n  const { hash, sighashType, script } = getHashForSig(\n    inputIndex,\n    input,\n    cache,\n    false,\n    sighashTypes,\n  );\n  checkScriptForPubkey(pubkey, script, 'sign');\n  return {\n    hash,\n    sighashType,\n  };\n}\nfunction getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {\n  const unsignedTx = cache.__TX;\n  const sighashType =\n    input.sighashType || transaction_1.Transaction.SIGHASH_ALL;\n  checkSighashTypeAllowed(sighashType, sighashTypes);\n  let hash;\n  let prevout;\n  if (input.nonWitnessUtxo) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const prevoutHash = unsignedTx.ins[inputIndex].hash;\n    const utxoHash = nonWitnessUtxoTx.getHash();\n    // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout\n    if (!prevoutHash.equals(utxoHash)) {\n      throw new Error(\n        `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`,\n      );\n    }\n    const prevoutIndex = unsignedTx.ins[inputIndex].index;\n    prevout = nonWitnessUtxoTx.outs[prevoutIndex];\n  } else if (input.witnessUtxo) {\n    prevout = input.witnessUtxo;\n  } else {\n    throw new Error('Need a Utxo input item for signing');\n  }\n  const { meaningfulScript, type } = getMeaningfulScript(\n    prevout.script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  if (['p2sh-p2wsh', 'p2wsh'].indexOf(type) >= 0) {\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      meaningfulScript,\n      prevout.value,\n      sighashType,\n    );\n  } else if ((0, psbtutils_1.isP2WPKH)(meaningfulScript)) {\n    // P2WPKH uses the P2PKH template for prevoutScript when signing\n    const signingScript = payments.p2pkh({\n      hash: meaningfulScript.slice(2),\n    }).output;\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      signingScript,\n      prevout.value,\n      sighashType,\n    );\n  } else {\n    // non-segwit\n    if (\n      input.nonWitnessUtxo === undefined &&\n      cache.__UNSAFE_SIGN_NONSEGWIT === false\n    )\n      throw new Error(\n        `Input #${inputIndex} has witnessUtxo but non-segwit script: ` +\n          `${meaningfulScript.toString('hex')}`,\n      );\n    if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)\n      console.warn(\n        'Warning: Signing non-segwit inputs without the full parent transaction ' +\n          'means there is a chance that a miner could feed you incorrect information ' +\n          \"to trick you into paying large fees. This behavior is the same as Psbt's predecesor \" +\n          '(TransactionBuilder - now removed) when signing non-segwit scripts. You are not ' +\n          'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' +\n          'BIP174 compliant.\\n*********************\\nPROCEED WITH CAUTION!\\n' +\n          '*********************',\n      );\n    hash = unsignedTx.hashForSignature(\n      inputIndex,\n      meaningfulScript,\n      sighashType,\n    );\n  }\n  return {\n    script: meaningfulScript,\n    sighashType,\n    hash,\n  };\n}\nfunction getAllTaprootHashesForSig(inputIndex, input, inputs, cache) {\n  const allPublicKeys = [];\n  if (input.tapInternalKey) {\n    const key = getPrevoutTaprootKey(inputIndex, input, cache);\n    if (key) {\n      allPublicKeys.push(key);\n    }\n  }\n  if (input.tapScriptSig) {\n    const tapScriptPubkeys = input.tapScriptSig.map(tss => tss.pubkey);\n    allPublicKeys.push(...tapScriptPubkeys);\n  }\n  const allHashes = allPublicKeys.map(pubicKey =>\n    getTaprootHashesForSig(inputIndex, input, inputs, pubicKey, cache),\n  );\n  return allHashes.flat();\n}\nfunction getPrevoutTaprootKey(inputIndex, input, cache) {\n  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);\n  return (0, psbtutils_1.isP2TR)(script) ? script.subarray(2, 34) : null;\n}\nfunction trimTaprootSig(signature) {\n  return signature.length === 64 ? signature : signature.subarray(0, 64);\n}\nfunction getTaprootHashesForSig(\n  inputIndex,\n  input,\n  inputs,\n  pubkey,\n  cache,\n  tapLeafHashToSign,\n  allowedSighashTypes,\n) {\n  const unsignedTx = cache.__TX;\n  const sighashType =\n    input.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;\n  checkSighashTypeAllowed(sighashType, allowedSighashTypes);\n  const prevOuts = inputs.map((i, index) =>\n    getScriptAndAmountFromUtxo(index, i, cache),\n  );\n  const signingScripts = prevOuts.map(o => o.script);\n  const values = prevOuts.map(o => o.value);\n  const hashes = [];\n  if (input.tapInternalKey && !tapLeafHashToSign) {\n    const outputKey =\n      getPrevoutTaprootKey(inputIndex, input, cache) || Buffer.from([]);\n    if ((0, bip371_1.toXOnly)(pubkey).equals(outputKey)) {\n      const tapKeyHash = unsignedTx.hashForWitnessV1(\n        inputIndex,\n        signingScripts,\n        values,\n        sighashType,\n      );\n      hashes.push({ pubkey, hash: tapKeyHash });\n    }\n  }\n  const tapLeafHashes = (input.tapLeafScript || [])\n    .filter(tapLeaf => (0, psbtutils_1.pubkeyInScript)(pubkey, tapLeaf.script))\n    .map(tapLeaf => {\n      const hash = (0, bip341_1.tapleafHash)({\n        output: tapLeaf.script,\n        version: tapLeaf.leafVersion,\n      });\n      return Object.assign({ hash }, tapLeaf);\n    })\n    .filter(\n      tapLeaf => !tapLeafHashToSign || tapLeafHashToSign.equals(tapLeaf.hash),\n    )\n    .map(tapLeaf => {\n      const tapScriptHash = unsignedTx.hashForWitnessV1(\n        inputIndex,\n        signingScripts,\n        values,\n        transaction_1.Transaction.SIGHASH_DEFAULT,\n        tapLeaf.hash,\n      );\n      return {\n        pubkey,\n        hash: tapScriptHash,\n        leafHash: tapLeaf.hash,\n      };\n    });\n  return hashes.concat(tapLeafHashes);\n}\nfunction checkSighashTypeAllowed(sighashType, sighashTypes) {\n  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {\n    const str = sighashTypeToString(sighashType);\n    throw new Error(\n      `Sighash type is not allowed. Retry the sign method passing the ` +\n        `sighashTypes array of whitelisted types. Sighash type: ${str}`,\n    );\n  }\n}\nfunction getPayment(script, scriptType, partialSig) {\n  let payment;\n  switch (scriptType) {\n    case 'multisig':\n      const sigs = getSortedSigs(script, partialSig);\n      payment = payments.p2ms({\n        output: script,\n        signatures: sigs,\n      });\n      break;\n    case 'pubkey':\n      payment = payments.p2pk({\n        output: script,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'pubkeyhash':\n      payment = payments.p2pkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'witnesspubkeyhash':\n      payment = payments.p2wpkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n  }\n  return payment;\n}\nfunction getScriptFromInput(inputIndex, input, cache) {\n  const unsignedTx = cache.__TX;\n  const res = {\n    script: null,\n    isSegwit: false,\n    isP2SH: false,\n    isP2WSH: false,\n  };\n  res.isP2SH = !!input.redeemScript;\n  res.isP2WSH = !!input.witnessScript;\n  if (input.witnessScript) {\n    res.script = input.witnessScript;\n  } else if (input.redeemScript) {\n    res.script = input.redeemScript;\n  } else {\n    if (input.nonWitnessUtxo) {\n      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n        cache,\n        input,\n        inputIndex,\n      );\n      const prevoutIndex = unsignedTx.ins[inputIndex].index;\n      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;\n    } else if (input.witnessUtxo) {\n      res.script = input.witnessUtxo.script;\n    }\n  }\n  if (input.witnessScript || (0, psbtutils_1.isP2WPKH)(res.script)) {\n    res.isSegwit = true;\n  }\n  return res;\n}\nfunction getSignersFromHD(inputIndex, inputs, hdKeyPair) {\n  const input = (0, utils_1.checkForInput)(inputs, inputIndex);\n  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {\n    throw new Error('Need bip32Derivation to sign with HD');\n  }\n  const myDerivations = input.bip32Derivation\n    .map(bipDv => {\n      if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {\n        return bipDv;\n      } else {\n        return;\n      }\n    })\n    .filter(v => !!v);\n  if (myDerivations.length === 0) {\n    throw new Error(\n      'Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint',\n    );\n  }\n  const signers = myDerivations.map(bipDv => {\n    const node = hdKeyPair.derivePath(bipDv.path);\n    if (!bipDv.pubkey.equals(node.publicKey)) {\n      throw new Error('pubkey did not match bip32Derivation');\n    }\n    return node;\n  });\n  return signers;\n}\nfunction getSortedSigs(script, partialSig) {\n  const p2ms = payments.p2ms({ output: script });\n  // for each pubkey in order of p2ms script\n  return p2ms.pubkeys\n    .map(pk => {\n      // filter partialSig array by pubkey being equal\n      return (\n        partialSig.filter(ps => {\n          return ps.pubkey.equals(pk);\n        })[0] || {}\n      ).signature;\n      // Any pubkey without a match will return undefined\n      // this last filter removes all the undefined items in the array.\n    })\n    .filter(v => !!v);\n}\nfunction scriptWitnessToWitnessStack(buffer) {\n  let offset = 0;\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n  function readVarInt() {\n    const vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n  function readVector() {\n    const count = readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(readVarSlice());\n    return vector;\n  }\n  return readVector();\n}\nfunction sighashTypeToString(sighashType) {\n  let text =\n    sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY\n      ? 'SIGHASH_ANYONECANPAY | '\n      : '';\n  const sigMod = sighashType & 0x1f;\n  switch (sigMod) {\n    case transaction_1.Transaction.SIGHASH_ALL:\n      text += 'SIGHASH_ALL';\n      break;\n    case transaction_1.Transaction.SIGHASH_SINGLE:\n      text += 'SIGHASH_SINGLE';\n      break;\n    case transaction_1.Transaction.SIGHASH_NONE:\n      text += 'SIGHASH_NONE';\n      break;\n  }\n  return text;\n}\nfunction addNonWitnessTxCache(cache, input, inputIndex) {\n  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;\n  const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);\n  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;\n  const self = cache;\n  const selfIndex = inputIndex;\n  delete input.nonWitnessUtxo;\n  Object.defineProperty(input, 'nonWitnessUtxo', {\n    enumerable: true,\n    get() {\n      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];\n      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];\n      if (buf !== undefined) {\n        return buf;\n      } else {\n        const newBuf = txCache.toBuffer();\n        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;\n        return newBuf;\n      }\n    },\n    set(data) {\n      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;\n    },\n  });\n}\nfunction inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {\n  let inputAmount = 0;\n  inputs.forEach((input, idx) => {\n    if (mustFinalize && input.finalScriptSig)\n      tx.ins[idx].script = input.finalScriptSig;\n    if (mustFinalize && input.finalScriptWitness) {\n      tx.ins[idx].witness = scriptWitnessToWitnessStack(\n        input.finalScriptWitness,\n      );\n    }\n    if (input.witnessUtxo) {\n      inputAmount += input.witnessUtxo.value;\n    } else if (input.nonWitnessUtxo) {\n      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);\n      const vout = tx.ins[idx].index;\n      const out = nwTx.outs[vout];\n      inputAmount += out.value;\n    }\n  });\n  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);\n  const fee = inputAmount - outputAmount;\n  if (fee < 0) {\n    throw new Error('Outputs are spending more than Inputs');\n  }\n  const bytes = tx.virtualSize();\n  cache.__FEE = fee;\n  cache.__EXTRACTED_TX = tx;\n  cache.__FEE_RATE = Math.floor(fee / bytes);\n}\nfunction nonWitnessUtxoTxFromCache(cache, input, inputIndex) {\n  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;\n  if (!c[inputIndex]) {\n    addNonWitnessTxCache(cache, input, inputIndex);\n  }\n  return c[inputIndex];\n}\nfunction getScriptFromUtxo(inputIndex, input, cache) {\n  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);\n  return script;\n}\nfunction getScriptAndAmountFromUtxo(inputIndex, input, cache) {\n  if (input.witnessUtxo !== undefined) {\n    return {\n      script: input.witnessUtxo.script,\n      value: input.witnessUtxo.value,\n    };\n  } else if (input.nonWitnessUtxo !== undefined) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const o = nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index];\n    return { script: o.script, value: o.value };\n  } else {\n    throw new Error(\"Can't find pubkey in input without Utxo data\");\n  }\n}\nfunction pubkeyInInput(pubkey, input, inputIndex, cache) {\n  const script = getScriptFromUtxo(inputIndex, input, cache);\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);\n}\nfunction pubkeyInOutput(pubkey, output, outputIndex, cache) {\n  const script = cache.__TX.outs[outputIndex].script;\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    outputIndex,\n    'output',\n    output.redeemScript,\n    output.witnessScript,\n  );\n  return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);\n}\nfunction redeemFromFinalScriptSig(finalScript) {\n  if (!finalScript) return;\n  const decomp = bscript.decompile(finalScript);\n  if (!decomp) return;\n  const lastItem = decomp[decomp.length - 1];\n  if (\n    !Buffer.isBuffer(lastItem) ||\n    isPubkeyLike(lastItem) ||\n    isSigLike(lastItem)\n  )\n    return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction redeemFromFinalWitnessScript(finalScript) {\n  if (!finalScript) return;\n  const decomp = scriptWitnessToWitnessStack(finalScript);\n  const lastItem = decomp[decomp.length - 1];\n  if (isPubkeyLike(lastItem)) return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction compressPubkey(pubkey) {\n  if (pubkey.length === 65) {\n    const parity = pubkey[64] & 1;\n    const newKey = pubkey.slice(0, 33);\n    newKey[0] = 2 | parity;\n    return newKey;\n  }\n  return pubkey.slice();\n}\nfunction isPubkeyLike(buf) {\n  return buf.length === 33 && bscript.isCanonicalPubKey(buf);\n}\nfunction isSigLike(buf) {\n  return bscript.isCanonicalScriptSignature(buf);\n}\nfunction getMeaningfulScript(\n  script,\n  index,\n  ioType,\n  redeemScript,\n  witnessScript,\n) {\n  const isP2SH = (0, psbtutils_1.isP2SHScript)(script);\n  const isP2SHP2WSH =\n    isP2SH && redeemScript && (0, psbtutils_1.isP2WSHScript)(redeemScript);\n  const isP2WSH = (0, psbtutils_1.isP2WSHScript)(script);\n  if (isP2SH && redeemScript === undefined)\n    throw new Error('scriptPubkey is P2SH but redeemScript missing');\n  if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined)\n    throw new Error(\n      'scriptPubkey or redeemScript is P2WSH but witnessScript missing',\n    );\n  let meaningfulScript;\n  if (isP2SHP2WSH) {\n    meaningfulScript = witnessScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n    checkWitnessScript(index, redeemScript, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2WSH) {\n    meaningfulScript = witnessScript;\n    checkWitnessScript(index, script, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2SH) {\n    meaningfulScript = redeemScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n  } else {\n    meaningfulScript = script;\n  }\n  return {\n    meaningfulScript,\n    type: isP2SHP2WSH\n      ? 'p2sh-p2wsh'\n      : isP2SH\n      ? 'p2sh'\n      : isP2WSH\n      ? 'p2wsh'\n      : 'raw',\n  };\n}\nfunction checkInvalidP2WSH(script) {\n  if (\n    (0, psbtutils_1.isP2WPKH)(script) ||\n    (0, psbtutils_1.isP2SHScript)(script)\n  ) {\n    throw new Error('P2WPKH or P2SH can not be contained within P2WSH');\n  }\n}\nfunction classifyScript(script) {\n  if ((0, psbtutils_1.isP2WPKH)(script)) return 'witnesspubkeyhash';\n  if ((0, psbtutils_1.isP2PKH)(script)) return 'pubkeyhash';\n  if ((0, psbtutils_1.isP2MS)(script)) return 'multisig';\n  if ((0, psbtutils_1.isP2PK)(script)) return 'pubkey';\n  return 'nonstandard';\n}\nfunction range(n) {\n  return [...Array(n).keys()];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}