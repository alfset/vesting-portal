{"ast":null,"code":"import{useCallback,useEffect,useMemo,useRef}from'react';import{useDispatch,useSelector}from'react-redux';import{useActiveWeb3React}from'../../hooks';import{useMulticallContract,useRpcMulticallContract}from'../../hooks/useContract';import useDebounce from'../../hooks/useDebounce';import chunkArray from'../../utils/chunkArray';import{CancelledError,retry,RetryableError}from'../../utils/retry';import{useBlockNumber}from'../application/hooks';import{// addUseChainId,\nerrorFetchingMulticallResults,fetchingMulticallResults,parseCallKey,updateMulticallResults}from'./actions';// 块调用，这样我们就不会超过气体限制\nconst CALL_CHUNK_SIZE=500;/**\n * 获取一组调用，强制执行最小块数约束\n * @param multicallContract multicall contract to fetch against\n * @param chunk chunk of calls to make\n * @param minBlockNumber minimum block number of the result set\n */export async function fetchChunk(multicallContract,chunk,minBlockNumber){console.debug('Fetching chunk',multicallContract,chunk,minBlockNumber);let resultsBlockNumber,returnData;// console.log('chunk')\n// console.log(chunk)\ntry{;[resultsBlockNumber,returnData]=await multicallContract.aggregate(chunk.map(obj=>[obj.address,obj.callData]));// console.log('multicallContract1')\n}catch(error){console.debug('Failed to fetch chunk inside retry',error);throw error;}if(resultsBlockNumber.toNumber()<minBlockNumber){// console.log(`Fetched results for old block number: ${resultsBlockNumber.toString()} vs. ${minBlockNumber}`)\n// console.debug(`Fetched results for old block number: ${resultsBlockNumber.toString()} vs. ${minBlockNumber}`)\nthrow new RetryableError('Fetched for old block number');}// console.log({ results: returnData, blockNumber: resultsBlockNumber.toNumber() })\nreturn{results:returnData,blockNumber:resultsBlockNumber.toNumber()};}/**\n * 获取一组调用，强制执行最小块数约束\n * @param multicallContract multicall contract to fetch against\n * @param chunk chunk of calls to make\n * @param minBlockNumber minimum block number of the result set\n */async function fetchChunk1(multicallContract,chunk,minBlockNumber){console.debug('Fetching chunk',multicallContract,chunk,minBlockNumber);let resultsBlockNumber,returnData;// console.log(multicallContract)\ntry{// multicallContract.methods.aggregate(chunk.map(obj => [obj.address, obj.callData])).call((err:any, res:any) => {\n//   console.log(err)\n//   console.log(res)\n// })\n// console.log(await multicallContract.methods.aggregate(chunk.map(obj => [obj.address, obj.callData])).call())\nconst callData=await multicallContract.methods.aggregate(chunk.map(obj=>[obj.address,obj.callData])).call();resultsBlockNumber=callData.blockNumber?Number(callData.blockNumber):0;returnData=callData.returnData;// ;[resultsBlockNumber, returnData] = await multicallContract.methods.aggregate(chunk.map(obj => [obj.address, obj.callData])).call()\n}catch(error){console.debug('Failed to fetch chunk inside retry',error);throw error;}if(resultsBlockNumber<minBlockNumber){console.debug(\"Fetched results for old block number: \".concat(resultsBlockNumber.toString(),\" vs. \").concat(minBlockNumber));throw new RetryableError('Fetched for old block number');}// console.log({ results: returnData, blockNumber: resultsBlockNumber })\nreturn{results:returnData,blockNumber:resultsBlockNumber};}/**\n * 从当前的所有侦听器状态，返回映射到每次读取的最小块数。这是每个键必须被获取的频率。\n * @param allListeners the all listeners state\n * @param chainId the current chain id\n */export function activeListeningKeys(allListeners,chainId){if(!allListeners||!chainId)return{};const listeners=allListeners[chainId];if(!listeners)return{};// console.log(listeners)\nreturn Object.keys(listeners).reduce((memo,callKey)=>{const keyListeners=listeners[callKey];memo[callKey]=Object.keys(keyListeners).filter(key=>{const blocksPerFetch=parseInt(key);if(blocksPerFetch<=0)return false;return keyListeners[blocksPerFetch]>0;}).reduce((previousMin,current)=>{return Math.min(previousMin,parseInt(current));},Infinity);return memo;},{});}/**\n * 返回需要重新获取的键\n * @param callResults current call result state\n * @param listeningKeys each call key mapped to how old the data can be in blocks\n * @param chainId the current chain id\n * @param latestBlockNumber the latest block number\n */export function outdatedListeningKeys(callResults,listeningKeys,chainId,latestBlockNumber){if(!chainId||!latestBlockNumber)return[];const results=callResults[chainId];// no results at all, load everything\nif(!results)return Object.keys(listeningKeys);return Object.keys(listeningKeys).filter(callKey=>{const blocksPerFetch=listeningKeys[callKey];const data=callResults[chainId][callKey];// no data, must fetch\nif(!data)return true;const minDataBlockNumber=latestBlockNumber-(blocksPerFetch-1);// already fetching it for a recent enough block, don't refetch it\nif(data.fetchingBlockNumber&&data.fetchingBlockNumber>=minDataBlockNumber)return false;// if data is older than minDataBlockNumber, fetch it\nreturn!data.blockNumber||data.blockNumber<minDataBlockNumber;});}export default function Updater(_ref){let{type}=_ref;const dispatch=useDispatch();const state=useSelector(state=>state.multicall);// wait for listeners to settle before triggering updates\nconst debouncedListeners=useDebounce(state.callListeners,100);const{chainId}=useActiveWeb3React();// const useChainId = state.useChainId ? state.useChainId : chainId\nconst useChainId=type?state.useChainId:chainId;const latestBlockNumber=useBlockNumber(useChainId);const multicallContract=useMulticallContract();const multicallContract1=useRpcMulticallContract(useChainId);// console.log(type)\n// console.log(useChainId)\n// console.log(latestBlockNumber)\n// console.log(chainId)\n// console.log(state)\nconst cancellations=useRef();// console.log(multicallContract1)\n// console.log(multicallContract)\nconst listeningKeys=useMemo(()=>{return activeListeningKeys(debouncedListeners,useChainId);},[debouncedListeners,useChainId]);const unserializedOutdatedCallKeys=useMemo(()=>{return outdatedListeningKeys(state.callResults,listeningKeys,useChainId,latestBlockNumber);},[useChainId,state.callResults,listeningKeys,latestBlockNumber]);const serializedOutdatedCallKeys=useMemo(()=>JSON.stringify(unserializedOutdatedCallKeys.sort()),[unserializedOutdatedCallKeys]);const updateResults=useCallback(()=>{var _cancellations$curren;// console.log('latestBlockNumber', latestBlockNumber)\n// console.log('useChainId', useChainId)\n// console.log('multicallContract', multicallContract)\nif(!latestBlockNumber||!useChainId||!multicallContract)return;// console.log(useChainId, 1)\nconst outdatedCallKeys=JSON.parse(serializedOutdatedCallKeys);// console.log(outdatedCallKeys)\nif(outdatedCallKeys.length===0)return;const calls=outdatedCallKeys.map(key=>parseCallKey(key));// console.log(useChainId, 2)\nconst chunkedCalls=chunkArray(calls,CALL_CHUNK_SIZE);if(((_cancellations$curren=cancellations.current)===null||_cancellations$curren===void 0?void 0:_cancellations$curren.blockNumber)!==latestBlockNumber){var _cancellations$curren2,_cancellations$curren3;(_cancellations$curren2=cancellations.current)===null||_cancellations$curren2===void 0?void 0:(_cancellations$curren3=_cancellations$curren2.cancellations)===null||_cancellations$curren3===void 0?void 0:_cancellations$curren3.forEach(c=>c());}// console.log(calls)\ndispatch(fetchingMulticallResults({calls,chainId:useChainId,fetchingBlockNumber:latestBlockNumber}));// console.log(useChainId, 3)\ncancellations.current={blockNumber:latestBlockNumber,cancellations:chunkedCalls.map((chunk,index)=>{// console.log(chunkedCalls)\n// console.log(chunk)\n// if (index > 10) return () => {console.log()}\nconst{cancel,promise}=retry(()=>chainId&&useChainId&&Number(useChainId)!==Number(chainId)?fetchChunk1(multicallContract1,chunk,latestBlockNumber):fetchChunk(multicallContract,chunk,latestBlockNumber),{n:Infinity,minWait:2500,maxWait:3500});promise.then(_ref2=>{let{results:returnData,blockNumber:fetchBlockNumber}=_ref2;cancellations.current={cancellations:[],blockNumber:latestBlockNumber};// console.log(returnData)\n// accumulates the length of all previous indices\nconst firstCallKeyIndex=chunkedCalls.slice(0,index).reduce((memo,curr)=>memo+curr.length,0);const lastCallKeyIndex=firstCallKeyIndex+returnData.length;// dispatch(addUseChainId({ chainId: chainId }))\ndispatch(updateMulticallResults({chainId:useChainId,results:outdatedCallKeys.slice(firstCallKeyIndex,lastCallKeyIndex).reduce((memo,callKey,i)=>{var _returnData$i;memo[callKey]=(_returnData$i=returnData[i])!==null&&_returnData$i!==void 0?_returnData$i:null;return memo;},{}),blockNumber:fetchBlockNumber}));}).catch(error=>{if(error instanceof CancelledError){console.debug('Cancelled fetch for blockNumber',latestBlockNumber);return;}console.error('Failed to fetch multicall chunk',chunk,useChainId,error);dispatch(errorFetchingMulticallResults({calls:chunk,chainId:useChainId,fetchingBlockNumber:latestBlockNumber}));});return cancel;})};},[useChainId,multicallContract,dispatch,serializedOutdatedCallKeys,latestBlockNumber]);// console.log(listeningKeys)\n// console.log(serializedOutdatedCallKeys)\n// useEffect(() => {\n//   updateResults()\n// }, [])\nuseEffect(()=>{updateResults();},[useChainId,multicallContract,dispatch,serializedOutdatedCallKeys,latestBlockNumber]);return null;}","map":{"version":3,"names":["useCallback","useEffect","useMemo","useRef","useDispatch","useSelector","useActiveWeb3React","useMulticallContract","useRpcMulticallContract","useDebounce","chunkArray","CancelledError","retry","RetryableError","useBlockNumber","errorFetchingMulticallResults","fetchingMulticallResults","parseCallKey","updateMulticallResults","CALL_CHUNK_SIZE","fetchChunk","multicallContract","chunk","minBlockNumber","console","debug","resultsBlockNumber","returnData","aggregate","map","obj","address","callData","error","toNumber","results","blockNumber","fetchChunk1","methods","call","Number","concat","toString","activeListeningKeys","allListeners","chainId","listeners","Object","keys","reduce","memo","callKey","keyListeners","filter","key","blocksPerFetch","parseInt","previousMin","current","Math","min","Infinity","outdatedListeningKeys","callResults","listeningKeys","latestBlockNumber","data","minDataBlockNumber","fetchingBlockNumber","Updater","_ref","type","dispatch","state","multicall","debouncedListeners","callListeners","useChainId","multicallContract1","cancellations","unserializedOutdatedCallKeys","serializedOutdatedCallKeys","JSON","stringify","sort","updateResults","_cancellations$curren","outdatedCallKeys","parse","length","calls","chunkedCalls","_cancellations$curren2","_cancellations$curren3","forEach","c","index","cancel","promise","n","minWait","maxWait","then","_ref2","fetchBlockNumber","firstCallKeyIndex","slice","curr","lastCallKeyIndex","i","_returnData$i","catch"],"sources":["/workspace/Planq-Dapps/vesting-portal/src/state/multicall/updater.tsx"],"sourcesContent":["import { Contract } from '@ethersproject/contracts'\nimport { useCallback, useEffect, useMemo, useRef } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { useActiveWeb3React } from '../../hooks'\nimport { useMulticallContract, useRpcMulticallContract } from '../../hooks/useContract'\nimport useDebounce from '../../hooks/useDebounce'\nimport chunkArray from '../../utils/chunkArray'\nimport { CancelledError, retry, RetryableError } from '../../utils/retry'\nimport { useBlockNumber } from '../application/hooks'\nimport { AppDispatch, AppState } from '../index'\nimport {\n  Call,\n  // addUseChainId,\n  errorFetchingMulticallResults,\n  fetchingMulticallResults,\n  parseCallKey,\n  updateMulticallResults\n} from './actions'\n\n// 块调用，这样我们就不会超过气体限制\nconst CALL_CHUNK_SIZE = 500\n\n/**\n * 获取一组调用，强制执行最小块数约束\n * @param multicallContract multicall contract to fetch against\n * @param chunk chunk of calls to make\n * @param minBlockNumber minimum block number of the result set\n */\nexport async function fetchChunk(\n  multicallContract: Contract,\n  chunk: Call[],\n  minBlockNumber: number\n): Promise<{ results: string[]; blockNumber: number }> {\n  console.debug('Fetching chunk', multicallContract, chunk, minBlockNumber)\n  let resultsBlockNumber, returnData\n  // console.log('chunk')\n  // console.log(chunk)\n  try {\n    ;[resultsBlockNumber, returnData] = await multicallContract.aggregate(chunk.map(obj => [obj.address, obj.callData]))\n    // console.log('multicallContract1')\n  } catch (error) {\n    console.debug('Failed to fetch chunk inside retry', error)\n    throw error\n  }\n  if (resultsBlockNumber.toNumber() < minBlockNumber) {\n    // console.log(`Fetched results for old block number: ${resultsBlockNumber.toString()} vs. ${minBlockNumber}`)\n    // console.debug(`Fetched results for old block number: ${resultsBlockNumber.toString()} vs. ${minBlockNumber}`)\n    throw new RetryableError('Fetched for old block number')\n  }\n  // console.log({ results: returnData, blockNumber: resultsBlockNumber.toNumber() })\n  return { results: returnData, blockNumber: resultsBlockNumber.toNumber() }\n}\n\n/**\n * 获取一组调用，强制执行最小块数约束\n * @param multicallContract multicall contract to fetch against\n * @param chunk chunk of calls to make\n * @param minBlockNumber minimum block number of the result set\n */\n async function fetchChunk1(\n  multicallContract: any,\n  chunk: Call[],\n  minBlockNumber: number\n): Promise<{ results: string[]; blockNumber: number }> {\n  console.debug('Fetching chunk', multicallContract, chunk, minBlockNumber)\n  let resultsBlockNumber, returnData\n  // console.log(multicallContract)\n  try {\n    // multicallContract.methods.aggregate(chunk.map(obj => [obj.address, obj.callData])).call((err:any, res:any) => {\n    //   console.log(err)\n    //   console.log(res)\n    // })\n    // console.log(await multicallContract.methods.aggregate(chunk.map(obj => [obj.address, obj.callData])).call())\n    const callData = await multicallContract.methods.aggregate(chunk.map(obj => [obj.address, obj.callData])).call()\n    resultsBlockNumber = callData.blockNumber ? Number(callData.blockNumber) : 0\n    returnData = callData.returnData\n    // ;[resultsBlockNumber, returnData] = await multicallContract.methods.aggregate(chunk.map(obj => [obj.address, obj.callData])).call()\n  } catch (error) {\n    console.debug('Failed to fetch chunk inside retry', error)\n    throw error\n  }\n  if (resultsBlockNumber < minBlockNumber) {\n    console.debug(`Fetched results for old block number: ${resultsBlockNumber.toString()} vs. ${minBlockNumber}`)\n    throw new RetryableError('Fetched for old block number')\n  }\n  // console.log({ results: returnData, blockNumber: resultsBlockNumber })\n  return { results: returnData, blockNumber: resultsBlockNumber }\n}\n\n/**\n * 从当前的所有侦听器状态，返回映射到每次读取的最小块数。这是每个键必须被获取的频率。\n * @param allListeners the all listeners state\n * @param chainId the current chain id\n */\nexport function activeListeningKeys(\n  allListeners: AppState['multicall']['callListeners'],\n  chainId?: number\n): { [callKey: string]: number } {\n  if (!allListeners || !chainId) return {}\n  const listeners = allListeners[chainId]\n  if (!listeners) return {}\n  // console.log(listeners)\n  return Object.keys(listeners).reduce<{ [callKey: string]: number }>((memo, callKey) => {\n    const keyListeners = listeners[callKey]\n\n    memo[callKey] = Object.keys(keyListeners)\n      .filter(key => {\n        const blocksPerFetch = parseInt(key)\n        if (blocksPerFetch <= 0) return false\n        return keyListeners[blocksPerFetch] > 0\n      })\n      .reduce((previousMin, current) => {\n        return Math.min(previousMin, parseInt(current))\n      }, Infinity)\n    return memo\n  }, {})\n}\n\n/**\n * 返回需要重新获取的键\n * @param callResults current call result state\n * @param listeningKeys each call key mapped to how old the data can be in blocks\n * @param chainId the current chain id\n * @param latestBlockNumber the latest block number\n */\nexport function outdatedListeningKeys(\n  callResults: AppState['multicall']['callResults'],\n  listeningKeys: { [callKey: string]: number },\n  chainId: number | undefined,\n  latestBlockNumber: number | undefined\n): string[] {\n  if (!chainId || !latestBlockNumber) return []\n  const results = callResults[chainId]\n  // no results at all, load everything\n  if (!results) return Object.keys(listeningKeys)\n\n  return Object.keys(listeningKeys).filter(callKey => {\n    const blocksPerFetch = listeningKeys[callKey]\n\n    const data = callResults[chainId][callKey]\n    // no data, must fetch\n    if (!data) return true\n\n    const minDataBlockNumber = latestBlockNumber - (blocksPerFetch - 1)\n\n    // already fetching it for a recent enough block, don't refetch it\n    if (data.fetchingBlockNumber && data.fetchingBlockNumber >= minDataBlockNumber) return false\n\n    // if data is older than minDataBlockNumber, fetch it\n    return !data.blockNumber || data.blockNumber < minDataBlockNumber\n  })\n}\n\nexport default function Updater({type}: {type?:number}): null {\n  const dispatch = useDispatch<AppDispatch>()\n  const state = useSelector<AppState, AppState['multicall']>(state => state.multicall)\n  // wait for listeners to settle before triggering updates\n  const debouncedListeners = useDebounce(state.callListeners, 100)\n  const { chainId } = useActiveWeb3React()\n  // const useChainId = state.useChainId ? state.useChainId : chainId\n  const useChainId = type ? state.useChainId : chainId\n  const latestBlockNumber = useBlockNumber(useChainId)\n  const multicallContract = useMulticallContract()\n  const multicallContract1 = useRpcMulticallContract(useChainId)\n\n  // console.log(type)\n  // console.log(useChainId)\n  // console.log(latestBlockNumber)\n  // console.log(chainId)\n  // console.log(state)\n  const cancellations = useRef<{ blockNumber: number; cancellations: (() => void)[] }>()\n  // console.log(multicallContract1)\n  // console.log(multicallContract)\n  const listeningKeys: { [callKey: string]: number } = useMemo(() => {\n    return activeListeningKeys(debouncedListeners, useChainId)\n  }, [debouncedListeners, useChainId])\n\n  const unserializedOutdatedCallKeys = useMemo(() => {\n    return outdatedListeningKeys(state.callResults, listeningKeys, useChainId, latestBlockNumber)\n  }, [useChainId, state.callResults, listeningKeys, latestBlockNumber])\n\n  const serializedOutdatedCallKeys = useMemo(() => JSON.stringify(unserializedOutdatedCallKeys.sort()), [\n    unserializedOutdatedCallKeys\n  ])\n\n  const updateResults = useCallback(() => {\n    // console.log('latestBlockNumber', latestBlockNumber)\n    // console.log('useChainId', useChainId)\n    // console.log('multicallContract', multicallContract)\n    if (!latestBlockNumber || !useChainId || !multicallContract) return\n    \n    // console.log(useChainId, 1)\n    const outdatedCallKeys: string[] = JSON.parse(serializedOutdatedCallKeys)\n    // console.log(outdatedCallKeys)\n    if (outdatedCallKeys.length === 0) return\n    const calls = outdatedCallKeys.map(key => parseCallKey(key))\n    // console.log(useChainId, 2)\n    const chunkedCalls = chunkArray(calls, CALL_CHUNK_SIZE)\n\n    if (cancellations.current?.blockNumber !== latestBlockNumber) {\n      cancellations.current?.cancellations?.forEach(c => c())\n    }\n    // console.log(calls)\n    dispatch(\n      fetchingMulticallResults({\n        calls,\n        chainId: useChainId,\n        fetchingBlockNumber: latestBlockNumber\n      })\n    )\n    // console.log(useChainId, 3)\n    cancellations.current = {\n      blockNumber: latestBlockNumber,\n      cancellations: chunkedCalls.map((chunk, index) => {\n        // console.log(chunkedCalls)\n        // console.log(chunk)\n        // if (index > 10) return () => {console.log()}\n        const { cancel, promise } = retry(() => chainId && useChainId && Number(useChainId) !== Number(chainId) ? fetchChunk1(multicallContract1, chunk, latestBlockNumber) : fetchChunk(multicallContract, chunk, latestBlockNumber), {\n          n: Infinity,\n          minWait: 2500,\n          maxWait: 3500\n        })\n        \n        promise\n          .then(({ results: returnData, blockNumber: fetchBlockNumber }) => {\n            cancellations.current = { cancellations: [], blockNumber: latestBlockNumber }\n            // console.log(returnData)\n            // accumulates the length of all previous indices\n            const firstCallKeyIndex = chunkedCalls.slice(0, index).reduce<number>((memo, curr) => memo + curr.length, 0)\n            const lastCallKeyIndex = firstCallKeyIndex + returnData.length\n            // dispatch(addUseChainId({ chainId: chainId }))\n            dispatch(\n              updateMulticallResults({\n                chainId: useChainId,\n                results: outdatedCallKeys\n                  .slice(firstCallKeyIndex, lastCallKeyIndex)\n                  .reduce<{ [callKey: string]: string | null }>((memo, callKey, i) => {\n                    memo[callKey] = returnData[i] ?? null\n                    return memo\n                  }, {}),\n                blockNumber: fetchBlockNumber\n              })\n            )\n          })\n          .catch((error: any) => {\n            if (error instanceof CancelledError) {\n              console.debug('Cancelled fetch for blockNumber', latestBlockNumber)\n              return\n            }\n            console.error('Failed to fetch multicall chunk', chunk, useChainId, error)\n            dispatch(\n              errorFetchingMulticallResults({\n                calls: chunk,\n                chainId: useChainId,\n                fetchingBlockNumber: latestBlockNumber\n              })\n            )\n          })\n        return cancel\n      })\n    }\n  }, [useChainId, multicallContract, dispatch, serializedOutdatedCallKeys, latestBlockNumber])\n  // console.log(listeningKeys)\n  // console.log(serializedOutdatedCallKeys)\n  // useEffect(() => {\n  //   updateResults()\n  // }, [])\n  useEffect(() => {\n    updateResults()\n  }, [useChainId, multicallContract, dispatch, serializedOutdatedCallKeys, latestBlockNumber])\n\n  return null\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}