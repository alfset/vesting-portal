{"ast":null,"code":"import { spawn, SUBSCRIBE, UNSUBSCRIBE, send, subscriber } from '@onflow/util-actor';\nimport * as logger from '@onflow/util-logger';\nimport { invariant } from '@onflow/util-invariant';\nconst pipe = function () {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n  return v => {\n    return funcs.reduce((res, func) => {\n      return func(res);\n    }, v);\n  };\n};\n\n/***\n * Merge multiple functions returning objects into one object.\n * @param funcs - Functions to merge\n * @return Merged object\n */\nconst mergePipe = function () {\n  for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    funcs[_key2] = arguments[_key2];\n  }\n  return v => {\n    return funcs.reduce((res, func) => {\n      return {\n        ...res,\n        ...func(v)\n      };\n    }, {});\n  };\n};\n\n/**\n * @description Object check\n * @param value - Value to check\n * @returns Is object status\n */\nconst isObject = value => value && typeof value === \"object\" && !Array.isArray(value);\n\n/**\n * @description Deep merge multiple objects.\n * @param target - Target object\n * @param sources - Source objects\n * @returns Merged object\n */\nconst mergeDeep = function (target) {\n  for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    sources[_key3 - 1] = arguments[_key3];\n  }\n  if (!sources.length) return target;\n  const source = sources.shift();\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, {\n          [key]: {}\n        });\n        mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n  return mergeDeep(target, ...sources);\n};\n\n/**\n * @description Deep merge multiple Flow JSON.\n * @param value - Flow JSON or array of Flow JSONs\n * @returns Merged Flow JSON\n */\nconst mergeFlowJSONs = value => Array.isArray(value) ? mergeDeep({}, ...value) : value;\n\n/**\n * @description Filter out contracts section of flow.json.\n * @param obj - Flow JSON\n * @returns Contracts section of Flow JSON\n */\nconst filterContracts = obj => obj.contracts ? obj.contracts : {};\n\n/**\n * @description Gathers contract addresses by network\n * @param network - Network to gather addresses for\n * @returns Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst mapContractAliasesToNetworkAddress = network => contracts => {\n  return Object.entries(contracts).reduce((c, _ref) => {\n    var _value$aliases;\n    let [key, value] = _ref;\n    const networkContractAlias = value === null || value === void 0 || (_value$aliases = value.aliases) === null || _value$aliases === void 0 ? void 0 : _value$aliases[network];\n    if (networkContractAlias) {\n      c[key] = networkContractAlias;\n    }\n    return c;\n  }, {});\n};\nconst mapDeploymentsToNetworkAddress = network => _ref2 => {\n  let {\n    deployments = {},\n    accounts = {}\n  } = _ref2;\n  const networkDeployment = deployments === null || deployments === void 0 ? void 0 : deployments[network];\n  if (!networkDeployment) return {};\n  return Object.entries(networkDeployment).reduce((c, _ref3) => {\n    var _accounts$key;\n    let [key, value] = _ref3;\n    // Resolve account address\n    const accountAddress = (_accounts$key = accounts[key]) === null || _accounts$key === void 0 ? void 0 : _accounts$key.address;\n    if (!accountAddress) return c;\n\n    // Create an object assigning the address to the contract name.\n    return value.reduce((c, contract) => {\n      return {\n        ...c,\n        [contract]: accountAddress\n      };\n    }, {});\n  }, {});\n};\n\n/**\n * @description Take in flow.json files and return contract to address mapping by network\n * @param jsons - Flow JSON or array of Flow JSONs\n * @param network - Network to gather addresses for\n * @returns Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst getContracts = (jsons, network) => {\n  return pipe(mergeFlowJSONs, mergePipe(mapDeploymentsToNetworkAddress(network), pipe(filterContracts, mapContractAliasesToNetworkAddress(network))))(jsons);\n};\n\n/**\n * @description Checks if string is hexidecimal\n * @param str - String to check\n * @returns Is hexidecimal status\n */\nconst isHexidecimal = str => {\n  // Check that it is a string\n  if (typeof str !== \"string\") return false;\n  return /^[0-9A-Fa-f]+$/.test(str);\n};\n\n/**\n * @description Checks flow.json file for private keys\n * @param flowJSON - Flow JSON\n * @returns Has private keys status\n */\nconst hasPrivateKeys = flowJSON => {\n  var _flowJSON$accounts;\n  return Object.entries((_flowJSON$accounts = flowJSON === null || flowJSON === void 0 ? void 0 : flowJSON.accounts) !== null && _flowJSON$accounts !== void 0 ? _flowJSON$accounts : []).reduce((hasPrivateKey, _ref4) => {\n    let [, value] = _ref4;\n    if (hasPrivateKey) return true;\n    return value && Object.prototype.hasOwnProperty.call(value, \"key\") && isHexidecimal(value === null || value === void 0 ? void 0 : value.key);\n  }, false);\n};\n\n/**\n * @description Take in flow.json or array of flow.json files and checks for private keys\n * @param value - Flow JSON or array of Flow JSONs\n * @returns Has private keys status\n */\nconst anyHasPrivateKeys = value => {\n  if (Array.isArray(value)) return value.some(hasPrivateKeys);\n  return hasPrivateKeys(value);\n};\n\n/**\n * @description Format network to always be 'emulator', 'testnet', or 'mainnet'\n * @param network - Network to format\n * @returns Formatted network name (either 'emulator', 'testnet', or 'mainnet')\n */\nconst cleanNetwork = network => {\n  const cleanedNetwork = (network === null || network === void 0 ? void 0 : network.toLowerCase()) === \"local\" ? \"emulator\" : network === null || network === void 0 ? void 0 : network.toLowerCase();\n  if (cleanedNetwork === \"emulator\" || cleanedNetwork === \"testnet\" || cleanedNetwork === \"mainnet\") return cleanedNetwork;\n  throw new Error(\"Invalid network \\\"\".concat(network, \"\\\". Must be one of \\\"emulator\\\", \\\"local\\\", \\\"testnet\\\", or \\\"mainnet\\\"\"));\n};\n\n// Inject config into logger to break circular dependency\nlogger.setConfig(config);\nconst NAME = \"config\";\nconst PUT = \"PUT_CONFIG\";\nconst GET = \"GET_CONFIG\";\nconst GET_ALL = \"GET_ALL_CONFIG\";\nconst UPDATE = \"UPDATE_CONFIG\";\nconst DELETE = \"DELETE_CONFIG\";\nconst CLEAR = \"CLEAR_CONFIG\";\nconst WHERE = \"WHERE_CONFIG\";\nconst UPDATED = \"CONFIG/UPDATED\";\nconst identity = v => v;\nconst HANDLERS = {\n  [PUT]: (ctx, _letter, _ref) => {\n    let {\n      key,\n      value\n    } = _ref;\n    if (key == null) throw new Error(\"Missing 'key' for config/put.\");\n    ctx.put(key, value);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [GET]: (ctx, letter, _ref2) => {\n    let {\n      key,\n      fallback\n    } = _ref2;\n    if (key == null) throw new Error(\"Missing 'key' for config/get\");\n    letter.reply(ctx.get(key, fallback));\n  },\n  [GET_ALL]: (ctx, letter) => {\n    letter.reply({\n      ...ctx.all()\n    });\n  },\n  [UPDATE]: (ctx, letter, _ref3) => {\n    let {\n      key,\n      fn\n    } = _ref3;\n    if (key == null) throw new Error(\"Missing 'key' for config/update\");\n    ctx.update(key, fn || identity);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [DELETE]: (ctx, letter, _ref4) => {\n    let {\n      key\n    } = _ref4;\n    if (key == null) throw new Error(\"Missing 'key' for config/delete\");\n    ctx.delete(key);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [CLEAR]: ctx => {\n    const keys = Object.keys(ctx.all());\n    for (const key of keys) ctx.delete(key);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [WHERE]: (ctx, letter, _ref5) => {\n    let {\n      pattern\n    } = _ref5;\n    if (pattern == null) throw new Error(\"Missing 'pattern' for config/where\");\n    letter.reply(ctx.where(pattern));\n  },\n  [SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from);\n    ctx.send(letter.from, UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from);\n  }\n};\nspawn(HANDLERS, NAME);\n\n/**\n * @description Adds a key-value pair to the config\n * @param key - The key to add\n * @param value - The value to add\n * @returns The config object\n */\nfunction put(key, value) {\n  send(NAME, PUT, {\n    key,\n    value\n  });\n  return config();\n}\n\n/**\n * @description Gets a key-value pair with a fallback from the config\n * @param key - The key to add\n * @param fallback - The fallback value to return if key is not found\n * @returns The value found at key or fallback\n */\nfunction get(key, fallback) {\n  return send(NAME, GET, {\n    key,\n    fallback\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Returns the first non null config value or the fallback\n * @param wants - The keys to search for\n * @param fallback - The fallback value to return if key is not found\n * @returns The value found at key or fallback\n */\nasync function first() {\n  let wants = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let fallback = arguments.length > 1 ? arguments[1] : undefined;\n  if (!wants.length) return fallback;\n  const [head, ...rest] = wants;\n  const ret = await get(head);\n  if (ret == null) return first(rest, fallback);\n  return ret;\n}\n\n/**\n * @description Returns the current config\n * @returns The config object\n */\nfunction all() {\n  return send(NAME, GET_ALL, null, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Updates a key-value pair in the config\n * @param key - The key to update\n * @param fn - The function to update the value with\n * @returns The config object\n */\nfunction update(key) {\n  let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;\n  send(NAME, UPDATE, {\n    key,\n    fn\n  });\n  return config();\n}\n\n/**\n * @description Deletes a key-value pair from the config\n * @param key - The key to delete\n * @returns The config object\n */\nfunction _delete(key) {\n  send(NAME, DELETE, {\n    key\n  });\n  return config();\n}\n\n/**\n * @description Returns a subset of the config based on a pattern\n * @param pattern - The pattern to match keys against\n * @returns The subset of the config\n */\nfunction where(pattern) {\n  return send(NAME, WHERE, {\n    pattern\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Subscribes to config updates\n * @param callback - The callback to call when config is updated\n * @returns The unsubscribe function\n */\nfunction subscribe(callback) {\n  return subscriber(NAME, () => spawn(HANDLERS, NAME), callback);\n}\n\n/**\n * @description Clears the config\n */\nasync function clearConfig() {\n  await send(NAME, CLEAR);\n}\n\n/**\n * @description Resets the config to a previous state\n * @param oldConfig - The previous config state\n * @returns The config object\n */\nasync function resetConfig(oldConfig) {\n  return clearConfig().then(() => config(oldConfig));\n}\n\n/**\n * @description Takes in flow.json or array of flow.json files and creates contract placeholders\n * @param data - The data to load\n * @param data.flowJSON - The flow.json or array of flow.json files\n */\nasync function load(data) {\n  const network = await get(\"flow.network\");\n  const cleanedNetwork = cleanNetwork(network);\n  const {\n    flowJSON\n  } = data;\n  invariant(Boolean(flowJSON), \"config.load -- 'flowJSON' must be defined\");\n  invariant(!!cleanedNetwork, \"Flow Network Required -- In order for FCL to load your contracts please define \\\"flow.network\\\" to \\\"emulator\\\", \\\"local\\\", \\\"testnet\\\", or \\\"mainnet\\\" in your config. See more here: https://developers.flow.com/tools/fcl-js/reference/configure-fcl\");\n  if (anyHasPrivateKeys(flowJSON)) {\n    const isEmulator = cleanedNetwork === \"emulator\";\n    logger.log({\n      title: \"Private Keys Detected\",\n      message: \"Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security\",\n      level: isEmulator ? logger.LEVELS.warn : logger.LEVELS.error\n    });\n    invariant(isEmulator, \"Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security\");\n  }\n  for (const [key, value] of Object.entries(getContracts(flowJSON, cleanedNetwork))) {\n    const contractConfigKey = \"0x\".concat(key);\n    const existingContractConfigKey = await get(contractConfigKey);\n    if (existingContractConfigKey && existingContractConfigKey !== value) {\n      logger.log({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: \"A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.\",\n        level: logger.LEVELS.warn\n      });\n    } else {\n      put(contractConfigKey, value);\n    }\n    const systemContractConfigKey = \"system.contracts.\".concat(key);\n    const systemExistingContractConfigKeyValue = await get(systemContractConfigKey);\n    if (systemExistingContractConfigKeyValue && systemExistingContractConfigKeyValue !== value) {\n      logger.log({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: \"A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.\",\n        level: logger.LEVELS.warn\n      });\n    } else {\n      put(systemContractConfigKey, value);\n    }\n  }\n}\n\n/**\n * @description Sets the config\n * @param values - The values to set\n * @returns The config object\n */\nfunction config(values) {\n  if (values != null && typeof values === \"object\") {\n    Object.keys(values).map(d => put(d, values[d]));\n  }\n  return {\n    put,\n    get,\n    all,\n    first,\n    update,\n    delete: _delete,\n    where,\n    subscribe,\n    overload,\n    load\n  };\n}\nconfig.put = put;\nconfig.get = get;\nconfig.all = all;\nconfig.first = first;\nconfig.update = update;\nconfig.delete = _delete;\nconfig.where = where;\nconfig.subscribe = subscribe;\nconfig.overload = overload;\nconfig.load = load;\n\n/**\n * @description Temporarily overloads the config with the given values and calls the callback\n * @param values - The values to overload the config with\n * @param callback - The callback to call with the overloaded config\n * @returns The result of the callback\n */\nasync function overload(values, callback) {\n  const oldConfig = await all();\n  try {\n    config(values);\n    const result = await callback(await all());\n    return result;\n  } finally {\n    await resetConfig(oldConfig);\n  }\n}\nexport { clearConfig, config };","map":{"version":3,"names":["pipe","_len","arguments","length","funcs","Array","_key","v","reduce","res","func","mergePipe","_len2","_key2","isObject","value","isArray","mergeDeep","target","_len3","sources","_key3","source","shift","key","Object","assign","mergeFlowJSONs","filterContracts","obj","contracts","mapContractAliasesToNetworkAddress","network","entries","c","_ref","_value$aliases","networkContractAlias","aliases","mapDeploymentsToNetworkAddress","_ref2","deployments","accounts","networkDeployment","_ref3","_accounts$key","accountAddress","address","contract","getContracts","jsons","isHexidecimal","str","test","hasPrivateKeys","flowJSON","_flowJSON$accounts","hasPrivateKey","_ref4","prototype","hasOwnProperty","call","anyHasPrivateKeys","some","cleanNetwork","cleanedNetwork","toLowerCase","Error","concat","logger","setConfig","config","NAME","PUT","GET","GET_ALL","UPDATE","DELETE","CLEAR","WHERE","UPDATED","identity","HANDLERS","ctx","_letter","put","broadcast","all","letter","fallback","reply","get","fn","update","delete","keys","_ref5","pattern","where","SUBSCRIBE","subscribe","from","send","UNSUBSCRIBE","unsubscribe","spawn","expectReply","timeout","first","wants","undefined","head","rest","ret","_delete","callback","subscriber","clearConfig","resetConfig","oldConfig","then","load","data","invariant","Boolean","isEmulator","log","title","message","level","LEVELS","warn","error","contractConfigKey","existingContractConfigKey","systemContractConfigKey","systemExistingContractConfigKeyValue","values","map","d","overload","result"],"sources":["../src/utils/utils.ts","../src/config.ts"],"sourcesContent":["type FlowNetwork = \"emulator\" | \"testnet\" | \"mainnet\"\nexport interface FlowJson {\n  networks?: {\n    [key in FlowNetwork]?: string\n  }\n  accounts?: {\n    [key: string]: {\n      address: string\n      key?: string | object\n    }\n  }\n  contracts?: {\n    [key: string]: {\n      source: string\n      aliases: {\n        [key in FlowNetwork]?: string\n      }\n    }\n  }\n  deployments?: {\n    [key in FlowNetwork]?: {\n      [contract: string]: string[]\n    }\n  }\n}\n\nconst pipe =\n  (...funcs: ((v: any) => any)[]) =>\n  (v: any) => {\n    return funcs.reduce((res, func) => {\n      return func(res)\n    }, v)\n  }\n\n/***\n * Merge multiple functions returning objects into one object.\n * @param funcs - Functions to merge\n * @return Merged object\n */\nconst mergePipe =\n  (...funcs: ((v: any) => any)[]) =>\n  (v: any) => {\n    return funcs.reduce((res, func) => {\n      return {...res, ...func(v)}\n    }, {})\n  }\n\n/**\n * @description Object check\n * @param value - Value to check\n * @returns Is object status\n */\nconst isObject = <T>(value: T): boolean =>\n  value && typeof value === \"object\" && !Array.isArray(value)\n\n/**\n * @description Deep merge multiple objects.\n * @param target - Target object\n * @param sources - Source objects\n * @returns Merged object\n */\nconst mergeDeep = (target: any, ...sources: any[]): any => {\n  if (!sources.length) return target\n  const source = sources.shift()\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, {[key]: {}})\n        mergeDeep(target[key], source[key])\n      } else {\n        Object.assign(target, {[key]: source[key]})\n      }\n    }\n  }\n\n  return mergeDeep(target, ...sources)\n}\n\n/**\n * @description Support if/then/else behavior in a function way.\n * @param testFn - Function to test\n * @param posCond - Function to run if testFn is true\n * @param negCond - Function to run it testFn is false\n * @returns Function that returns the result of posCond or negCond\n */\nexport const ifElse =\n  <T, U>(testFn: (v: T) => U, posCond: (v: T) => U, negCond: (v: T) => U) =>\n  (v: T) =>\n    testFn(v) ? posCond(v) : negCond(v)\n\n/**\n * @description Deep merge multiple Flow JSON.\n * @param value - Flow JSON or array of Flow JSONs\n * @returns Merged Flow JSON\n */\nconst mergeFlowJSONs = (value: FlowJson | FlowJson[]) =>\n  Array.isArray(value) ? mergeDeep({}, ...value) : value\n\n/**\n * @description Filter out contracts section of flow.json.\n * @param obj - Flow JSON\n * @returns Contracts section of Flow JSON\n */\nconst filterContracts = (obj: FlowJson) => (obj.contracts ? obj.contracts : {})\n\n/**\n * @description Gathers contract addresses by network\n * @param network - Network to gather addresses for\n * @returns Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst mapContractAliasesToNetworkAddress =\n  (network: string) => (contracts: Record<string, any>) => {\n    return Object.entries(contracts).reduce((c, [key, value]) => {\n      const networkContractAlias = value?.aliases?.[network]\n      if (networkContractAlias) {\n        c[key] = networkContractAlias\n      }\n\n      return c\n    }, {} as Record<string, string>)\n  }\n\nconst mapDeploymentsToNetworkAddress =\n  (network: FlowNetwork) =>\n  ({\n    deployments = {},\n    accounts = {},\n  }: Pick<FlowJson, \"deployments\" | \"accounts\">) => {\n    const networkDeployment = deployments?.[network]\n    if (!networkDeployment) return {}\n\n    return Object.entries(networkDeployment).reduce((c, [key, value]) => {\n      // Resolve account address\n      const accountAddress = accounts[key]?.address\n      if (!accountAddress) return c\n\n      // Create an object assigning the address to the contract name.\n      return value.reduce((c, contract) => {\n        return {...c, [contract]: accountAddress}\n      }, {})\n    }, {})\n  }\n\n/**\n * @description Take in flow.json files and return contract to address mapping by network\n * @param jsons - Flow JSON or array of Flow JSONs\n * @param network - Network to gather addresses for\n * @returns Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nexport const getContracts = (\n  jsons: FlowJson | FlowJson[],\n  network: FlowNetwork\n) => {\n  return pipe(\n    mergeFlowJSONs,\n    mergePipe(\n      mapDeploymentsToNetworkAddress(network),\n      pipe(filterContracts, mapContractAliasesToNetworkAddress(network))\n    )\n  )(jsons)\n}\n\n/**\n * @description Checks if string is hexidecimal\n * @param str - String to check\n * @returns Is hexidecimal status\n */\nconst isHexidecimal = (str: unknown) => {\n  // Check that it is a string\n  if (typeof str !== \"string\") return false\n  return /^[0-9A-Fa-f]+$/.test(str)\n}\n\n/**\n * @description Checks flow.json file for private keys\n * @param flowJSON - Flow JSON\n * @returns Has private keys status\n */\nconst hasPrivateKeys = (flowJSON: FlowJson) => {\n  return Object.entries(flowJSON?.accounts ?? []).reduce(\n    (hasPrivateKey, [, value]) => {\n      if (hasPrivateKey) return true\n      return (\n        value &&\n        Object.prototype.hasOwnProperty.call(value, \"key\") &&\n        isHexidecimal(value?.key)\n      )\n    },\n    false\n  )\n}\n\n/**\n * @description Take in flow.json or array of flow.json files and checks for private keys\n * @param value - Flow JSON or array of Flow JSONs\n * @returns Has private keys status\n */\nexport const anyHasPrivateKeys = (value: FlowJson | FlowJson[]) => {\n  if (Array.isArray(value)) return value.some(hasPrivateKeys)\n  return hasPrivateKeys(value)\n}\n\n/**\n * @description Format network to always be 'emulator', 'testnet', or 'mainnet'\n * @param network - Network to format\n * @returns Formatted network name (either 'emulator', 'testnet', or 'mainnet')\n */\nexport const cleanNetwork = (network: string): FlowNetwork => {\n  const cleanedNetwork =\n    network?.toLowerCase() === \"local\" ? \"emulator\" : network?.toLowerCase()\n  if (\n    cleanedNetwork === \"emulator\" ||\n    cleanedNetwork === \"testnet\" ||\n    cleanedNetwork === \"mainnet\"\n  )\n    return cleanedNetwork\n\n  throw new Error(\n    `Invalid network \"${network}\". Must be one of \"emulator\", \"local\", \"testnet\", or \"mainnet\"`\n  )\n}\n","import {\n  spawn,\n  send,\n  subscriber,\n  SUBSCRIBE,\n  UNSUBSCRIBE,\n  ActorHandlers,\n} from \"@onflow/util-actor\"\nimport * as logger from \"@onflow/util-logger\"\nimport {invariant} from \"@onflow/util-invariant\"\nimport {getContracts, cleanNetwork, anyHasPrivateKeys} from \"./utils/utils\"\n\n// Inject config into logger to break circular dependency\nlogger.setConfig(config)\n\nconst NAME = \"config\"\nconst PUT = \"PUT_CONFIG\"\nconst GET = \"GET_CONFIG\"\nconst GET_ALL = \"GET_ALL_CONFIG\"\nconst UPDATE = \"UPDATE_CONFIG\"\nconst DELETE = \"DELETE_CONFIG\"\nconst CLEAR = \"CLEAR_CONFIG\"\nconst WHERE = \"WHERE_CONFIG\"\nconst UPDATED = \"CONFIG/UPDATED\"\n\nconst identity = <T>(v: T) => v\n\nconst HANDLERS: ActorHandlers = {\n  [PUT]: (ctx, _letter, {key, value}) => {\n    if (key == null) throw new Error(\"Missing 'key' for config/put.\")\n    ctx.put(key, value)\n    ctx.broadcast(UPDATED, {...ctx.all()})\n  },\n  [GET]: (ctx, letter, {key, fallback}) => {\n    if (key == null) throw new Error(\"Missing 'key' for config/get\")\n    letter.reply(ctx.get(key, fallback))\n  },\n  [GET_ALL]: (ctx, letter) => {\n    letter.reply({...ctx.all()})\n  },\n  [UPDATE]: (ctx, letter, {key, fn}) => {\n    if (key == null) throw new Error(\"Missing 'key' for config/update\")\n    ctx.update(key, fn || identity)\n    ctx.broadcast(UPDATED, {...ctx.all()})\n  },\n  [DELETE]: (ctx, letter, {key}) => {\n    if (key == null) throw new Error(\"Missing 'key' for config/delete\")\n    ctx.delete(key)\n    ctx.broadcast(UPDATED, {...ctx.all()})\n  },\n  [CLEAR]: ctx => {\n    const keys = Object.keys(ctx.all())\n    for (const key of keys) ctx.delete(key)\n    ctx.broadcast(UPDATED, {...ctx.all()})\n  },\n  [WHERE]: (ctx, letter, {pattern}) => {\n    if (pattern == null) throw new Error(\"Missing 'pattern' for config/where\")\n    letter.reply(ctx.where(pattern))\n  },\n  [SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from)\n    ctx.send(letter.from, UPDATED, {...ctx.all()})\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from)\n  },\n}\n\nspawn(HANDLERS, NAME)\n\n/**\n * @description Adds a key-value pair to the config\n * @param key - The key to add\n * @param value - The value to add\n * @returns The config object\n */\nfunction put<T>(key: string, value: T) {\n  send(NAME, PUT, {key, value})\n  return config()\n}\n\n/**\n * @description Gets a key-value pair with a fallback from the config\n * @param key - The key to add\n * @param fallback - The fallback value to return if key is not found\n * @returns The value found at key or fallback\n */\nfunction get<T>(key: string, fallback?: T): Promise<T> {\n  return send(NAME, GET, {key, fallback}, {expectReply: true, timeout: 10})\n}\n\n/**\n * @description Returns the first non null config value or the fallback\n * @param wants - The keys to search for\n * @param fallback - The fallback value to return if key is not found\n * @returns The value found at key or fallback\n */\nasync function first<T>(wants: string[] = [], fallback: T): Promise<T> {\n  if (!wants.length) return fallback\n  const [head, ...rest] = wants\n  const ret = await get<T>(head)\n  if (ret == null) return first(rest, fallback)\n  return ret\n}\n\n/**\n * @description Returns the current config\n * @returns The config object\n */\nfunction all(): Promise<Record<string, unknown>> {\n  return send(NAME, GET_ALL, null, {expectReply: true, timeout: 10})\n}\n\n/**\n * @description Updates a key-value pair in the config\n * @param key - The key to update\n * @param fn - The function to update the value with\n * @returns The config object\n */\nfunction update<T>(key: string, fn: (x: T) => T = identity) {\n  send(NAME, UPDATE, {key, fn})\n  return config()\n}\n\n/**\n * @description Deletes a key-value pair from the config\n * @param key - The key to delete\n * @returns The config object\n */\nfunction _delete(key: string) {\n  send(NAME, DELETE, {key})\n  return config()\n}\n\n/**\n * @description Returns a subset of the config based on a pattern\n * @param pattern - The pattern to match keys against\n * @returns The subset of the config\n */\nfunction where(pattern: RegExp): Promise<Record<string, unknown>> {\n  return send(NAME, WHERE, {pattern}, {expectReply: true, timeout: 10})\n}\n\n/**\n * @description Subscribes to config updates\n * @param callback - The callback to call when config is updated\n * @returns The unsubscribe function\n */\nfunction subscribe(\n  callback: (\n    config: Record<string, unknown> | null,\n    error: Error | null\n  ) => void\n): () => void {\n  return subscriber(NAME, () => spawn(HANDLERS, NAME), callback)\n}\n\n/**\n * @description Clears the config\n */\nexport async function clearConfig(): Promise<void> {\n  await send(NAME, CLEAR)\n}\n\n/**\n * @description Resets the config to a previous state\n * @param oldConfig - The previous config state\n * @returns The config object\n */\nasync function resetConfig(oldConfig: Record<string, unknown>) {\n  return clearConfig().then(() => config(oldConfig))\n}\n\n/**\n * @description Takes in flow.json or array of flow.json files and creates contract placeholders\n * @param data - The data to load\n * @param data.flowJSON - The flow.json or array of flow.json files\n */\nasync function load(data: {\n  flowJSON: Record<string, unknown> | Record<string, unknown>[]\n}) {\n  const network: string = await get(\"flow.network\")\n  const cleanedNetwork = cleanNetwork(network)\n  const {flowJSON} = data\n\n  invariant(Boolean(flowJSON), \"config.load -- 'flowJSON' must be defined\")\n\n  invariant(\n    !!cleanedNetwork,\n    `Flow Network Required -- In order for FCL to load your contracts please define \"flow.network\" to \"emulator\", \"local\", \"testnet\", or \"mainnet\" in your config. See more here: https://developers.flow.com/tools/fcl-js/reference/configure-fcl`\n  )\n\n  if (anyHasPrivateKeys(flowJSON)) {\n    const isEmulator = cleanedNetwork === \"emulator\"\n\n    logger.log({\n      title: \"Private Keys Detected\",\n      message: `Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security`,\n      level: isEmulator ? logger.LEVELS.warn : logger.LEVELS.error,\n    })\n\n    invariant(\n      isEmulator,\n      `Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security`\n    )\n  }\n\n  for (const [key, value] of Object.entries(\n    getContracts(flowJSON, cleanedNetwork)\n  )) {\n    const contractConfigKey = `0x${key}`\n    const existingContractConfigKey = await get(contractConfigKey)\n    if (existingContractConfigKey && existingContractConfigKey !== value) {\n      logger.log({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: logger.LEVELS.warn,\n      })\n    } else {\n      put(contractConfigKey, value)\n    }\n\n    const systemContractConfigKey = `system.contracts.${key}`\n    const systemExistingContractConfigKeyValue = await get(\n      systemContractConfigKey\n    )\n    if (\n      systemExistingContractConfigKeyValue &&\n      systemExistingContractConfigKeyValue !== value\n    ) {\n      logger.log({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: logger.LEVELS.warn,\n      })\n    } else {\n      put(systemContractConfigKey, value)\n    }\n  }\n}\n\n/**\n * @description Sets the config\n * @param values - The values to set\n * @returns The config object\n */\nfunction config(values?: Record<string, unknown>) {\n  if (values != null && typeof values === \"object\") {\n    Object.keys(values).map(d => put(d, values[d]))\n  }\n\n  return {\n    put,\n    get,\n    all,\n    first,\n    update,\n    delete: _delete,\n    where,\n    subscribe,\n    overload,\n    load,\n  }\n}\n\nconfig.put = put\nconfig.get = get\nconfig.all = all\nconfig.first = first\nconfig.update = update\nconfig.delete = _delete\nconfig.where = where\nconfig.subscribe = subscribe\nconfig.overload = overload\nconfig.load = load\n\nexport {config}\n\n/**\n * @description Temporarily overloads the config with the given values and calls the callback\n * @param values - The values to overload the config with\n * @param callback - The callback to call with the overloaded config\n * @returns The result of the callback\n */\nasync function overload<T>(\n  values: Record<string, unknown>,\n  callback: (oldConfig: Record<string, unknown>) => T\n) {\n  const oldConfig = await all()\n  try {\n    config(values)\n    const result = await callback(await all())\n    return result\n  } finally {\n    await resetConfig(oldConfig)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}