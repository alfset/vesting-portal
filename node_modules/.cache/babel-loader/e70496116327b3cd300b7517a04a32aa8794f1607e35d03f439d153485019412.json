{"ast":null,"code":"import { useCallback, useEffect, useMemo, useRef } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useActiveWeb3React } from '../../hooks';\nimport { useMulticallContract, useRpcMulticallContract } from '../../hooks/useContract';\nimport useDebounce from '../../hooks/useDebounce';\nimport chunkArray from '../../utils/chunkArray';\nimport { CancelledError, retry, RetryableError } from '../../utils/retry';\nimport { useBlockNumber } from '../application/hooks';\nimport {\n// addUseChainId,\nerrorFetchingMulticallResults, fetchingMulticallResults, parseCallKey, updateMulticallResults } from './actions';\n\n// 块调用，这样我们就不会超过气体限制\nconst CALL_CHUNK_SIZE = 500;\n\n/**\n * 获取一组调用，强制执行最小块数约束\n * @param multicallContract multicall contract to fetch against\n * @param chunk chunk of calls to make\n * @param minBlockNumber minimum block number of the result set\n */\nexport async function fetchChunk(multicallContract, chunk, minBlockNumber) {\n  console.debug('Fetching chunk', multicallContract, chunk, minBlockNumber);\n  let resultsBlockNumber, returnData;\n  // console.log('chunk')\n  // console.log(chunk)\n  try {\n    ;\n    [resultsBlockNumber, returnData] = await multicallContract.aggregate(chunk.map(obj => [obj.address, obj.callData]));\n    // console.log('multicallContract1')\n  } catch (error) {\n    console.debug('Failed to fetch chunk inside retry', error);\n    throw error;\n  }\n  if (resultsBlockNumber.toNumber() < minBlockNumber) {\n    // console.log(`Fetched results for old block number: ${resultsBlockNumber.toString()} vs. ${minBlockNumber}`)\n    // console.debug(`Fetched results for old block number: ${resultsBlockNumber.toString()} vs. ${minBlockNumber}`)\n    throw new RetryableError('Fetched for old block number');\n  }\n  // console.log({ results: returnData, blockNumber: resultsBlockNumber.toNumber() })\n  return {\n    results: returnData,\n    blockNumber: resultsBlockNumber.toNumber()\n  };\n}\n\n/**\n * 获取一组调用，强制执行最小块数约束\n * @param multicallContract multicall contract to fetch against\n * @param chunk chunk of calls to make\n * @param minBlockNumber minimum block number of the result set\n */\nasync function fetchChunk1(multicallContract, chunk, minBlockNumber) {\n  console.debug('Fetching chunk', multicallContract, chunk, minBlockNumber);\n  let resultsBlockNumber, returnData;\n  // console.log(multicallContract)\n  try {\n    // multicallContract.methods.aggregate(chunk.map(obj => [obj.address, obj.callData])).call((err:any, res:any) => {\n    //   console.log(err)\n    //   console.log(res)\n    // })\n    // console.log(await multicallContract.methods.aggregate(chunk.map(obj => [obj.address, obj.callData])).call())\n    const callData = await multicallContract.methods.aggregate(chunk.map(obj => [obj.address, obj.callData])).call();\n    resultsBlockNumber = callData.blockNumber ? Number(callData.blockNumber) : 0;\n    returnData = callData.returnData;\n    // ;[resultsBlockNumber, returnData] = await multicallContract.methods.aggregate(chunk.map(obj => [obj.address, obj.callData])).call()\n  } catch (error) {\n    console.debug('Failed to fetch chunk inside retry', error);\n    throw error;\n  }\n  if (resultsBlockNumber < minBlockNumber) {\n    console.debug(\"Fetched results for old block number: \".concat(resultsBlockNumber.toString(), \" vs. \").concat(minBlockNumber));\n    throw new RetryableError('Fetched for old block number');\n  }\n  // console.log({ results: returnData, blockNumber: resultsBlockNumber })\n  return {\n    results: returnData,\n    blockNumber: resultsBlockNumber\n  };\n}\n\n/**\n * 从当前的所有侦听器状态，返回映射到每次读取的最小块数。这是每个键必须被获取的频率。\n * @param allListeners the all listeners state\n * @param chainId the current chain id\n */\nexport function activeListeningKeys(allListeners, chainId) {\n  if (!allListeners || !chainId) return {};\n  const listeners = allListeners[chainId];\n  if (!listeners) return {};\n  // console.log(listeners)\n  return Object.keys(listeners).reduce((memo, callKey) => {\n    const keyListeners = listeners[callKey];\n    memo[callKey] = Object.keys(keyListeners).filter(key => {\n      const blocksPerFetch = parseInt(key);\n      if (blocksPerFetch <= 0) return false;\n      return keyListeners[blocksPerFetch] > 0;\n    }).reduce((previousMin, current) => {\n      return Math.min(previousMin, parseInt(current));\n    }, Infinity);\n    return memo;\n  }, {});\n}\n\n/**\n * 返回需要重新获取的键\n * @param callResults current call result state\n * @param listeningKeys each call key mapped to how old the data can be in blocks\n * @param chainId the current chain id\n * @param latestBlockNumber the latest block number\n */\nexport function outdatedListeningKeys(callResults, listeningKeys, chainId, latestBlockNumber) {\n  if (!chainId || !latestBlockNumber) return [];\n  const results = callResults[chainId];\n  // no results at all, load everything\n  if (!results) return Object.keys(listeningKeys);\n  return Object.keys(listeningKeys).filter(callKey => {\n    const blocksPerFetch = listeningKeys[callKey];\n    const data = callResults[chainId][callKey];\n    // no data, must fetch\n    if (!data) return true;\n    const minDataBlockNumber = latestBlockNumber - (blocksPerFetch - 1);\n\n    // already fetching it for a recent enough block, don't refetch it\n    if (data.fetchingBlockNumber && data.fetchingBlockNumber >= minDataBlockNumber) return false;\n\n    // if data is older than minDataBlockNumber, fetch it\n    return !data.blockNumber || data.blockNumber < minDataBlockNumber;\n  });\n}\nexport default function Updater(_ref) {\n  let {\n    type\n  } = _ref;\n  const dispatch = useDispatch();\n  const state = useSelector(state => state.multicall);\n  // wait for listeners to settle before triggering updates\n  const debouncedListeners = useDebounce(state.callListeners, 100);\n  const {\n    chainId\n  } = useActiveWeb3React();\n  // const useChainId = state.useChainId ? state.useChainId : chainId\n  const useChainId = type ? state.useChainId : chainId;\n  const latestBlockNumber = useBlockNumber(useChainId);\n  const multicallContract = useMulticallContract();\n  const multicallContract1 = useRpcMulticallContract(useChainId);\n\n  // console.log(type)\n  // console.log(useChainId)\n  // console.log(latestBlockNumber)\n  // console.log(chainId)\n  // console.log(state)\n  const cancellations = useRef();\n  // console.log(multicallContract1)\n  // console.log(multicallContract)\n  const listeningKeys = useMemo(() => {\n    return activeListeningKeys(debouncedListeners, useChainId);\n  }, [debouncedListeners, useChainId]);\n  const unserializedOutdatedCallKeys = useMemo(() => {\n    return outdatedListeningKeys(state.callResults, listeningKeys, useChainId, latestBlockNumber);\n  }, [useChainId, state.callResults, listeningKeys, latestBlockNumber]);\n  const serializedOutdatedCallKeys = useMemo(() => JSON.stringify(unserializedOutdatedCallKeys.sort()), [unserializedOutdatedCallKeys]);\n  const updateResults = useCallback(() => {\n    var _cancellations$curren;\n    // console.log('latestBlockNumber', latestBlockNumber)\n    // console.log('useChainId', useChainId)\n    // console.log('multicallContract', multicallContract)\n    if (!latestBlockNumber || !useChainId || !multicallContract) return;\n\n    // console.log(useChainId, 1)\n    const outdatedCallKeys = JSON.parse(serializedOutdatedCallKeys);\n    // console.log(outdatedCallKeys)\n    if (outdatedCallKeys.length === 0) return;\n    const calls = outdatedCallKeys.map(key => parseCallKey(key));\n    // console.log(useChainId, 2)\n    const chunkedCalls = chunkArray(calls, CALL_CHUNK_SIZE);\n    if (((_cancellations$curren = cancellations.current) === null || _cancellations$curren === void 0 ? void 0 : _cancellations$curren.blockNumber) !== latestBlockNumber) {\n      var _cancellations$curren2, _cancellations$curren3;\n      (_cancellations$curren2 = cancellations.current) === null || _cancellations$curren2 === void 0 ? void 0 : (_cancellations$curren3 = _cancellations$curren2.cancellations) === null || _cancellations$curren3 === void 0 ? void 0 : _cancellations$curren3.forEach(c => c());\n    }\n    // console.log(calls)\n    dispatch(fetchingMulticallResults({\n      calls,\n      chainId: useChainId,\n      fetchingBlockNumber: latestBlockNumber\n    }));\n    // console.log(useChainId, 3)\n    cancellations.current = {\n      blockNumber: latestBlockNumber,\n      cancellations: chunkedCalls.map((chunk, index) => {\n        // console.log(chunkedCalls)\n        // console.log(chunk)\n        // if (index > 10) return () => {console.log()}\n        const {\n          cancel,\n          promise\n        } = retry(() => chainId && useChainId && Number(useChainId) !== Number(chainId) ? fetchChunk1(multicallContract1, chunk, latestBlockNumber) : fetchChunk(multicallContract, chunk, latestBlockNumber), {\n          n: Infinity,\n          minWait: 2500,\n          maxWait: 3500\n        });\n        promise.then(_ref2 => {\n          let {\n            results: returnData,\n            blockNumber: fetchBlockNumber\n          } = _ref2;\n          cancellations.current = {\n            cancellations: [],\n            blockNumber: latestBlockNumber\n          };\n          // console.log(returnData)\n          // accumulates the length of all previous indices\n          const firstCallKeyIndex = chunkedCalls.slice(0, index).reduce((memo, curr) => memo + curr.length, 0);\n          const lastCallKeyIndex = firstCallKeyIndex + returnData.length;\n          // dispatch(addUseChainId({ chainId: chainId }))\n          dispatch(updateMulticallResults({\n            chainId: useChainId,\n            results: outdatedCallKeys.slice(firstCallKeyIndex, lastCallKeyIndex).reduce((memo, callKey, i) => {\n              var _returnData$i;\n              memo[callKey] = (_returnData$i = returnData[i]) !== null && _returnData$i !== void 0 ? _returnData$i : null;\n              return memo;\n            }, {}),\n            blockNumber: fetchBlockNumber\n          }));\n        }).catch(error => {\n          if (error instanceof CancelledError) {\n            console.debug('Cancelled fetch for blockNumber', latestBlockNumber);\n            return;\n          }\n          console.error('Failed to fetch multicall chunk', chunk, useChainId, error);\n          dispatch(errorFetchingMulticallResults({\n            calls: chunk,\n            chainId: useChainId,\n            fetchingBlockNumber: latestBlockNumber\n          }));\n        });\n        return cancel;\n      })\n    };\n  }, [useChainId, multicallContract, dispatch, serializedOutdatedCallKeys, latestBlockNumber]);\n  // console.log(listeningKeys)\n  // console.log(serializedOutdatedCallKeys)\n  // useEffect(() => {\n  //   updateResults()\n  // }, [])\n  useEffect(() => {\n    updateResults();\n  }, [useChainId, multicallContract, dispatch, serializedOutdatedCallKeys, latestBlockNumber]);\n  return null;\n}","map":{"version":3,"names":["useCallback","useEffect","useMemo","useRef","useDispatch","useSelector","useActiveWeb3React","useMulticallContract","useRpcMulticallContract","useDebounce","chunkArray","CancelledError","retry","RetryableError","useBlockNumber","errorFetchingMulticallResults","fetchingMulticallResults","parseCallKey","updateMulticallResults","CALL_CHUNK_SIZE","fetchChunk","multicallContract","chunk","minBlockNumber","console","debug","resultsBlockNumber","returnData","aggregate","map","obj","address","callData","error","toNumber","results","blockNumber","fetchChunk1","methods","call","Number","concat","toString","activeListeningKeys","allListeners","chainId","listeners","Object","keys","reduce","memo","callKey","keyListeners","filter","key","blocksPerFetch","parseInt","previousMin","current","Math","min","Infinity","outdatedListeningKeys","callResults","listeningKeys","latestBlockNumber","data","minDataBlockNumber","fetchingBlockNumber","Updater","_ref","type","dispatch","state","multicall","debouncedListeners","callListeners","useChainId","multicallContract1","cancellations","unserializedOutdatedCallKeys","serializedOutdatedCallKeys","JSON","stringify","sort","updateResults","_cancellations$curren","outdatedCallKeys","parse","length","calls","chunkedCalls","_cancellations$curren2","_cancellations$curren3","forEach","c","index","cancel","promise","n","minWait","maxWait","then","_ref2","fetchBlockNumber","firstCallKeyIndex","slice","curr","lastCallKeyIndex","i","_returnData$i","catch"],"sources":["/workspace/Planq-Dapps/vesting-portal/src/state/multicall/updater.tsx"],"sourcesContent":["import { Contract } from '@ethersproject/contracts'\nimport { useCallback, useEffect, useMemo, useRef } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { useActiveWeb3React } from '../../hooks'\nimport { useMulticallContract, useRpcMulticallContract } from '../../hooks/useContract'\nimport useDebounce from '../../hooks/useDebounce'\nimport chunkArray from '../../utils/chunkArray'\nimport { CancelledError, retry, RetryableError } from '../../utils/retry'\nimport { useBlockNumber } from '../application/hooks'\nimport { AppDispatch, AppState } from '../index'\nimport {\n  Call,\n  // addUseChainId,\n  errorFetchingMulticallResults,\n  fetchingMulticallResults,\n  parseCallKey,\n  updateMulticallResults\n} from './actions'\n\n// 块调用，这样我们就不会超过气体限制\nconst CALL_CHUNK_SIZE = 500\n\n/**\n * 获取一组调用，强制执行最小块数约束\n * @param multicallContract multicall contract to fetch against\n * @param chunk chunk of calls to make\n * @param minBlockNumber minimum block number of the result set\n */\nexport async function fetchChunk(\n  multicallContract: Contract,\n  chunk: Call[],\n  minBlockNumber: number\n): Promise<{ results: string[]; blockNumber: number }> {\n  console.debug('Fetching chunk', multicallContract, chunk, minBlockNumber)\n  let resultsBlockNumber, returnData\n  // console.log('chunk')\n  // console.log(chunk)\n  try {\n    ;[resultsBlockNumber, returnData] = await multicallContract.aggregate(chunk.map(obj => [obj.address, obj.callData]))\n    // console.log('multicallContract1')\n  } catch (error) {\n    console.debug('Failed to fetch chunk inside retry', error)\n    throw error\n  }\n  if (resultsBlockNumber.toNumber() < minBlockNumber) {\n    // console.log(`Fetched results for old block number: ${resultsBlockNumber.toString()} vs. ${minBlockNumber}`)\n    // console.debug(`Fetched results for old block number: ${resultsBlockNumber.toString()} vs. ${minBlockNumber}`)\n    throw new RetryableError('Fetched for old block number')\n  }\n  // console.log({ results: returnData, blockNumber: resultsBlockNumber.toNumber() })\n  return { results: returnData, blockNumber: resultsBlockNumber.toNumber() }\n}\n\n/**\n * 获取一组调用，强制执行最小块数约束\n * @param multicallContract multicall contract to fetch against\n * @param chunk chunk of calls to make\n * @param minBlockNumber minimum block number of the result set\n */\n async function fetchChunk1(\n  multicallContract: any,\n  chunk: Call[],\n  minBlockNumber: number\n): Promise<{ results: string[]; blockNumber: number }> {\n  console.debug('Fetching chunk', multicallContract, chunk, minBlockNumber)\n  let resultsBlockNumber, returnData\n  // console.log(multicallContract)\n  try {\n    // multicallContract.methods.aggregate(chunk.map(obj => [obj.address, obj.callData])).call((err:any, res:any) => {\n    //   console.log(err)\n    //   console.log(res)\n    // })\n    // console.log(await multicallContract.methods.aggregate(chunk.map(obj => [obj.address, obj.callData])).call())\n    const callData = await multicallContract.methods.aggregate(chunk.map(obj => [obj.address, obj.callData])).call()\n    resultsBlockNumber = callData.blockNumber ? Number(callData.blockNumber) : 0\n    returnData = callData.returnData\n    // ;[resultsBlockNumber, returnData] = await multicallContract.methods.aggregate(chunk.map(obj => [obj.address, obj.callData])).call()\n  } catch (error) {\n    console.debug('Failed to fetch chunk inside retry', error)\n    throw error\n  }\n  if (resultsBlockNumber < minBlockNumber) {\n    console.debug(`Fetched results for old block number: ${resultsBlockNumber.toString()} vs. ${minBlockNumber}`)\n    throw new RetryableError('Fetched for old block number')\n  }\n  // console.log({ results: returnData, blockNumber: resultsBlockNumber })\n  return { results: returnData, blockNumber: resultsBlockNumber }\n}\n\n/**\n * 从当前的所有侦听器状态，返回映射到每次读取的最小块数。这是每个键必须被获取的频率。\n * @param allListeners the all listeners state\n * @param chainId the current chain id\n */\nexport function activeListeningKeys(\n  allListeners: AppState['multicall']['callListeners'],\n  chainId?: number\n): { [callKey: string]: number } {\n  if (!allListeners || !chainId) return {}\n  const listeners = allListeners[chainId]\n  if (!listeners) return {}\n  // console.log(listeners)\n  return Object.keys(listeners).reduce<{ [callKey: string]: number }>((memo, callKey) => {\n    const keyListeners = listeners[callKey]\n\n    memo[callKey] = Object.keys(keyListeners)\n      .filter(key => {\n        const blocksPerFetch = parseInt(key)\n        if (blocksPerFetch <= 0) return false\n        return keyListeners[blocksPerFetch] > 0\n      })\n      .reduce((previousMin, current) => {\n        return Math.min(previousMin, parseInt(current))\n      }, Infinity)\n    return memo\n  }, {})\n}\n\n/**\n * 返回需要重新获取的键\n * @param callResults current call result state\n * @param listeningKeys each call key mapped to how old the data can be in blocks\n * @param chainId the current chain id\n * @param latestBlockNumber the latest block number\n */\nexport function outdatedListeningKeys(\n  callResults: AppState['multicall']['callResults'],\n  listeningKeys: { [callKey: string]: number },\n  chainId: number | undefined,\n  latestBlockNumber: number | undefined\n): string[] {\n  if (!chainId || !latestBlockNumber) return []\n  const results = callResults[chainId]\n  // no results at all, load everything\n  if (!results) return Object.keys(listeningKeys)\n\n  return Object.keys(listeningKeys).filter(callKey => {\n    const blocksPerFetch = listeningKeys[callKey]\n\n    const data = callResults[chainId][callKey]\n    // no data, must fetch\n    if (!data) return true\n\n    const minDataBlockNumber = latestBlockNumber - (blocksPerFetch - 1)\n\n    // already fetching it for a recent enough block, don't refetch it\n    if (data.fetchingBlockNumber && data.fetchingBlockNumber >= minDataBlockNumber) return false\n\n    // if data is older than minDataBlockNumber, fetch it\n    return !data.blockNumber || data.blockNumber < minDataBlockNumber\n  })\n}\n\nexport default function Updater({type}: {type?:number}): null {\n  const dispatch = useDispatch<AppDispatch>()\n  const state = useSelector<AppState, AppState['multicall']>(state => state.multicall)\n  // wait for listeners to settle before triggering updates\n  const debouncedListeners = useDebounce(state.callListeners, 100)\n  const { chainId } = useActiveWeb3React()\n  // const useChainId = state.useChainId ? state.useChainId : chainId\n  const useChainId = type ? state.useChainId : chainId\n  const latestBlockNumber = useBlockNumber(useChainId)\n  const multicallContract = useMulticallContract()\n  const multicallContract1 = useRpcMulticallContract(useChainId)\n\n  // console.log(type)\n  // console.log(useChainId)\n  // console.log(latestBlockNumber)\n  // console.log(chainId)\n  // console.log(state)\n  const cancellations = useRef<{ blockNumber: number; cancellations: (() => void)[] }>()\n  // console.log(multicallContract1)\n  // console.log(multicallContract)\n  const listeningKeys: { [callKey: string]: number } = useMemo(() => {\n    return activeListeningKeys(debouncedListeners, useChainId)\n  }, [debouncedListeners, useChainId])\n\n  const unserializedOutdatedCallKeys = useMemo(() => {\n    return outdatedListeningKeys(state.callResults, listeningKeys, useChainId, latestBlockNumber)\n  }, [useChainId, state.callResults, listeningKeys, latestBlockNumber])\n\n  const serializedOutdatedCallKeys = useMemo(() => JSON.stringify(unserializedOutdatedCallKeys.sort()), [\n    unserializedOutdatedCallKeys\n  ])\n\n  const updateResults = useCallback(() => {\n    // console.log('latestBlockNumber', latestBlockNumber)\n    // console.log('useChainId', useChainId)\n    // console.log('multicallContract', multicallContract)\n    if (!latestBlockNumber || !useChainId || !multicallContract) return\n    \n    // console.log(useChainId, 1)\n    const outdatedCallKeys: string[] = JSON.parse(serializedOutdatedCallKeys)\n    // console.log(outdatedCallKeys)\n    if (outdatedCallKeys.length === 0) return\n    const calls = outdatedCallKeys.map(key => parseCallKey(key))\n    // console.log(useChainId, 2)\n    const chunkedCalls = chunkArray(calls, CALL_CHUNK_SIZE)\n\n    if (cancellations.current?.blockNumber !== latestBlockNumber) {\n      cancellations.current?.cancellations?.forEach(c => c())\n    }\n    // console.log(calls)\n    dispatch(\n      fetchingMulticallResults({\n        calls,\n        chainId: useChainId,\n        fetchingBlockNumber: latestBlockNumber\n      })\n    )\n    // console.log(useChainId, 3)\n    cancellations.current = {\n      blockNumber: latestBlockNumber,\n      cancellations: chunkedCalls.map((chunk, index) => {\n        // console.log(chunkedCalls)\n        // console.log(chunk)\n        // if (index > 10) return () => {console.log()}\n        const { cancel, promise } = retry(() => chainId && useChainId && Number(useChainId) !== Number(chainId) ? fetchChunk1(multicallContract1, chunk, latestBlockNumber) : fetchChunk(multicallContract, chunk, latestBlockNumber), {\n          n: Infinity,\n          minWait: 2500,\n          maxWait: 3500\n        })\n        \n        promise\n          .then(({ results: returnData, blockNumber: fetchBlockNumber }) => {\n            cancellations.current = { cancellations: [], blockNumber: latestBlockNumber }\n            // console.log(returnData)\n            // accumulates the length of all previous indices\n            const firstCallKeyIndex = chunkedCalls.slice(0, index).reduce<number>((memo, curr) => memo + curr.length, 0)\n            const lastCallKeyIndex = firstCallKeyIndex + returnData.length\n            // dispatch(addUseChainId({ chainId: chainId }))\n            dispatch(\n              updateMulticallResults({\n                chainId: useChainId,\n                results: outdatedCallKeys\n                  .slice(firstCallKeyIndex, lastCallKeyIndex)\n                  .reduce<{ [callKey: string]: string | null }>((memo, callKey, i) => {\n                    memo[callKey] = returnData[i] ?? null\n                    return memo\n                  }, {}),\n                blockNumber: fetchBlockNumber\n              })\n            )\n          })\n          .catch((error: any) => {\n            if (error instanceof CancelledError) {\n              console.debug('Cancelled fetch for blockNumber', latestBlockNumber)\n              return\n            }\n            console.error('Failed to fetch multicall chunk', chunk, useChainId, error)\n            dispatch(\n              errorFetchingMulticallResults({\n                calls: chunk,\n                chainId: useChainId,\n                fetchingBlockNumber: latestBlockNumber\n              })\n            )\n          })\n        return cancel\n      })\n    }\n  }, [useChainId, multicallContract, dispatch, serializedOutdatedCallKeys, latestBlockNumber])\n  // console.log(listeningKeys)\n  // console.log(serializedOutdatedCallKeys)\n  // useEffect(() => {\n  //   updateResults()\n  // }, [])\n  useEffect(() => {\n    updateResults()\n  }, [useChainId, multicallContract, dispatch, serializedOutdatedCallKeys, latestBlockNumber])\n\n  return null\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}