{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\nvar Transform = require('stream').Transform;\nvar inherits = require('inherits');\nmodule.exports = function (KeccakState) {\n  function Keccak(rate, capacity, delimitedSuffix, hashBitLength, options) {\n    Transform.call(this, options);\n    this._rate = rate;\n    this._capacity = capacity;\n    this._delimitedSuffix = delimitedSuffix;\n    this._hashBitLength = hashBitLength;\n    this._options = options;\n    this._state = new KeccakState();\n    this._state.initialize(rate, capacity);\n    this._finalized = false;\n  }\n  inherits(Keccak, Transform);\n  Keccak.prototype._transform = function (chunk, encoding, callback) {\n    var error = null;\n    try {\n      this.update(chunk, encoding);\n    } catch (err) {\n      error = err;\n    }\n    callback(error);\n  };\n  Keccak.prototype._flush = function (callback) {\n    var error = null;\n    try {\n      this.push(this.digest());\n    } catch (err) {\n      error = err;\n    }\n    callback(error);\n  };\n  Keccak.prototype.update = function (data, encoding) {\n    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer');\n    if (this._finalized) throw new Error('Digest already called');\n    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding);\n    this._state.absorb(data);\n    return this;\n  };\n  Keccak.prototype.digest = function (encoding) {\n    if (this._finalized) throw new Error('Digest already called');\n    this._finalized = true;\n    if (this._delimitedSuffix) this._state.absorbLastFewBits(this._delimitedSuffix);\n    var digest = this._state.squeeze(this._hashBitLength / 8);\n    if (encoding !== undefined) digest = digest.toString(encoding);\n    this._resetState();\n    return digest;\n  };\n\n  // remove result from memory\n  Keccak.prototype._resetState = function () {\n    this._state.initialize(this._rate, this._capacity);\n    return this;\n  };\n\n  // because sometimes we need hash right now and little later\n  Keccak.prototype._clone = function () {\n    var clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);\n    this._state.copy(clone._state);\n    clone._finalized = this._finalized;\n    return clone;\n  };\n  return Keccak;\n};","map":{"version":3,"names":["Buffer","require","Transform","inherits","module","exports","KeccakState","Keccak","rate","capacity","delimitedSuffix","hashBitLength","options","call","_rate","_capacity","_delimitedSuffix","_hashBitLength","_options","_state","initialize","_finalized","prototype","_transform","chunk","encoding","callback","error","update","err","_flush","push","digest","data","isBuffer","TypeError","Error","from","absorb","absorbLastFewBits","squeeze","undefined","toString","_resetState","_clone","clone","copy"],"sources":["/workspace/Planq-Dapps/vesting-portal/node_modules/nebulas/node_modules/keccak/lib/api/keccak.js"],"sourcesContent":["'use strict'\nvar Buffer = require('safe-buffer').Buffer\nvar Transform = require('stream').Transform\nvar inherits = require('inherits')\n\nmodule.exports = function (KeccakState) {\n  function Keccak (rate, capacity, delimitedSuffix, hashBitLength, options) {\n    Transform.call(this, options)\n\n    this._rate = rate\n    this._capacity = capacity\n    this._delimitedSuffix = delimitedSuffix\n    this._hashBitLength = hashBitLength\n    this._options = options\n\n    this._state = new KeccakState()\n    this._state.initialize(rate, capacity)\n    this._finalized = false\n  }\n\n  inherits(Keccak, Transform)\n\n  Keccak.prototype._transform = function (chunk, encoding, callback) {\n    var error = null\n    try {\n      this.update(chunk, encoding)\n    } catch (err) {\n      error = err\n    }\n\n    callback(error)\n  }\n\n  Keccak.prototype._flush = function (callback) {\n    var error = null\n    try {\n      this.push(this.digest())\n    } catch (err) {\n      error = err\n    }\n\n    callback(error)\n  }\n\n  Keccak.prototype.update = function (data, encoding) {\n    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')\n    if (this._finalized) throw new Error('Digest already called')\n    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)\n\n    this._state.absorb(data)\n\n    return this\n  }\n\n  Keccak.prototype.digest = function (encoding) {\n    if (this._finalized) throw new Error('Digest already called')\n    this._finalized = true\n\n    if (this._delimitedSuffix) this._state.absorbLastFewBits(this._delimitedSuffix)\n    var digest = this._state.squeeze(this._hashBitLength / 8)\n    if (encoding !== undefined) digest = digest.toString(encoding)\n\n    this._resetState()\n\n    return digest\n  }\n\n  // remove result from memory\n  Keccak.prototype._resetState = function () {\n    this._state.initialize(this._rate, this._capacity)\n    return this\n  }\n\n  // because sometimes we need hash right now and little later\n  Keccak.prototype._clone = function () {\n    var clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options)\n    this._state.copy(clone._state)\n    clone._finalized = this._finalized\n\n    return clone\n  }\n\n  return Keccak\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}