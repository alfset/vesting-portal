{"ast":null,"code":"import { isDesktopChrome } from '@terra-dev/browser-check';\nimport { getTerraChromeExtensions } from '@terra-dev/chrome-extension';\nimport { readonlyWalletModal } from '@terra-dev/readonly-wallet-modal';\nimport { ConnectType, WalletStatus } from '@terra-dev/use-wallet';\nimport { CreateTxFailed, Timeout, TxFailed, TxUnspecifiedError, UserDenied } from '@terra-dev/wallet-types';\nimport { WebConnectorController } from '@terra-dev/web-connector-controller';\nimport { WebConnectorCreateTxFailed, WebConnectorStatusType, WebConnectorTxFailed, WebConnectorTxStatus, WebConnectorUserDenied } from '@terra-dev/web-connector-interface';\nimport { AccAddress } from '@terra-money/terra.js';\nimport deepEqual from 'fast-deep-equal';\nimport { BehaviorSubject, combineLatest } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\nimport { CHROME_EXTENSION_INSTALL_URL, DEFAULT_CHROME_EXTENSION_COMPATIBLE_BROWSER_CHECK, WEB_EXTENSION_CONNECTED_KEY } from './env';\nimport { ChromeExtensionController, ChromeExtensionCreateTxFailed, ChromeExtensionStatus, ChromeExtensionTxFailed, ChromeExtensionUnspecifiedError } from './modules/chrome-extension';\nimport { connect as reConnect, connectIfSessionExists as reConnectIfSessionExists } from './modules/readonly-wallet';\nimport { connect as wcConnect, connectIfSessionExists as wcConnectIfSessionExists, WalletConnectCreateTxFailed, WalletConnectSessionStatus, WalletConnectTimeout, WalletConnectTxFailed, WalletConnectTxUnspecifiedError, WalletConnectUserDenied } from './modules/walletconnect';\nimport { checkAvailableExtension } from './utils/checkAvailableExtension';\nconst CONNECTIONS = {\n  [ConnectType.READONLY]: {\n    type: ConnectType.READONLY,\n    name: 'View an address',\n    icon: 'https://assets.terra.money/icon/station-extension/icon.png'\n  },\n  [ConnectType.WALLETCONNECT]: {\n    type: ConnectType.WALLETCONNECT,\n    name: 'Terra Station Mobile',\n    icon: 'https://assets.terra.money/icon/station-extension/icon.png'\n  },\n  [ConnectType.WEB_CONNECT]: {\n    type: ConnectType.WEB_CONNECT,\n    name: 'Terra Station',\n    icon: 'https://assets.terra.money/icon/station-extension/icon.png'\n  }\n};\nconst defaultWaitingChromeExtensionInstallCheck = 1000 * 3;\nexport class WalletController {\n  constructor(options) {\n    var _this = this;\n    var _a;\n    this.options = options;\n    this.chromeExtension = null;\n    this.webConnector = null;\n    this.walletConnect = null;\n    this.readonlyWallet = null;\n    this.disableReadonlyWallet = null;\n    this.disableChromeExtension = null;\n    this.disableWebExtension = null;\n    this.disableWalletConnect = null;\n    /** @see Wallet#isChromeExtensionCompatibleBrowser */\n    this.isChromeExtensionCompatibleBrowser = () => {\n      var _a;\n      return ((_a = this.options.dangerously__chromeExtensionCompatibleBrowserCheck) !== null && _a !== void 0 ? _a : DEFAULT_CHROME_EXTENSION_COMPATIBLE_BROWSER_CHECK)(navigator.userAgent);\n    };\n    /** @see Wallet#availableConnectTypes */\n    this.availableConnectTypes = () => {\n      return this._availableConnectTypes.asObservable();\n    };\n    /** @see Wallet#availableConnections */\n    this.availableConnections = () => {\n      return this._availableConnectTypes.pipe(map(connectTypes => {\n        const connections = [];\n        for (const connectType of connectTypes) {\n          if (connectType === ConnectType.CHROME_EXTENSION) {\n            const terraExtensions = getTerraChromeExtensions();\n            for (const terraExtension of terraExtensions) {\n              connections.push({\n                type: ConnectType.CHROME_EXTENSION,\n                ...terraExtension\n              });\n            }\n          } else {\n            connections.push(CONNECTIONS[connectType]);\n          }\n        }\n        return connections;\n      }));\n    };\n    /** @see Wallet#availableInstallTypes */\n    this.availableInstallTypes = () => {\n      return this._availableInstallTypes.asObservable();\n    };\n    /**\n     * @see Wallet#status\n     * @see Wallet#network\n     * @see Wallet#wallets\n     */\n    this.states = () => {\n      return this._states.asObservable();\n    };\n    /** @deprecated please use `states()` */\n    this.status = () => {\n      return this._states.pipe(map(data => data.status));\n    };\n    /** @deprecated please use `states()` */\n    this.network = () => {\n      return this._states.pipe(map(data => data.network));\n    };\n    /** @deprecated please use `states()` */\n    this.wallets = () => {\n      return this._states.pipe(map(data => data.status === WalletStatus.WALLET_CONNECTED ? data.wallets : []));\n    };\n    /** @see Wallet#recheckStatus */\n    this.recheckStatus = () => {\n      var _a;\n      if (this.disableChromeExtension) {\n        (_a = this.chromeExtension) === null || _a === void 0 ? void 0 : _a.recheckStatus();\n      }\n    };\n    /** @see Wallet#install */\n    this.install = type => {\n      var _a;\n      if (type === ConnectType.CHROME_EXTENSION) {\n        window.open(CHROME_EXTENSION_INSTALL_URL, '_blank');\n      } else if (type === ConnectType.WEB_CONNECT) {\n        const webExtensionStatus = (_a = this.webConnector) === null || _a === void 0 ? void 0 : _a.getLastStatus();\n        if ((webExtensionStatus === null || webExtensionStatus === void 0 ? void 0 : webExtensionStatus.type) === WebConnectorStatusType.NO_AVAILABLE && webExtensionStatus.installLink) {\n          window.open(webExtensionStatus.installLink, '_blank');\n        }\n      } else {\n        console.warn(\"ConnectType \\\"\".concat(type, \"\\\" does not support install() function\"));\n      }\n    };\n    /** @see Wallet#connect */\n    this.connect = (type, identifier) => {\n      var _a, _b, _c;\n      switch (type) {\n        case ConnectType.READONLY:\n          const networks = Object.keys(this.options.walletConnectChainIds).map(chainId => this.options.walletConnectChainIds[+chainId]);\n          const createReadonlyWalletSession = (_c = (_b = (_a = this.options).createReadonlyWalletSession) === null || _b === void 0 ? void 0 : _b.call(_a, networks)) !== null && _c !== void 0 ? _c : readonlyWalletModal({\n            networks\n          });\n          createReadonlyWalletSession.then(readonlyWalletSession => {\n            if (readonlyWalletSession) {\n              this.enableReadonlyWallet(reConnect(readonlyWalletSession));\n            }\n          });\n          break;\n        case ConnectType.WALLETCONNECT:\n          this.enableWalletConnect(wcConnect(this.options));\n          break;\n        case ConnectType.CHROME_EXTENSION:\n          this.chromeExtension.connect(identifier).then(success => {\n            if (success) {\n              this.enableChromeExtension();\n            }\n          });\n          break;\n        case ConnectType.WEB_CONNECT:\n          this.enableWebExtension();\n          break;\n        default:\n          throw new Error(\"Unknown ConnectType!\");\n      }\n    };\n    /** @see Wallet#connectReadonly */\n    this.connectReadonly = (terraAddress, network) => {\n      this.enableReadonlyWallet(reConnect({\n        terraAddress,\n        network\n      }));\n    };\n    /** @see Wallet#disconnect */\n    this.disconnect = () => {\n      var _a, _b, _c, _d;\n      (_a = this.disableReadonlyWallet) === null || _a === void 0 ? void 0 : _a.call(this);\n      this.disableReadonlyWallet = null;\n      (_b = this.disableChromeExtension) === null || _b === void 0 ? void 0 : _b.call(this);\n      this.disableChromeExtension = null;\n      (_c = this.disableWebExtension) === null || _c === void 0 ? void 0 : _c.call(this);\n      this.disableWebExtension = null;\n      (_d = this.disableWalletConnect) === null || _d === void 0 ? void 0 : _d.call(this);\n      this.disableWalletConnect = null;\n      localStorage.removeItem(WEB_EXTENSION_CONNECTED_KEY);\n      this.updateStates(this._notConnected);\n    };\n    /** @see Wallet#post */\n    this.post = async function (tx) {\n      let txTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // ---------------------------------------------\n      // chrome extension - legacy extension\n      // ---------------------------------------------\n      if (_this.disableChromeExtension) {\n        if (!_this.chromeExtension) {\n          throw new Error(\"chromeExtension instance not created!\");\n        }\n        return _this.chromeExtension\n        // TODO make WalletConnectTxResult to common type\n        .post(tx).then(_ref => {\n          let {\n            payload\n          } = _ref;\n          return {\n            ...tx,\n            result: payload.result,\n            success: true\n          };\n        }).catch(error => {\n          if (error instanceof ChromeExtensionCreateTxFailed) {\n            throw new CreateTxFailed(tx, error.message);\n          } else if (error instanceof ChromeExtensionTxFailed) {\n            throw new TxFailed(tx, error.txhash, error.message, null);\n          } else if (error instanceof ChromeExtensionUnspecifiedError) {\n            throw new TxUnspecifiedError(tx, error.message);\n          }\n          // UserDeniedError\n          // All unspecified errors...\n          throw error;\n        });\n      }\n      // ---------------------------------------------\n      // web extension - new extension\n      // ---------------------------------------------\n      else if (_this.disableWebExtension) {\n        return new Promise((resolve, reject) => {\n          var _a, _b;\n          if (!_this.webConnector) {\n            reject(new Error(\"webExtension instance not created!\"));\n            return;\n          }\n          const webExtensionStates = _this.webConnector.getLastStates();\n          if (!webExtensionStates) {\n            reject(new Error(\"webExtension.getLastStates() returns undefined!\"));\n            return;\n          }\n          const focusedWallet = txTarget.terraAddress ? (_a = webExtensionStates.wallets.find(itemWallet => itemWallet.terraAddress === txTarget.terraAddress)) !== null && _a !== void 0 ? _a : webExtensionStates.wallets[0] : webExtensionStates.focusedWalletAddress ? (_b = webExtensionStates.wallets.find(itemWallet => itemWallet.terraAddress === webExtensionStates.focusedWalletAddress)) !== null && _b !== void 0 ? _b : webExtensionStates.wallets[0] : webExtensionStates.wallets[0];\n          const subscription = _this.webConnector.post(focusedWallet.terraAddress, tx).subscribe({\n            next: extensionTxResult => {\n              switch (extensionTxResult.status) {\n                case WebConnectorTxStatus.SUCCEED:\n                  resolve({\n                    ...tx,\n                    result: extensionTxResult.payload,\n                    success: true\n                  });\n                  subscription.unsubscribe();\n                  break;\n              }\n            },\n            error: error => {\n              if (error instanceof WebConnectorUserDenied) {\n                reject(new UserDenied());\n              } else if (error instanceof WebConnectorCreateTxFailed) {\n                reject(new CreateTxFailed(tx, error.message));\n              } else if (error instanceof WebConnectorTxFailed) {\n                reject(new TxFailed(tx, error.txhash, error.message, error.raw_message));\n              } else {\n                reject(new TxUnspecifiedError(tx, 'message' in error ? error.message : String(error)));\n              }\n              subscription.unsubscribe();\n            }\n          });\n        });\n      }\n      // ---------------------------------------------\n      // wallet connect\n      // ---------------------------------------------\n      else if (_this.walletConnect) {\n        return _this.walletConnect.post(tx).then(result => ({\n          ...tx,\n          result,\n          success: true\n        })).catch(error => {\n          let throwError = error;\n          try {\n            if (error instanceof WalletConnectUserDenied) {\n              throwError = new UserDenied();\n            } else if (error instanceof WalletConnectCreateTxFailed) {\n              throwError = new CreateTxFailed(tx, error.message);\n            } else if (error instanceof WalletConnectTxFailed) {\n              throwError = new TxFailed(tx, error.txhash, error.message, error.raw_message);\n            } else if (error instanceof WalletConnectTimeout) {\n              throwError = new Timeout(error.message);\n            } else if (error instanceof WalletConnectTxUnspecifiedError) {\n              throwError = new TxUnspecifiedError(tx, error.message);\n            }\n          } catch (_a) {\n            throwError = new TxUnspecifiedError(tx, 'message' in error ? error.message : String(error));\n          }\n          throw throwError;\n        });\n      } else {\n        throw new Error(\"There are no connections that can be posting tx!\");\n      }\n    };\n    /** @see Wallet#sign */\n    this.sign = async function (tx) {\n      let txTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (_this.disableChromeExtension) {\n        if (!_this.chromeExtension) {\n          throw new Error(\"chromeExtension instance not created!\");\n        }\n        return _this.chromeExtension.sign(tx).then(_ref2 => {\n          let {\n            payload\n          } = _ref2;\n          const publicKey = typeof payload.result.public_key === 'string' ? {\n            type: 'tendermint/PubKeySecp256k1',\n            value: payload.result.public_key\n          } : payload.result.public_key;\n          const signResult = {\n            ...payload.result,\n            public_key: publicKey\n          };\n          return {\n            ...tx,\n            result: signResult,\n            success: true\n          };\n        }).catch(error => {\n          if (error instanceof ChromeExtensionCreateTxFailed) {\n            throw new CreateTxFailed(tx, error.message);\n          } else if (error instanceof ChromeExtensionTxFailed) {\n            throw new TxFailed(tx, error.txhash, error.message, null);\n          } else if (error instanceof ChromeExtensionUnspecifiedError) {\n            throw new TxUnspecifiedError(tx, error.message);\n          }\n          // UserDenied - chrome extension will sent original UserDenied error type\n          // All unspecified errors...\n          throw error;\n        });\n      }\n      throw new Error(\"sign() method only available on chrome extension\");\n      // TODO implements sign() to other connect types\n    };\n    // ================================================================\n    // internal\n    // connect type changing\n    // ================================================================\n    this.updateStates = next => {\n      const prev = this._states.getValue();\n      if (next.status === WalletStatus.WALLET_CONNECTED && next.wallets.length === 0) {\n        console.trace('???');\n      }\n      if (prev.status !== next.status || !deepEqual(prev, next)) {\n        this._states.next(next);\n      }\n    };\n    this.enableReadonlyWallet = readonlyWallet => {\n      var _a, _b, _c, _d;\n      (_a = this.disableWalletConnect) === null || _a === void 0 ? void 0 : _a.call(this);\n      (_b = this.disableChromeExtension) === null || _b === void 0 ? void 0 : _b.call(this);\n      (_c = this.disableWebExtension) === null || _c === void 0 ? void 0 : _c.call(this);\n      if (this.readonlyWallet === readonlyWallet || ((_d = this.readonlyWallet) === null || _d === void 0 ? void 0 : _d.terraAddress) === readonlyWallet.terraAddress && this.readonlyWallet.network === readonlyWallet.network) {\n        return;\n      }\n      if (this.readonlyWallet) {\n        this.readonlyWallet.disconnect();\n      }\n      this.readonlyWallet = readonlyWallet;\n      this.updateStates({\n        status: WalletStatus.WALLET_CONNECTED,\n        network: readonlyWallet.network,\n        wallets: [{\n          connectType: ConnectType.READONLY,\n          terraAddress: readonlyWallet.terraAddress,\n          design: 'readonly'\n        }]\n      });\n      this.disableReadonlyWallet = () => {\n        readonlyWallet.disconnect();\n        this.readonlyWallet = null;\n        this.disableReadonlyWallet = null;\n      };\n    };\n    this.enableWebExtension = () => {\n      var _a, _b, _c;\n      (_a = this.disableReadonlyWallet) === null || _a === void 0 ? void 0 : _a.call(this);\n      (_b = this.disableWalletConnect) === null || _b === void 0 ? void 0 : _b.call(this);\n      (_c = this.disableChromeExtension) === null || _c === void 0 ? void 0 : _c.call(this);\n      if (this.disableWebExtension || !this.webConnector) {\n        return;\n      }\n      const extensionSubscription = combineLatest([this.webConnector.status(), this.webConnector.states()]).subscribe(_ref3 => {\n        let [status, states] = _ref3;\n        var _a;\n        if (!states) {\n          return;\n        }\n        if (status.type === WebConnectorStatusType.READY) {\n          if (states.wallets.length > 0) {\n            const focusedWallet = states.focusedWalletAddress ? (_a = states.wallets.find(itemWallet => itemWallet.terraAddress === states.focusedWalletAddress)) !== null && _a !== void 0 ? _a : states.wallets[0] : states.wallets[0];\n            this.updateStates({\n              status: WalletStatus.WALLET_CONNECTED,\n              network: states.network,\n              wallets: [{\n                connectType: ConnectType.WEB_CONNECT,\n                terraAddress: focusedWallet.terraAddress,\n                design: focusedWallet.design\n              }]\n            });\n          }\n        } else if (status.type === WebConnectorStatusType.NO_AVAILABLE) {\n          localStorage.removeItem(WEB_EXTENSION_CONNECTED_KEY);\n          this.updateStates(this._notConnected);\n          if (!status.isApproved && this.disableWebExtension) {\n            this.disableWebExtension();\n          }\n        }\n      });\n      localStorage.setItem(WEB_EXTENSION_CONNECTED_KEY, 'true');\n      const lastExtensionStatus = this.webConnector.getLastStatus();\n      if (lastExtensionStatus.type === WebConnectorStatusType.NO_AVAILABLE && lastExtensionStatus.isApproved === false) {\n        this.webConnector.requestApproval();\n      }\n      this.disableWebExtension = () => {\n        localStorage.removeItem(WEB_EXTENSION_CONNECTED_KEY);\n        extensionSubscription.unsubscribe();\n        this.disableWebExtension = null;\n      };\n    };\n    this.enableChromeExtension = () => {\n      var _a, _b, _c;\n      (_a = this.disableReadonlyWallet) === null || _a === void 0 ? void 0 : _a.call(this);\n      (_b = this.disableWalletConnect) === null || _b === void 0 ? void 0 : _b.call(this);\n      (_c = this.disableWebExtension) === null || _c === void 0 ? void 0 : _c.call(this);\n      if (this.disableChromeExtension || !this.chromeExtension) {\n        return;\n      }\n      const extensionSubscription = combineLatest([this.chromeExtension.status(), this.chromeExtension.networkInfo(), this.chromeExtension.terraAddress()]).subscribe({\n        next: _ref4 => {\n          let [status, networkInfo, terraAddress] = _ref4;\n          if (status === ChromeExtensionStatus.WALLET_CONNECTED && typeof terraAddress === 'string' && AccAddress.validate(terraAddress)) {\n            this.updateStates({\n              status: WalletStatus.WALLET_CONNECTED,\n              network: networkInfo,\n              wallets: [{\n                connectType: ConnectType.CHROME_EXTENSION,\n                terraAddress,\n                design: 'extension'\n              }]\n            });\n          } else {\n            this.updateStates(this._notConnected);\n          }\n        }\n      });\n      this.disableChromeExtension = () => {\n        var _a;\n        (_a = this.chromeExtension) === null || _a === void 0 ? void 0 : _a.disconnect();\n        extensionSubscription.unsubscribe();\n        this.disableChromeExtension = null;\n      };\n    };\n    this.enableWalletConnect = walletConnect => {\n      var _a, _b, _c;\n      (_a = this.disableReadonlyWallet) === null || _a === void 0 ? void 0 : _a.call(this);\n      (_b = this.disableChromeExtension) === null || _b === void 0 ? void 0 : _b.call(this);\n      (_c = this.disableWebExtension) === null || _c === void 0 ? void 0 : _c.call(this);\n      if (this.walletConnect === walletConnect) {\n        return;\n      }\n      if (this.walletConnect) {\n        this.walletConnect.disconnect();\n      }\n      this.walletConnect = walletConnect;\n      const subscribeWalletConnect = wc => {\n        return wc.session().subscribe({\n          next: status => {\n            var _a;\n            switch (status.status) {\n              case WalletConnectSessionStatus.CONNECTED:\n                this.updateStates({\n                  status: WalletStatus.WALLET_CONNECTED,\n                  network: (_a = this.options.walletConnectChainIds[status.chainId]) !== null && _a !== void 0 ? _a : this.options.defaultNetwork,\n                  wallets: [{\n                    connectType: ConnectType.WALLETCONNECT,\n                    terraAddress: status.terraAddress,\n                    design: 'walletconnect'\n                  }]\n                });\n                break;\n              default:\n                this.updateStates(this._notConnected);\n                break;\n            }\n          }\n        });\n      };\n      const walletConnectSessionSubscription = subscribeWalletConnect(walletConnect);\n      this.disableWalletConnect = () => {\n        var _a;\n        (_a = this.walletConnect) === null || _a === void 0 ? void 0 : _a.disconnect();\n        this.walletConnect = null;\n        walletConnectSessionSubscription.unsubscribe();\n        this.disableWalletConnect = null;\n      };\n    };\n    this._notConnected = {\n      status: WalletStatus.WALLET_NOT_CONNECTED,\n      network: options.defaultNetwork\n    };\n    this._initializing = {\n      status: WalletStatus.INITIALIZING,\n      network: options.defaultNetwork\n    };\n    this._availableConnectTypes = new BehaviorSubject([ConnectType.READONLY, ConnectType.WALLETCONNECT]);\n    this._availableInstallTypes = new BehaviorSubject([]);\n    this._states = new BehaviorSubject(this._initializing);\n    let numSessionCheck = 0;\n    // wait checking the availability of the chrome extension\n    // 0. check if extension wallet session is exists\n    checkAvailableExtension((_a = options.waitingChromeExtensionInstallCheck) !== null && _a !== void 0 ? _a : defaultWaitingChromeExtensionInstallCheck, this.isChromeExtensionCompatibleBrowser()).then(extensionType => {\n      var _a;\n      if (extensionType === ConnectType.WEB_CONNECT) {\n        this._availableConnectTypes.next([ConnectType.READONLY, ConnectType.WEB_CONNECT, ConnectType.WALLETCONNECT]);\n        this.webConnector = new WebConnectorController(window);\n        const subscription = this.webConnector.status().pipe(filter(webExtensionStatus => {\n          return webExtensionStatus.type !== WebConnectorStatusType.INITIALIZING;\n        })).subscribe(webExtensionStatus => {\n          subscription.unsubscribe();\n          if (webExtensionStatus.type === WebConnectorStatusType.READY && localStorage.getItem(WEB_EXTENSION_CONNECTED_KEY) === 'true' && !this.disableWalletConnect && !this.disableReadonlyWallet) {\n            this.enableWebExtension();\n          } else if (numSessionCheck === 0) {\n            numSessionCheck += 1;\n          } else {\n            this.updateStates(this._notConnected);\n            localStorage.removeItem(WEB_EXTENSION_CONNECTED_KEY);\n          }\n        });\n      } else if (extensionType === ConnectType.CHROME_EXTENSION) {\n        this._availableConnectTypes.next([ConnectType.READONLY, ConnectType.CHROME_EXTENSION, ConnectType.WALLETCONNECT]);\n        this.chromeExtension = new ChromeExtensionController({\n          enableWalletConnection: true,\n          defaultNetwork: options.defaultNetwork,\n          selectExtension: options.selectChromeExtension,\n          dangerously__chromeExtensionCompatibleBrowserCheck: (_a = options.dangerously__chromeExtensionCompatibleBrowserCheck) !== null && _a !== void 0 ? _a : DEFAULT_CHROME_EXTENSION_COMPATIBLE_BROWSER_CHECK\n        });\n        const subscription = this.chromeExtension.status().pipe(filter(chromeExtensionStatus => {\n          return chromeExtensionStatus !== ChromeExtensionStatus.INITIALIZING;\n        })).subscribe(chromeExtensionStatus => {\n          try {\n            subscription.unsubscribe();\n          } catch (_a) {}\n          if (chromeExtensionStatus === ChromeExtensionStatus.WALLET_CONNECTED && !this.disableWalletConnect && !this.disableReadonlyWallet) {\n            this.enableChromeExtension();\n          } else if (numSessionCheck === 0) {\n            numSessionCheck += 1;\n          } else {\n            this.updateStates(this._notConnected);\n          }\n        });\n      } else {\n        if (isDesktopChrome(this.isChromeExtensionCompatibleBrowser())) {\n          this._availableInstallTypes.next([ConnectType.CHROME_EXTENSION]);\n        }\n        if (numSessionCheck === 0) {\n          numSessionCheck += 1;\n        } else {\n          this.updateStates(this._notConnected);\n        }\n      }\n    });\n    // 1. check if readonly wallet session is exists\n    const draftReadonlyWallet = reConnectIfSessionExists();\n    if (draftReadonlyWallet) {\n      this.enableReadonlyWallet(draftReadonlyWallet);\n      return;\n    }\n    // 2. check if walletconnect sesison is exists\n    const draftWalletConnect = wcConnectIfSessionExists(options);\n    if (draftWalletConnect && draftWalletConnect.getLatestSession().status === WalletConnectSessionStatus.CONNECTED) {\n      this.enableWalletConnect(draftWalletConnect);\n    } else if (numSessionCheck === 0) {\n      numSessionCheck += 1;\n    } else {\n      this.updateStates(this._notConnected);\n    }\n  }\n}","map":{"version":3,"names":["isDesktopChrome","getTerraChromeExtensions","readonlyWalletModal","ConnectType","WalletStatus","CreateTxFailed","Timeout","TxFailed","TxUnspecifiedError","UserDenied","WebConnectorController","WebConnectorCreateTxFailed","WebConnectorStatusType","WebConnectorTxFailed","WebConnectorTxStatus","WebConnectorUserDenied","AccAddress","deepEqual","BehaviorSubject","combineLatest","filter","map","CHROME_EXTENSION_INSTALL_URL","DEFAULT_CHROME_EXTENSION_COMPATIBLE_BROWSER_CHECK","WEB_EXTENSION_CONNECTED_KEY","ChromeExtensionController","ChromeExtensionCreateTxFailed","ChromeExtensionStatus","ChromeExtensionTxFailed","ChromeExtensionUnspecifiedError","connect","reConnect","connectIfSessionExists","reConnectIfSessionExists","wcConnect","wcConnectIfSessionExists","WalletConnectCreateTxFailed","WalletConnectSessionStatus","WalletConnectTimeout","WalletConnectTxFailed","WalletConnectTxUnspecifiedError","WalletConnectUserDenied","checkAvailableExtension","CONNECTIONS","READONLY","type","name","icon","WALLETCONNECT","WEB_CONNECT","defaultWaitingChromeExtensionInstallCheck","WalletController","constructor","options","_this","chromeExtension","webConnector","walletConnect","readonlyWallet","disableReadonlyWallet","disableChromeExtension","disableWebExtension","disableWalletConnect","isChromeExtensionCompatibleBrowser","_a","dangerously__chromeExtensionCompatibleBrowserCheck","navigator","userAgent","availableConnectTypes","_availableConnectTypes","asObservable","availableConnections","pipe","connectTypes","connections","connectType","CHROME_EXTENSION","terraExtensions","terraExtension","push","availableInstallTypes","_availableInstallTypes","states","_states","status","data","network","wallets","WALLET_CONNECTED","recheckStatus","install","window","open","webExtensionStatus","getLastStatus","NO_AVAILABLE","installLink","console","warn","concat","identifier","networks","Object","keys","walletConnectChainIds","chainId","createReadonlyWalletSession","_c","_b","call","then","readonlyWalletSession","enableReadonlyWallet","enableWalletConnect","success","enableChromeExtension","enableWebExtension","Error","connectReadonly","terraAddress","disconnect","_d","localStorage","removeItem","updateStates","_notConnected","post","tx","txTarget","arguments","length","undefined","_ref","payload","result","catch","error","message","txhash","Promise","resolve","reject","webExtensionStates","getLastStates","focusedWallet","find","itemWallet","focusedWalletAddress","subscription","subscribe","next","extensionTxResult","SUCCEED","unsubscribe","raw_message","String","throwError","sign","_ref2","publicKey","public_key","value","signResult","prev","getValue","trace","design","extensionSubscription","_ref3","READY","isApproved","setItem","lastExtensionStatus","requestApproval","networkInfo","_ref4","validate","subscribeWalletConnect","wc","session","CONNECTED","defaultNetwork","walletConnectSessionSubscription","WALLET_NOT_CONNECTED","_initializing","INITIALIZING","numSessionCheck","waitingChromeExtensionInstallCheck","extensionType","getItem","enableWalletConnection","selectExtension","selectChromeExtension","chromeExtensionStatus","draftReadonlyWallet","draftWalletConnect","getLatestSession"],"sources":["../../../src/@terra-money/wallet-provider/controller.ts"],"sourcesContent":["import { isDesktopChrome } from '@terra-dev/browser-check';\nimport {\n  ChromeExtensionInfo,\n  getTerraChromeExtensions,\n} from '@terra-dev/chrome-extension';\nimport { readonlyWalletModal } from '@terra-dev/readonly-wallet-modal';\nimport {\n  Connection,\n  ConnectType,\n  TxResult,\n  WalletInfo,\n  WalletStates,\n  WalletStatus,\n} from '@terra-dev/use-wallet';\nimport {\n  CreateTxFailed,\n  NetworkInfo,\n  SignResult,\n  Timeout,\n  TxFailed,\n  TxUnspecifiedError,\n  UserDenied,\n} from '@terra-dev/wallet-types';\nimport { WebConnectorController } from '@terra-dev/web-connector-controller';\nimport {\n  WebConnectorCreateTxFailed,\n  WebConnectorStatusType,\n  WebConnectorTxFailed,\n  WebConnectorTxResult,\n  WebConnectorTxStatus,\n  WebConnectorUserDenied,\n} from '@terra-dev/web-connector-interface';\nimport {\n  AccAddress,\n  CreateTxOptions,\n  PublicKey,\n  StdSignMsg,\n} from '@terra-money/terra.js';\nimport deepEqual from 'fast-deep-equal';\nimport { BehaviorSubject, combineLatest, Observable, Subscription } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\nimport {\n  CHROME_EXTENSION_INSTALL_URL,\n  DEFAULT_CHROME_EXTENSION_COMPATIBLE_BROWSER_CHECK,\n  WEB_EXTENSION_CONNECTED_KEY,\n} from './env';\nimport {\n  ChromeExtensionController,\n  ChromeExtensionCreateTxFailed,\n  ChromeExtensionStatus,\n  ChromeExtensionTxFailed,\n  ChromeExtensionUnspecifiedError,\n} from './modules/chrome-extension';\nimport {\n  connect as reConnect,\n  connectIfSessionExists as reConnectIfSessionExists,\n  ReadonlyWalletController,\n  ReadonlyWalletSession,\n} from './modules/readonly-wallet';\nimport {\n  connect as wcConnect,\n  connectIfSessionExists as wcConnectIfSessionExists,\n  WalletConnectController,\n  WalletConnectControllerOptions,\n  WalletConnectCreateTxFailed,\n  WalletConnectSessionStatus,\n  WalletConnectTimeout,\n  WalletConnectTxFailed,\n  WalletConnectTxResult,\n  WalletConnectTxUnspecifiedError,\n  WalletConnectUserDenied,\n} from './modules/walletconnect';\nimport { checkAvailableExtension } from './utils/checkAvailableExtension';\n\nexport interface WalletControllerOptions\n  extends WalletConnectControllerOptions {\n  /**\n   * ⚠️ Don't hardcoding this, use getChain Options()\n   *\n   * fallback network if controller is not connected\n   */\n  defaultNetwork: NetworkInfo;\n\n  /**\n   * ⚠️ Don't hardcoding this, use getChain Options()\n   *\n   * for walletconnect\n   *\n   * The network rules passed by the Terra Station Mobile are 0 is testnet, 1 is mainnet.\n   *\n   * Always set testnet for 0 and mainnet for 1.\n   *\n   * @example\n   * ```\n   * const mainnet: NetworkInfo = {\n   *  name: 'mainnet',\n   *  chainID: 'columbus-5',\n   *  lcd: 'https://lcd.terra.dev',\n   * }\n   *\n   * const testnet: NetworkInfo = {\n   *  name: 'testnet',\n   *  chainID: 'bombay-12',\n   *  lcd: 'https://bombay-lcd.terra.dev',\n   * }\n   *\n   * const walletConnectChainIds: Record<number, NetworkInfo> = {\n   *   0: testnet,\n   *   1: mainnet,\n   * }\n   *\n   * <WalletProvider walletConnectChainIds={walletConnectChainIds}>\n   * ```\n   */\n  walletConnectChainIds: Record<number, NetworkInfo>;\n\n  /**\n   * run at executing the `connect(ConnectType.READONLY)`\n   */\n  createReadonlyWalletSession?: (\n    networks: NetworkInfo[],\n  ) => Promise<ReadonlyWalletSession | null>;\n\n  /**\n   * run at executing the `connect(ConnectType.CHROME_EXTENSION)`\n   * if user installed multiple wallets\n   */\n  selectChromeExtension?: (\n    extensionInfos: ChromeExtensionInfo[],\n  ) => Promise<ChromeExtensionInfo | null>;\n\n  /**\n   * milliseconds to wait checking chrome extension is installed\n   *\n   * @default 1000 * 3 miliseconds\n   */\n  waitingChromeExtensionInstallCheck?: number;\n\n  /**\n   * ⚠️ This API is an option for wallet developers. Please don't use dApp developers.\n   *\n   * @example\n   * ```\n   * <WalletProvider dangerously__chromeExtensionCompatibleBrowserCheck={(userAgent: string) => {\n   *   return /MyWallet\\//.test(userAgent);\n   * }}>\n   * ```\n   */\n  dangerously__chromeExtensionCompatibleBrowserCheck?: (\n    userAgent: string,\n  ) => boolean;\n}\n\nconst CONNECTIONS = {\n  [ConnectType.READONLY]: {\n    type: ConnectType.READONLY,\n    name: 'View an address',\n    icon: 'https://assets.terra.money/icon/station-extension/icon.png',\n  } as Connection,\n  [ConnectType.WALLETCONNECT]: {\n    type: ConnectType.WALLETCONNECT,\n    name: 'Terra Station Mobile',\n    icon: 'https://assets.terra.money/icon/station-extension/icon.png',\n  } as Connection,\n  [ConnectType.WEB_CONNECT]: {\n    type: ConnectType.WEB_CONNECT,\n    name: 'Terra Station',\n    icon: 'https://assets.terra.money/icon/station-extension/icon.png',\n  } as Connection,\n} as const;\n\nconst defaultWaitingChromeExtensionInstallCheck = 1000 * 3;\n\nexport class WalletController {\n  private chromeExtension: ChromeExtensionController | null = null;\n  private webConnector: WebConnectorController | null = null;\n  private walletConnect: WalletConnectController | null = null;\n  private readonlyWallet: ReadonlyWalletController | null = null;\n\n  private _availableConnectTypes: BehaviorSubject<ConnectType[]>;\n  private _availableInstallTypes: BehaviorSubject<ConnectType[]>;\n  private _states: BehaviorSubject<WalletStates>;\n\n  private disableReadonlyWallet: (() => void) | null = null;\n  private disableChromeExtension: (() => void) | null = null;\n  private disableWebExtension: (() => void) | null = null;\n  private disableWalletConnect: (() => void) | null = null;\n\n  private readonly _notConnected: WalletStates;\n  private readonly _initializing: WalletStates;\n\n  constructor(readonly options: WalletControllerOptions) {\n    this._notConnected = {\n      status: WalletStatus.WALLET_NOT_CONNECTED,\n      network: options.defaultNetwork,\n    };\n\n    this._initializing = {\n      status: WalletStatus.INITIALIZING,\n      network: options.defaultNetwork,\n    };\n\n    this._availableConnectTypes = new BehaviorSubject<ConnectType[]>([\n      ConnectType.READONLY,\n      ConnectType.WALLETCONNECT,\n    ]);\n\n    this._availableInstallTypes = new BehaviorSubject<ConnectType[]>([]);\n\n    this._states = new BehaviorSubject<WalletStates>(this._initializing);\n\n    let numSessionCheck: number = 0;\n\n    // wait checking the availability of the chrome extension\n    // 0. check if extension wallet session is exists\n    checkAvailableExtension(\n      options.waitingChromeExtensionInstallCheck ??\n        defaultWaitingChromeExtensionInstallCheck,\n      this.isChromeExtensionCompatibleBrowser(),\n    ).then((extensionType) => {\n      if (extensionType === ConnectType.WEB_CONNECT) {\n        this._availableConnectTypes.next([\n          ConnectType.READONLY,\n          ConnectType.WEB_CONNECT,\n          ConnectType.WALLETCONNECT,\n        ]);\n\n        this.webConnector = new WebConnectorController(window);\n\n        const subscription = this.webConnector\n          .status()\n          .pipe(\n            filter((webExtensionStatus) => {\n              return (\n                webExtensionStatus.type !== WebConnectorStatusType.INITIALIZING\n              );\n            }),\n          )\n          .subscribe((webExtensionStatus) => {\n            subscription.unsubscribe();\n\n            if (\n              webExtensionStatus.type === WebConnectorStatusType.READY &&\n              localStorage.getItem(WEB_EXTENSION_CONNECTED_KEY) === 'true' &&\n              !this.disableWalletConnect &&\n              !this.disableReadonlyWallet\n            ) {\n              this.enableWebExtension();\n            } else if (numSessionCheck === 0) {\n              numSessionCheck += 1;\n            } else {\n              this.updateStates(this._notConnected);\n              localStorage.removeItem(WEB_EXTENSION_CONNECTED_KEY);\n            }\n          });\n      } else if (extensionType === ConnectType.CHROME_EXTENSION) {\n        this._availableConnectTypes.next([\n          ConnectType.READONLY,\n          ConnectType.CHROME_EXTENSION,\n          ConnectType.WALLETCONNECT,\n        ]);\n\n        this.chromeExtension = new ChromeExtensionController({\n          enableWalletConnection: true,\n          defaultNetwork: options.defaultNetwork,\n          selectExtension: options.selectChromeExtension,\n          dangerously__chromeExtensionCompatibleBrowserCheck:\n            options.dangerously__chromeExtensionCompatibleBrowserCheck ??\n            DEFAULT_CHROME_EXTENSION_COMPATIBLE_BROWSER_CHECK,\n        });\n\n        const subscription = this.chromeExtension\n          .status()\n          .pipe(\n            filter((chromeExtensionStatus) => {\n              return (\n                chromeExtensionStatus !== ChromeExtensionStatus.INITIALIZING\n              );\n            }),\n          )\n          .subscribe((chromeExtensionStatus) => {\n            try {\n              subscription.unsubscribe();\n            } catch {}\n\n            if (\n              chromeExtensionStatus ===\n                ChromeExtensionStatus.WALLET_CONNECTED &&\n              !this.disableWalletConnect &&\n              !this.disableReadonlyWallet\n            ) {\n              this.enableChromeExtension();\n            } else if (numSessionCheck === 0) {\n              numSessionCheck += 1;\n            } else {\n              this.updateStates(this._notConnected);\n            }\n          });\n      } else {\n        if (isDesktopChrome(this.isChromeExtensionCompatibleBrowser())) {\n          this._availableInstallTypes.next([ConnectType.CHROME_EXTENSION]);\n        }\n\n        if (numSessionCheck === 0) {\n          numSessionCheck += 1;\n        } else {\n          this.updateStates(this._notConnected);\n        }\n      }\n    });\n\n    // 1. check if readonly wallet session is exists\n    const draftReadonlyWallet = reConnectIfSessionExists();\n\n    if (draftReadonlyWallet) {\n      this.enableReadonlyWallet(draftReadonlyWallet);\n      return;\n    }\n\n    // 2. check if walletconnect sesison is exists\n    const draftWalletConnect = wcConnectIfSessionExists(options);\n\n    if (\n      draftWalletConnect &&\n      draftWalletConnect.getLatestSession().status ===\n        WalletConnectSessionStatus.CONNECTED\n    ) {\n      this.enableWalletConnect(draftWalletConnect);\n    } else if (numSessionCheck === 0) {\n      numSessionCheck += 1;\n    } else {\n      this.updateStates(this._notConnected);\n    }\n  }\n\n  /** @see Wallet#isChromeExtensionCompatibleBrowser */\n  isChromeExtensionCompatibleBrowser = (): boolean => {\n    return (\n      this.options.dangerously__chromeExtensionCompatibleBrowserCheck ??\n      DEFAULT_CHROME_EXTENSION_COMPATIBLE_BROWSER_CHECK\n    )(navigator.userAgent);\n  };\n\n  /** @see Wallet#availableConnectTypes */\n  availableConnectTypes = (): Observable<ConnectType[]> => {\n    return this._availableConnectTypes.asObservable();\n  };\n\n  /** @see Wallet#availableConnections */\n  availableConnections = (): Observable<Connection[]> => {\n    return this._availableConnectTypes.pipe(\n      map((connectTypes) => {\n        const connections: Connection[] = [];\n\n        for (const connectType of connectTypes) {\n          if (connectType === ConnectType.CHROME_EXTENSION) {\n            const terraExtensions = getTerraChromeExtensions();\n\n            for (const terraExtension of terraExtensions) {\n              connections.push({\n                type: ConnectType.CHROME_EXTENSION,\n                ...terraExtension,\n              });\n            }\n          } else {\n            connections.push(CONNECTIONS[connectType]);\n          }\n        }\n\n        return connections;\n      }),\n    );\n  };\n\n  /** @see Wallet#availableInstallTypes */\n  availableInstallTypes = (): Observable<ConnectType[]> => {\n    return this._availableInstallTypes.asObservable();\n  };\n\n  /**\n   * @see Wallet#status\n   * @see Wallet#network\n   * @see Wallet#wallets\n   */\n  states = (): Observable<WalletStates> => {\n    return this._states.asObservable();\n  };\n\n  /** @deprecated please use `states()` */\n  status = (): Observable<WalletStatus> => {\n    return this._states.pipe(map((data) => data.status));\n  };\n\n  /** @deprecated please use `states()` */\n  network = (): Observable<NetworkInfo> => {\n    return this._states.pipe(map((data) => data.network));\n  };\n\n  /** @deprecated please use `states()` */\n  wallets = (): Observable<WalletInfo[]> => {\n    return this._states.pipe(\n      map((data) =>\n        data.status === WalletStatus.WALLET_CONNECTED ? data.wallets : [],\n      ),\n    );\n  };\n\n  /** @see Wallet#recheckStatus */\n  recheckStatus = () => {\n    if (this.disableChromeExtension) {\n      this.chromeExtension?.recheckStatus();\n    }\n  };\n\n  /** @see Wallet#install */\n  install = (type: ConnectType) => {\n    if (type === ConnectType.CHROME_EXTENSION) {\n      window.open(CHROME_EXTENSION_INSTALL_URL, '_blank');\n    } else if (type === ConnectType.WEB_CONNECT) {\n      const webExtensionStatus = this.webConnector?.getLastStatus();\n      if (\n        webExtensionStatus?.type === WebConnectorStatusType.NO_AVAILABLE &&\n        webExtensionStatus.installLink\n      ) {\n        window.open(webExtensionStatus.installLink, '_blank');\n      }\n    } else {\n      console.warn(`ConnectType \"${type}\" does not support install() function`);\n    }\n  };\n\n  /** @see Wallet#connect */\n  connect = (type: ConnectType, identifier?: string) => {\n    switch (type) {\n      case ConnectType.READONLY:\n        const networks: NetworkInfo[] = Object.keys(\n          this.options.walletConnectChainIds,\n        ).map((chainId) => this.options.walletConnectChainIds[+chainId]);\n\n        const createReadonlyWalletSession =\n          this.options.createReadonlyWalletSession?.(networks) ??\n          readonlyWalletModal({ networks });\n\n        createReadonlyWalletSession.then((readonlyWalletSession) => {\n          if (readonlyWalletSession) {\n            this.enableReadonlyWallet(reConnect(readonlyWalletSession));\n          }\n        });\n        break;\n      case ConnectType.WALLETCONNECT:\n        this.enableWalletConnect(wcConnect(this.options));\n        break;\n      case ConnectType.CHROME_EXTENSION:\n        this.chromeExtension!.connect(identifier).then((success) => {\n          if (success) {\n            this.enableChromeExtension();\n          }\n        });\n        break;\n      case ConnectType.WEB_CONNECT:\n        this.enableWebExtension();\n        break;\n      default:\n        throw new Error(`Unknown ConnectType!`);\n    }\n  };\n\n  /** @see Wallet#connectReadonly */\n  connectReadonly = (terraAddress: string, network: NetworkInfo) => {\n    this.enableReadonlyWallet(\n      reConnect({\n        terraAddress,\n        network,\n      }),\n    );\n  };\n\n  /** @see Wallet#disconnect */\n  disconnect = () => {\n    this.disableReadonlyWallet?.();\n    this.disableReadonlyWallet = null;\n\n    this.disableChromeExtension?.();\n    this.disableChromeExtension = null;\n\n    this.disableWebExtension?.();\n    this.disableWebExtension = null;\n\n    this.disableWalletConnect?.();\n    this.disableWalletConnect = null;\n\n    localStorage.removeItem(WEB_EXTENSION_CONNECTED_KEY);\n    this.updateStates(this._notConnected);\n  };\n\n  /** @see Wallet#post */\n  post = async (\n    tx: CreateTxOptions,\n    // TODO not work at this time. for the future extension\n    txTarget: { terraAddress?: string } = {},\n  ): Promise<TxResult> => {\n    // ---------------------------------------------\n    // chrome extension - legacy extension\n    // ---------------------------------------------\n    if (this.disableChromeExtension) {\n      if (!this.chromeExtension) {\n        throw new Error(`chromeExtension instance not created!`);\n      }\n\n      return (\n        this.chromeExtension\n          // TODO make WalletConnectTxResult to common type\n          .post<CreateTxOptions, { result: WalletConnectTxResult }>(tx)\n          .then(({ payload }) => {\n            return {\n              ...tx,\n              result: payload.result,\n              success: true,\n            } as TxResult;\n          })\n          .catch((error) => {\n            if (error instanceof ChromeExtensionCreateTxFailed) {\n              throw new CreateTxFailed(tx, error.message);\n            } else if (error instanceof ChromeExtensionTxFailed) {\n              throw new TxFailed(tx, error.txhash, error.message, null);\n            } else if (error instanceof ChromeExtensionUnspecifiedError) {\n              throw new TxUnspecifiedError(tx, error.message);\n            }\n            // UserDeniedError\n            // All unspecified errors...\n            throw error;\n          })\n      );\n    }\n    // ---------------------------------------------\n    // web extension - new extension\n    // ---------------------------------------------\n    else if (this.disableWebExtension) {\n      return new Promise<TxResult>((resolve, reject) => {\n        if (!this.webConnector) {\n          reject(new Error(`webExtension instance not created!`));\n          return;\n        }\n\n        const webExtensionStates = this.webConnector.getLastStates();\n\n        if (!webExtensionStates) {\n          reject(new Error(`webExtension.getLastStates() returns undefined!`));\n          return;\n        }\n\n        const focusedWallet = txTarget.terraAddress\n          ? webExtensionStates.wallets.find(\n              (itemWallet) => itemWallet.terraAddress === txTarget.terraAddress,\n            ) ?? webExtensionStates.wallets[0]\n          : webExtensionStates.focusedWalletAddress\n          ? webExtensionStates.wallets.find(\n              (itemWallet) =>\n                itemWallet.terraAddress ===\n                webExtensionStates.focusedWalletAddress,\n            ) ?? webExtensionStates.wallets[0]\n          : webExtensionStates.wallets[0];\n\n        const subscription = this.webConnector\n          .post(focusedWallet.terraAddress, tx)\n          .subscribe({\n            next: (extensionTxResult: WebConnectorTxResult) => {\n              switch (extensionTxResult.status) {\n                case WebConnectorTxStatus.SUCCEED:\n                  resolve({\n                    ...tx,\n                    result: extensionTxResult.payload,\n                    success: true,\n                  });\n                  subscription.unsubscribe();\n                  break;\n              }\n            },\n            error: (error) => {\n              if (error instanceof WebConnectorUserDenied) {\n                reject(new UserDenied());\n              } else if (error instanceof WebConnectorCreateTxFailed) {\n                reject(new CreateTxFailed(tx, error.message));\n              } else if (error instanceof WebConnectorTxFailed) {\n                reject(\n                  new TxFailed(\n                    tx,\n                    error.txhash,\n                    error.message,\n                    error.raw_message,\n                  ),\n                );\n              } else {\n                reject(\n                  new TxUnspecifiedError(\n                    tx,\n                    'message' in error ? error.message : String(error),\n                  ),\n                );\n              }\n              subscription.unsubscribe();\n            },\n          });\n      });\n    }\n    // ---------------------------------------------\n    // wallet connect\n    // ---------------------------------------------\n    else if (this.walletConnect) {\n      return this.walletConnect\n        .post(tx)\n        .then(\n          (result) =>\n            ({\n              ...tx,\n              result,\n              success: true,\n            } as TxResult),\n        )\n        .catch((error) => {\n          let throwError = error;\n\n          try {\n            if (error instanceof WalletConnectUserDenied) {\n              throwError = new UserDenied();\n            } else if (error instanceof WalletConnectCreateTxFailed) {\n              throwError = new CreateTxFailed(tx, error.message);\n            } else if (error instanceof WalletConnectTxFailed) {\n              throwError = new TxFailed(\n                tx,\n                error.txhash,\n                error.message,\n                error.raw_message,\n              );\n            } else if (error instanceof WalletConnectTimeout) {\n              throwError = new Timeout(error.message);\n            } else if (error instanceof WalletConnectTxUnspecifiedError) {\n              throwError = new TxUnspecifiedError(tx, error.message);\n            }\n          } catch {\n            throwError = new TxUnspecifiedError(\n              tx,\n              'message' in error ? error.message : String(error),\n            );\n          }\n\n          throw throwError;\n        });\n    } else {\n      throw new Error(`There are no connections that can be posting tx!`);\n    }\n  };\n\n  /** @see Wallet#sign */\n  sign = async (\n    tx: CreateTxOptions,\n    // TODO not work at this time. for the future extension\n    txTarget: { terraAddress?: string } = {},\n  ): Promise<SignResult> => {\n    interface SignResultRaw extends CreateTxOptions {\n      result: {\n        public_key: string | PublicKey.Data;\n        recid: number;\n        signature: string;\n        stdSignMsgData: StdSignMsg.Data;\n      };\n      success: boolean;\n    }\n\n    if (this.disableChromeExtension) {\n      if (!this.chromeExtension) {\n        throw new Error(`chromeExtension instance not created!`);\n      }\n\n      return this.chromeExtension\n        .sign<CreateTxOptions, SignResultRaw>(tx)\n        .then(({ payload }) => {\n          const publicKey: PublicKey.Data =\n            typeof payload.result.public_key === 'string'\n              ? {\n                  type: 'tendermint/PubKeySecp256k1',\n                  value: payload.result.public_key,\n                }\n              : payload.result.public_key;\n\n          const signResult: SignResult['result'] = {\n            ...payload.result,\n            public_key: publicKey,\n          };\n\n          return {\n            ...tx,\n            result: signResult,\n            success: true,\n          };\n        })\n        .catch((error) => {\n          if (error instanceof ChromeExtensionCreateTxFailed) {\n            throw new CreateTxFailed(tx, error.message);\n          } else if (error instanceof ChromeExtensionTxFailed) {\n            throw new TxFailed(tx, error.txhash, error.message, null);\n          } else if (error instanceof ChromeExtensionUnspecifiedError) {\n            throw new TxUnspecifiedError(tx, error.message);\n          }\n          // UserDenied - chrome extension will sent original UserDenied error type\n          // All unspecified errors...\n          throw error;\n        });\n    }\n\n    throw new Error(`sign() method only available on chrome extension`);\n    // TODO implements sign() to other connect types\n  };\n\n  // ================================================================\n  // internal\n  // connect type changing\n  // ================================================================\n  private updateStates = (next: WalletStates) => {\n    const prev = this._states.getValue();\n\n    if (\n      next.status === WalletStatus.WALLET_CONNECTED &&\n      next.wallets.length === 0\n    ) {\n      console.trace('???');\n    }\n\n    if (prev.status !== next.status || !deepEqual(prev, next)) {\n      this._states.next(next);\n    }\n  };\n\n  private enableReadonlyWallet = (readonlyWallet: ReadonlyWalletController) => {\n    this.disableWalletConnect?.();\n    this.disableChromeExtension?.();\n    this.disableWebExtension?.();\n\n    if (\n      this.readonlyWallet === readonlyWallet ||\n      (this.readonlyWallet?.terraAddress === readonlyWallet.terraAddress &&\n        this.readonlyWallet.network === readonlyWallet.network)\n    ) {\n      return;\n    }\n\n    if (this.readonlyWallet) {\n      this.readonlyWallet.disconnect();\n    }\n\n    this.readonlyWallet = readonlyWallet;\n\n    this.updateStates({\n      status: WalletStatus.WALLET_CONNECTED,\n      network: readonlyWallet.network,\n      wallets: [\n        {\n          connectType: ConnectType.READONLY,\n          terraAddress: readonlyWallet.terraAddress,\n          design: 'readonly',\n        },\n      ],\n    });\n\n    this.disableReadonlyWallet = () => {\n      readonlyWallet.disconnect();\n      this.readonlyWallet = null;\n      this.disableReadonlyWallet = null;\n    };\n  };\n\n  private enableWebExtension = () => {\n    this.disableReadonlyWallet?.();\n    this.disableWalletConnect?.();\n    this.disableChromeExtension?.();\n\n    if (this.disableWebExtension || !this.webConnector) {\n      return;\n    }\n\n    const extensionSubscription = combineLatest([\n      this.webConnector.status(),\n      this.webConnector.states(),\n    ]).subscribe(([status, states]) => {\n      if (!states) {\n        return;\n      }\n\n      if (status.type === WebConnectorStatusType.READY) {\n        if (states.wallets.length > 0) {\n          const focusedWallet = states.focusedWalletAddress\n            ? states.wallets.find(\n                (itemWallet) =>\n                  itemWallet.terraAddress === states.focusedWalletAddress,\n              ) ?? states.wallets[0]\n            : states.wallets[0];\n\n          this.updateStates({\n            status: WalletStatus.WALLET_CONNECTED,\n            network: states.network,\n            wallets: [\n              {\n                connectType: ConnectType.WEB_CONNECT,\n                terraAddress: focusedWallet.terraAddress,\n                design: focusedWallet.design,\n              },\n            ],\n          });\n        }\n      } else if (status.type === WebConnectorStatusType.NO_AVAILABLE) {\n        localStorage.removeItem(WEB_EXTENSION_CONNECTED_KEY);\n        this.updateStates(this._notConnected);\n\n        if (!status.isApproved && this.disableWebExtension) {\n          this.disableWebExtension();\n        }\n      }\n    });\n\n    localStorage.setItem(WEB_EXTENSION_CONNECTED_KEY, 'true');\n\n    const lastExtensionStatus = this.webConnector.getLastStatus();\n\n    if (\n      lastExtensionStatus.type === WebConnectorStatusType.NO_AVAILABLE &&\n      lastExtensionStatus.isApproved === false\n    ) {\n      this.webConnector.requestApproval();\n    }\n\n    this.disableWebExtension = () => {\n      localStorage.removeItem(WEB_EXTENSION_CONNECTED_KEY);\n      extensionSubscription.unsubscribe();\n      this.disableWebExtension = null;\n    };\n  };\n\n  private enableChromeExtension = () => {\n    this.disableReadonlyWallet?.();\n    this.disableWalletConnect?.();\n    this.disableWebExtension?.();\n\n    if (this.disableChromeExtension || !this.chromeExtension) {\n      return;\n    }\n\n    const extensionSubscription = combineLatest([\n      this.chromeExtension.status(),\n      this.chromeExtension.networkInfo(),\n      this.chromeExtension.terraAddress(),\n    ]).subscribe({\n      next: ([status, networkInfo, terraAddress]) => {\n        if (\n          status === ChromeExtensionStatus.WALLET_CONNECTED &&\n          typeof terraAddress === 'string' &&\n          AccAddress.validate(terraAddress)\n        ) {\n          this.updateStates({\n            status: WalletStatus.WALLET_CONNECTED,\n            network: networkInfo,\n            wallets: [\n              {\n                connectType: ConnectType.CHROME_EXTENSION,\n                terraAddress,\n                design: 'extension',\n              },\n            ],\n          });\n        } else {\n          this.updateStates(this._notConnected);\n        }\n      },\n    });\n\n    this.disableChromeExtension = () => {\n      this.chromeExtension?.disconnect();\n      extensionSubscription.unsubscribe();\n      this.disableChromeExtension = null;\n    };\n  };\n\n  private enableWalletConnect = (walletConnect: WalletConnectController) => {\n    this.disableReadonlyWallet?.();\n    this.disableChromeExtension?.();\n    this.disableWebExtension?.();\n\n    if (this.walletConnect === walletConnect) {\n      return;\n    }\n\n    if (this.walletConnect) {\n      this.walletConnect.disconnect();\n    }\n\n    this.walletConnect = walletConnect;\n\n    const subscribeWalletConnect = (\n      wc: WalletConnectController,\n    ): Subscription => {\n      return wc.session().subscribe({\n        next: (status) => {\n          switch (status.status) {\n            case WalletConnectSessionStatus.CONNECTED:\n              this.updateStates({\n                status: WalletStatus.WALLET_CONNECTED,\n                network:\n                  this.options.walletConnectChainIds[status.chainId] ??\n                  this.options.defaultNetwork,\n                wallets: [\n                  {\n                    connectType: ConnectType.WALLETCONNECT,\n                    terraAddress: status.terraAddress,\n                    design: 'walletconnect',\n                  },\n                ],\n              });\n              break;\n            default:\n              this.updateStates(this._notConnected);\n              break;\n          }\n        },\n      });\n    };\n\n    const walletConnectSessionSubscription =\n      subscribeWalletConnect(walletConnect);\n\n    this.disableWalletConnect = () => {\n      this.walletConnect?.disconnect();\n      this.walletConnect = null;\n      walletConnectSessionSubscription.unsubscribe();\n      this.disableWalletConnect = null;\n    };\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}