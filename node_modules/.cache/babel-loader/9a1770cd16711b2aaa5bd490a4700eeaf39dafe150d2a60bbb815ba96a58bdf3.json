{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.signature = exports.number = exports.isCanonicalScriptSignature = exports.isDefinedHashType = exports.isCanonicalPubKey = exports.toStack = exports.fromASM = exports.toASM = exports.decompile = exports.compile = exports.countNonPushOnlyOPs = exports.isPushOnly = exports.OPS = void 0;\nconst bip66 = require('./bip66');\nconst ops_1 = require('./ops');\nObject.defineProperty(exports, 'OPS', {\n  enumerable: true,\n  get: function () {\n    return ops_1.OPS;\n  }\n});\nconst pushdata = require('./push_data');\nconst scriptNumber = require('./script_number');\nconst scriptSignature = require('./script_signature');\nconst types = require('./types');\nconst {\n  typeforce\n} = types;\nconst OP_INT_BASE = ops_1.OPS.OP_RESERVED; // OP_1 - 1\nfunction isOPInt(value) {\n  return types.Number(value) && (value === ops_1.OPS.OP_0 || value >= ops_1.OPS.OP_1 && value <= ops_1.OPS.OP_16 || value === ops_1.OPS.OP_1NEGATE);\n}\nfunction isPushOnlyChunk(value) {\n  return types.Buffer(value) || isOPInt(value);\n}\nfunction isPushOnly(value) {\n  return types.Array(value) && value.every(isPushOnlyChunk);\n}\nexports.isPushOnly = isPushOnly;\nfunction countNonPushOnlyOPs(value) {\n  return value.length - value.filter(isPushOnlyChunk).length;\n}\nexports.countNonPushOnlyOPs = countNonPushOnlyOPs;\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return ops_1.OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return ops_1.OPS.OP_1NEGATE;\n}\nfunction chunksIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\nfunction chunksIsArray(buf) {\n  return types.Array(buf);\n}\nfunction singleChunkIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\nfunction compile(chunks) {\n  // TODO: remove me\n  if (chunksIsBuffer(chunks)) return chunks;\n  typeforce(types.Array, chunks);\n  const bufferSize = chunks.reduce((accum, chunk) => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    }\n    // opcode\n    return accum + 1;\n  }, 0.0);\n  const buffer = Buffer.allocUnsafe(bufferSize);\n  let offset = 0;\n  chunks.forEach(chunk => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      const opcode = asMinimalOP(chunk);\n      if (opcode !== undefined) {\n        buffer.writeUInt8(opcode, offset);\n        offset += 1;\n        return;\n      }\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      chunk.copy(buffer, offset);\n      offset += chunk.length;\n      // opcode\n    } else {\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  });\n  if (offset !== buffer.length) throw new Error('Could not decode chunks');\n  return buffer;\n}\nexports.compile = compile;\nfunction decompile(buffer) {\n  // TODO: remove me\n  if (chunksIsArray(buffer)) return buffer;\n  typeforce(types.Buffer, buffer);\n  const chunks = [];\n  let i = 0;\n  while (i < buffer.length) {\n    const opcode = buffer[i];\n    // data chunk\n    if (opcode > ops_1.OPS.OP_0 && opcode <= ops_1.OPS.OP_PUSHDATA4) {\n      const d = pushdata.decode(buffer, i);\n      // did reading a pushDataInt fail?\n      if (d === null) return null;\n      i += d.size;\n      // attempt to read too much data?\n      if (i + d.number > buffer.length) return null;\n      const data = buffer.slice(i, i + d.number);\n      i += d.number;\n      // decompile minimally\n      const op = asMinimalOP(data);\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      }\n      // opcode\n    } else {\n      chunks.push(opcode);\n      i += 1;\n    }\n  }\n  return chunks;\n}\nexports.decompile = decompile;\nfunction toASM(chunks) {\n  if (chunksIsBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n  return chunks.map(chunk => {\n    // data?\n    if (singleChunkIsBuffer(chunk)) {\n      const op = asMinimalOP(chunk);\n      if (op === undefined) return chunk.toString('hex');\n      chunk = op;\n    }\n    // opcode!\n    return ops_1.REVERSE_OPS[chunk];\n  }).join(' ');\n}\nexports.toASM = toASM;\nfunction fromASM(asm) {\n  typeforce(types.String, asm);\n  return compile(asm.split(' ').map(chunkStr => {\n    // opcode?\n    if (ops_1.OPS[chunkStr] !== undefined) return ops_1.OPS[chunkStr];\n    typeforce(types.Hex, chunkStr);\n    // data!\n    return Buffer.from(chunkStr, 'hex');\n  }));\n}\nexports.fromASM = fromASM;\nfunction toStack(chunks) {\n  chunks = decompile(chunks);\n  typeforce(isPushOnly, chunks);\n  return chunks.map(op => {\n    if (singleChunkIsBuffer(op)) return op;\n    if (op === ops_1.OPS.OP_0) return Buffer.allocUnsafe(0);\n    return scriptNumber.encode(op - OP_INT_BASE);\n  });\n}\nexports.toStack = toStack;\nfunction isCanonicalPubKey(buffer) {\n  return types.isPoint(buffer);\n}\nexports.isCanonicalPubKey = isCanonicalPubKey;\nfunction isDefinedHashType(hashType) {\n  const hashTypeMod = hashType & ~0x80;\n  // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\nexports.isDefinedHashType = isDefinedHashType;\nfunction isCanonicalScriptSignature(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;\n  return bip66.check(buffer.slice(0, -1));\n}\nexports.isCanonicalScriptSignature = isCanonicalScriptSignature;\nexports.number = scriptNumber;\nexports.signature = scriptSignature;","map":{"version":3,"names":["Object","defineProperty","exports","value","signature","number","isCanonicalScriptSignature","isDefinedHashType","isCanonicalPubKey","toStack","fromASM","toASM","decompile","compile","countNonPushOnlyOPs","isPushOnly","OPS","bip66","require","ops_1","enumerable","get","pushdata","scriptNumber","scriptSignature","types","typeforce","OP_INT_BASE","OP_RESERVED","isOPInt","Number","OP_0","OP_1","OP_16","OP_1NEGATE","isPushOnlyChunk","Buffer","Array","every","length","filter","asMinimalOP","buffer","chunksIsBuffer","buf","isBuffer","chunksIsArray","singleChunkIsBuffer","chunks","bufferSize","reduce","accum","chunk","undefined","encodingLength","allocUnsafe","offset","forEach","opcode","writeUInt8","encode","copy","Error","i","OP_PUSHDATA4","d","decode","size","data","slice","op","push","map","toString","REVERSE_OPS","join","asm","String","split","chunkStr","Hex","from","isPoint","hashType","hashTypeMod","check"],"sources":["/workspace/Planq-Dapps/vesting-portal/node_modules/bitcoinjs-lib/src/script.js"],"sourcesContent":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.signature =\n  exports.number =\n  exports.isCanonicalScriptSignature =\n  exports.isDefinedHashType =\n  exports.isCanonicalPubKey =\n  exports.toStack =\n  exports.fromASM =\n  exports.toASM =\n  exports.decompile =\n  exports.compile =\n  exports.countNonPushOnlyOPs =\n  exports.isPushOnly =\n  exports.OPS =\n    void 0;\nconst bip66 = require('./bip66');\nconst ops_1 = require('./ops');\nObject.defineProperty(exports, 'OPS', {\n  enumerable: true,\n  get: function () {\n    return ops_1.OPS;\n  },\n});\nconst pushdata = require('./push_data');\nconst scriptNumber = require('./script_number');\nconst scriptSignature = require('./script_signature');\nconst types = require('./types');\nconst { typeforce } = types;\nconst OP_INT_BASE = ops_1.OPS.OP_RESERVED; // OP_1 - 1\nfunction isOPInt(value) {\n  return (\n    types.Number(value) &&\n    (value === ops_1.OPS.OP_0 ||\n      (value >= ops_1.OPS.OP_1 && value <= ops_1.OPS.OP_16) ||\n      value === ops_1.OPS.OP_1NEGATE)\n  );\n}\nfunction isPushOnlyChunk(value) {\n  return types.Buffer(value) || isOPInt(value);\n}\nfunction isPushOnly(value) {\n  return types.Array(value) && value.every(isPushOnlyChunk);\n}\nexports.isPushOnly = isPushOnly;\nfunction countNonPushOnlyOPs(value) {\n  return value.length - value.filter(isPushOnlyChunk).length;\n}\nexports.countNonPushOnlyOPs = countNonPushOnlyOPs;\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return ops_1.OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return ops_1.OPS.OP_1NEGATE;\n}\nfunction chunksIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\nfunction chunksIsArray(buf) {\n  return types.Array(buf);\n}\nfunction singleChunkIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\nfunction compile(chunks) {\n  // TODO: remove me\n  if (chunksIsBuffer(chunks)) return chunks;\n  typeforce(types.Array, chunks);\n  const bufferSize = chunks.reduce((accum, chunk) => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    }\n    // opcode\n    return accum + 1;\n  }, 0.0);\n  const buffer = Buffer.allocUnsafe(bufferSize);\n  let offset = 0;\n  chunks.forEach(chunk => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      const opcode = asMinimalOP(chunk);\n      if (opcode !== undefined) {\n        buffer.writeUInt8(opcode, offset);\n        offset += 1;\n        return;\n      }\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      chunk.copy(buffer, offset);\n      offset += chunk.length;\n      // opcode\n    } else {\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  });\n  if (offset !== buffer.length) throw new Error('Could not decode chunks');\n  return buffer;\n}\nexports.compile = compile;\nfunction decompile(buffer) {\n  // TODO: remove me\n  if (chunksIsArray(buffer)) return buffer;\n  typeforce(types.Buffer, buffer);\n  const chunks = [];\n  let i = 0;\n  while (i < buffer.length) {\n    const opcode = buffer[i];\n    // data chunk\n    if (opcode > ops_1.OPS.OP_0 && opcode <= ops_1.OPS.OP_PUSHDATA4) {\n      const d = pushdata.decode(buffer, i);\n      // did reading a pushDataInt fail?\n      if (d === null) return null;\n      i += d.size;\n      // attempt to read too much data?\n      if (i + d.number > buffer.length) return null;\n      const data = buffer.slice(i, i + d.number);\n      i += d.number;\n      // decompile minimally\n      const op = asMinimalOP(data);\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      }\n      // opcode\n    } else {\n      chunks.push(opcode);\n      i += 1;\n    }\n  }\n  return chunks;\n}\nexports.decompile = decompile;\nfunction toASM(chunks) {\n  if (chunksIsBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n  return chunks\n    .map(chunk => {\n      // data?\n      if (singleChunkIsBuffer(chunk)) {\n        const op = asMinimalOP(chunk);\n        if (op === undefined) return chunk.toString('hex');\n        chunk = op;\n      }\n      // opcode!\n      return ops_1.REVERSE_OPS[chunk];\n    })\n    .join(' ');\n}\nexports.toASM = toASM;\nfunction fromASM(asm) {\n  typeforce(types.String, asm);\n  return compile(\n    asm.split(' ').map(chunkStr => {\n      // opcode?\n      if (ops_1.OPS[chunkStr] !== undefined) return ops_1.OPS[chunkStr];\n      typeforce(types.Hex, chunkStr);\n      // data!\n      return Buffer.from(chunkStr, 'hex');\n    }),\n  );\n}\nexports.fromASM = fromASM;\nfunction toStack(chunks) {\n  chunks = decompile(chunks);\n  typeforce(isPushOnly, chunks);\n  return chunks.map(op => {\n    if (singleChunkIsBuffer(op)) return op;\n    if (op === ops_1.OPS.OP_0) return Buffer.allocUnsafe(0);\n    return scriptNumber.encode(op - OP_INT_BASE);\n  });\n}\nexports.toStack = toStack;\nfunction isCanonicalPubKey(buffer) {\n  return types.isPoint(buffer);\n}\nexports.isCanonicalPubKey = isCanonicalPubKey;\nfunction isDefinedHashType(hashType) {\n  const hashTypeMod = hashType & ~0x80;\n  // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\nexports.isDefinedHashType = isDefinedHashType;\nfunction isCanonicalScriptSignature(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;\n  return bip66.check(buffer.slice(0, -1));\n}\nexports.isCanonicalScriptSignature = isCanonicalScriptSignature;\nexports.number = scriptNumber;\nexports.signature = scriptSignature;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}