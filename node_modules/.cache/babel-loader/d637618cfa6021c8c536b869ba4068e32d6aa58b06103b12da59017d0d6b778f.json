{"ast":null,"code":"\"use strict\";\n\n/**\n * Generate a character map.\n * @param {string} alphabet e.g. \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"\n * @param {object} mappings map overrides from key to value\n * @method\n */\nvar charmap = function (alphabet, mappings) {\n  mappings || (mappings = {});\n  alphabet.split(\"\").forEach(function (c, i) {\n    if (!(c in mappings)) mappings[c] = i;\n  });\n  return mappings;\n};\n\n/**\n * The RFC 4648 base 32 alphabet and character map.\n * @see {@link https://tools.ietf.org/html/rfc4648}\n */\n\nvar rfc4648 = {\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n  charmap: {\n    0: 14,\n    1: 8\n  }\n};\nrfc4648.charmap = charmap(rfc4648.alphabet, rfc4648.charmap);\n\n/**\n * The Crockford base 32 alphabet and character map.\n * @see {@link http://www.crockford.com/wrmg/base32.html}\n */\n\nvar crockford = {\n  alphabet: \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\",\n  charmap: {\n    O: 0,\n    I: 1,\n    L: 1\n  }\n};\ncrockford.charmap = charmap(crockford.alphabet, crockford.charmap);\n\n/**\n * base32hex\n * @see {@link https://en.wikipedia.org/wiki/Base32#base32hex}\n */\n\nvar base32hex = {\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n  charmap: {}\n};\nbase32hex.charmap = charmap(base32hex.alphabet, base32hex.charmap);\n\n/**\n * Create a new `Decoder` with the given options.\n *\n * @param {object} [options]\n *   @param {string} [type] Supported Base-32 variants are \"rfc4648\" and\n *     \"crockford\".\n *   @param {object} [charmap] Override the character map used in decoding.\n * @constructor\n */\n\nfunction Decoder(options) {\n  this.buf = [];\n  this.shift = 8;\n  this.carry = 0;\n  if (options) {\n    switch (options.type) {\n      case \"rfc4648\":\n        this.charmap = exports.rfc4648.charmap;\n        break;\n      case \"crockford\":\n        this.charmap = exports.crockford.charmap;\n        break;\n      case \"base32hex\":\n        this.charmap = exports.base32hex.charmap;\n        break;\n      default:\n        throw new Error(\"invalid type\");\n    }\n    if (options.charmap) this.charmap = options.charmap;\n  }\n}\n\n/**\n * The default character map coresponds to RFC4648.\n */\n\nDecoder.prototype.charmap = rfc4648.charmap;\n\n/**\n * Decode a string, continuing from the previous state.\n *\n * @param {string} str\n * @return {Decoder} this\n */\n\nDecoder.prototype.write = function (str) {\n  var charmap = this.charmap;\n  var buf = this.buf;\n  var shift = this.shift;\n  var carry = this.carry;\n\n  // decode string\n  str.toUpperCase().split(\"\").forEach(function (char) {\n    // ignore padding\n    if (char == \"=\") return;\n\n    // lookup symbol\n    var symbol = charmap[char] & 0xff;\n\n    // 1: 00000 000\n    // 2:          00 00000 0\n    // 3:                    0000 0000\n    // 4:                             0 00000 00\n    // 5:                                       000 00000\n    // 6:                                                00000 000\n    // 7:                                                         00 00000 0\n\n    shift -= 5;\n    if (shift > 0) {\n      carry |= symbol << shift;\n    } else if (shift < 0) {\n      buf.push(carry | symbol >> -shift);\n      shift += 8;\n      carry = symbol << shift & 0xff;\n    } else {\n      buf.push(carry | symbol);\n      shift = 8;\n      carry = 0;\n    }\n  });\n\n  // save state\n  this.shift = shift;\n  this.carry = carry;\n\n  // for chaining\n  return this;\n};\n\n/**\n * Finish decoding.\n *\n * @param {string} [str] The final string to decode.\n * @return {Array} Decoded byte array.\n */\n\nDecoder.prototype.finalize = function (str) {\n  if (str) {\n    this.write(str);\n  }\n  if (this.shift !== 8 && this.carry !== 0) {\n    this.buf.push(this.carry);\n    this.shift = 8;\n    this.carry = 0;\n  }\n  return this.buf;\n};\n\n/**\n * Create a new `Encoder` with the given options.\n *\n * @param {object} [options]\n *   @param {string} [type] Supported Base-32 variants are \"rfc4648\" and\n *     \"crockford\".\n *   @param {object} [alphabet] Override the alphabet used in encoding.\n * @constructor\n */\n\nfunction Encoder(options) {\n  this.buf = \"\";\n  this.shift = 3;\n  this.carry = 0;\n  if (options) {\n    switch (options.type) {\n      case \"rfc4648\":\n        this.alphabet = exports.rfc4648.alphabet;\n        break;\n      case \"crockford\":\n        this.alphabet = exports.crockford.alphabet;\n        break;\n      case \"base32hex\":\n        this.alphabet = exports.base32hex.alphabet;\n        break;\n      default:\n        throw new Error(\"invalid type\");\n    }\n    if (options.alphabet) this.alphabet = options.alphabet;else if (options.lc) this.alphabet = this.alphabet.toLowerCase();\n  }\n}\n\n/**\n * The default alphabet coresponds to RFC4648.\n */\n\nEncoder.prototype.alphabet = rfc4648.alphabet;\n\n/**\n * Encode a byte array, continuing from the previous state.\n *\n * @param {byte[]} buf The byte array to encode.\n * @return {Encoder} this\n */\n\nEncoder.prototype.write = function (buf) {\n  var shift = this.shift;\n  var carry = this.carry;\n  var symbol;\n  var byte;\n  var i;\n\n  // encode each byte in buf\n  for (i = 0; i < buf.length; i++) {\n    byte = buf[i];\n\n    // 1: 00000 000\n    // 2:          00 00000 0\n    // 3:                    0000 0000\n    // 4:                             0 00000 00\n    // 5:                                       000 00000\n    // 6:                                                00000 000\n    // 7:                                                         00 00000 0\n\n    symbol = carry | byte >> shift;\n    this.buf += this.alphabet[symbol & 0x1f];\n    if (shift > 5) {\n      shift -= 5;\n      symbol = byte >> shift;\n      this.buf += this.alphabet[symbol & 0x1f];\n    }\n    shift = 5 - shift;\n    carry = byte << shift;\n    shift = 8 - shift;\n  }\n\n  // save state\n  this.shift = shift;\n  this.carry = carry;\n\n  // for chaining\n  return this;\n};\n\n/**\n * Finish encoding.\n *\n * @param {byte[]} [buf] The final byte array to encode.\n * @return {string} The encoded byte array.\n */\n\nEncoder.prototype.finalize = function (buf) {\n  if (buf) {\n    this.write(buf);\n  }\n  if (this.shift !== 3) {\n    this.buf += this.alphabet[this.carry & 0x1f];\n    this.shift = 3;\n    this.carry = 0;\n  }\n  return this.buf;\n};\n\n/**\n * Convenience encoder.\n *\n * @param {byte[]} buf The byte array to encode.\n * @param {object} [options] Options to pass to the encoder.\n * @return {string} The encoded string.\n */\n\nexports.encode = function (buf, options) {\n  return new Encoder(options).finalize(buf);\n};\n\n/**\n * Convenience decoder.\n *\n * @param {string} str The string to decode.\n * @param {object} [options] Options to pass to the decoder.\n * @return {byte[]} The decoded byte array.\n */\n\nexports.decode = function (str, options) {\n  return new Decoder(options).finalize(str);\n};\n\n// Exports.\nexports.Decoder = Decoder;\nexports.Encoder = Encoder;\nexports.charmap = charmap;\nexports.crockford = crockford;\nexports.rfc4648 = rfc4648;\nexports.base32hex = base32hex;","map":{"version":3,"names":["charmap","alphabet","mappings","split","forEach","c","i","rfc4648","crockford","O","I","L","base32hex","Decoder","options","buf","shift","carry","type","exports","Error","prototype","write","str","toUpperCase","char","symbol","push","finalize","Encoder","lc","toLowerCase","byte","length","encode","decode"],"sources":["/workspace/Planq-Dapps/vesting-portal/node_modules/base32.js/base32.js"],"sourcesContent":["\"use strict\";\n\n/**\n * Generate a character map.\n * @param {string} alphabet e.g. \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"\n * @param {object} mappings map overrides from key to value\n * @method\n */\n\nvar charmap = function (alphabet, mappings) {\n  mappings || (mappings = {});\n  alphabet.split(\"\").forEach(function (c, i) {\n    if (!(c in mappings)) mappings[c] = i;\n  });\n  return mappings;\n}\n\n/**\n * The RFC 4648 base 32 alphabet and character map.\n * @see {@link https://tools.ietf.org/html/rfc4648}\n */\n\nvar rfc4648 = {\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n  charmap: {\n    0: 14,\n    1: 8\n  }\n};\n\nrfc4648.charmap = charmap(rfc4648.alphabet, rfc4648.charmap);\n\n/**\n * The Crockford base 32 alphabet and character map.\n * @see {@link http://www.crockford.com/wrmg/base32.html}\n */\n\nvar crockford = {\n  alphabet: \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\",\n  charmap: {\n    O: 0,\n    I: 1,\n    L: 1\n  }\n};\n\ncrockford.charmap = charmap(crockford.alphabet, crockford.charmap);\n\n/**\n * base32hex\n * @see {@link https://en.wikipedia.org/wiki/Base32#base32hex}\n */\n\nvar base32hex = {\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n  charmap: {}\n};\n\nbase32hex.charmap = charmap(base32hex.alphabet, base32hex.charmap);\n\n/**\n * Create a new `Decoder` with the given options.\n *\n * @param {object} [options]\n *   @param {string} [type] Supported Base-32 variants are \"rfc4648\" and\n *     \"crockford\".\n *   @param {object} [charmap] Override the character map used in decoding.\n * @constructor\n */\n\nfunction Decoder (options) {\n  this.buf = [];\n  this.shift = 8;\n  this.carry = 0;\n\n  if (options) {\n\n    switch (options.type) {\n      case \"rfc4648\":\n        this.charmap = exports.rfc4648.charmap;\n        break;\n      case \"crockford\":\n        this.charmap = exports.crockford.charmap;\n        break;\n      case \"base32hex\":\n        this.charmap = exports.base32hex.charmap;\n        break;\n      default:\n        throw new Error(\"invalid type\");\n    }\n\n    if (options.charmap) this.charmap = options.charmap;\n  }\n}\n\n/**\n * The default character map coresponds to RFC4648.\n */\n\nDecoder.prototype.charmap = rfc4648.charmap;\n\n/**\n * Decode a string, continuing from the previous state.\n *\n * @param {string} str\n * @return {Decoder} this\n */\n\nDecoder.prototype.write = function (str) {\n  var charmap = this.charmap;\n  var buf = this.buf;\n  var shift = this.shift;\n  var carry = this.carry;\n\n  // decode string\n  str.toUpperCase().split(\"\").forEach(function (char) {\n\n    // ignore padding\n    if (char == \"=\") return;\n\n    // lookup symbol\n    var symbol = charmap[char] & 0xff;\n\n    // 1: 00000 000\n    // 2:          00 00000 0\n    // 3:                    0000 0000\n    // 4:                             0 00000 00\n    // 5:                                       000 00000\n    // 6:                                                00000 000\n    // 7:                                                         00 00000 0\n\n    shift -= 5;\n    if (shift > 0) {\n      carry |= symbol << shift;\n    } else if (shift < 0) {\n      buf.push(carry | (symbol >> -shift));\n      shift += 8;\n      carry = (symbol << shift) & 0xff;\n    } else {\n      buf.push(carry | symbol);\n      shift = 8;\n      carry = 0;\n    }\n  });\n\n  // save state\n  this.shift = shift;\n  this.carry = carry;\n\n  // for chaining\n  return this;\n};\n\n/**\n * Finish decoding.\n *\n * @param {string} [str] The final string to decode.\n * @return {Array} Decoded byte array.\n */\n\nDecoder.prototype.finalize = function (str) {\n  if (str) {\n    this.write(str);\n  }\n  if (this.shift !== 8 && this.carry !== 0) {\n    this.buf.push(this.carry);\n    this.shift = 8;\n    this.carry = 0;\n  }\n  return this.buf;\n};\n\n/**\n * Create a new `Encoder` with the given options.\n *\n * @param {object} [options]\n *   @param {string} [type] Supported Base-32 variants are \"rfc4648\" and\n *     \"crockford\".\n *   @param {object} [alphabet] Override the alphabet used in encoding.\n * @constructor\n */\n\nfunction Encoder (options) {\n  this.buf = \"\";\n  this.shift = 3;\n  this.carry = 0;\n\n  if (options) {\n\n    switch (options.type) {\n      case \"rfc4648\":\n        this.alphabet = exports.rfc4648.alphabet;\n        break;\n      case \"crockford\":\n        this.alphabet = exports.crockford.alphabet;\n        break;\n      case \"base32hex\":\n        this.alphabet = exports.base32hex.alphabet;\n        break;\n      default:\n        throw new Error(\"invalid type\");\n    }\n\n    if (options.alphabet) this.alphabet = options.alphabet;\n    else if (options.lc) this.alphabet = this.alphabet.toLowerCase();\n  }\n}\n\n/**\n * The default alphabet coresponds to RFC4648.\n */\n\nEncoder.prototype.alphabet = rfc4648.alphabet;\n\n/**\n * Encode a byte array, continuing from the previous state.\n *\n * @param {byte[]} buf The byte array to encode.\n * @return {Encoder} this\n */\n\nEncoder.prototype.write = function (buf) {\n  var shift = this.shift;\n  var carry = this.carry;\n  var symbol;\n  var byte;\n  var i;\n\n  // encode each byte in buf\n  for (i = 0; i < buf.length; i++) {\n    byte = buf[i];\n\n    // 1: 00000 000\n    // 2:          00 00000 0\n    // 3:                    0000 0000\n    // 4:                             0 00000 00\n    // 5:                                       000 00000\n    // 6:                                                00000 000\n    // 7:                                                         00 00000 0\n\n    symbol = carry | (byte >> shift);\n    this.buf += this.alphabet[symbol & 0x1f];\n\n    if (shift > 5) {\n      shift -= 5;\n      symbol = byte >> shift;\n      this.buf += this.alphabet[symbol & 0x1f];\n    }\n\n    shift = 5 - shift;\n    carry = byte << shift;\n    shift = 8 - shift;\n  }\n\n  // save state\n  this.shift = shift;\n  this.carry = carry;\n\n  // for chaining\n  return this;\n};\n\n/**\n * Finish encoding.\n *\n * @param {byte[]} [buf] The final byte array to encode.\n * @return {string} The encoded byte array.\n */\n\nEncoder.prototype.finalize = function (buf) {\n  if (buf) {\n    this.write(buf);\n  }\n  if (this.shift !== 3) {\n    this.buf += this.alphabet[this.carry & 0x1f];\n    this.shift = 3;\n    this.carry = 0;\n  }\n  return this.buf;\n};\n\n/**\n * Convenience encoder.\n *\n * @param {byte[]} buf The byte array to encode.\n * @param {object} [options] Options to pass to the encoder.\n * @return {string} The encoded string.\n */\n\nexports.encode = function (buf, options) {\n  return new Encoder(options).finalize(buf);\n};\n\n/**\n * Convenience decoder.\n *\n * @param {string} str The string to decode.\n * @param {object} [options] Options to pass to the decoder.\n * @return {byte[]} The decoded byte array.\n */\n\nexports.decode = function (str, options) {\n  return new Decoder(options).finalize(str);\n};\n\n// Exports.\nexports.Decoder = Decoder;\nexports.Encoder = Encoder;\nexports.charmap = charmap;\nexports.crockford = crockford;\nexports.rfc4648 = rfc4648;\nexports.base32hex = base32hex;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}