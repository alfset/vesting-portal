{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionBuilder = exports.TimeoutInfinite = exports.BASE_FEE = undefined;\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nexports.isValidDate = isValidDate;\nvar _jsXdr = require('js-xdr');\nvar _bignumber = require('bignumber.js');\nvar _bignumber2 = _interopRequireDefault(_bignumber);\nvar _clone = require('lodash/clone');\nvar _clone2 = _interopRequireDefault(_clone);\nvar _isUndefined = require('lodash/isUndefined');\nvar _isUndefined2 = _interopRequireDefault(_isUndefined);\nvar _isString = require('lodash/isString');\nvar _isString2 = _interopRequireDefault(_isString);\nvar _isArray = require('lodash/isArray');\nvar _isArray2 = _interopRequireDefault(_isArray);\nvar _xdr = require('./xdr');\nvar _xdr2 = _interopRequireDefault(_xdr);\nvar _transaction = require('./transaction');\nvar _fee_bump_transaction = require('./fee_bump_transaction');\nvar _signerkey = require('./signerkey');\nvar _memo = require('./memo');\nvar _decode_encode_muxed_account = require('./util/decode_encode_muxed_account');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/**\n * Minimum base fee for transactions. If this fee is below the network\n * minimum, the transaction will fail. The more operations in the\n * transaction, the greater the required fee. Use {@link\n * Server#fetchBaseFee} to get an accurate value of minimum transaction\n * fee on the network.\n *\n * @constant\n * @see [Fees](https://developers.stellar.org/docs/glossary/fees/)\n */\nvar BASE_FEE = exports.BASE_FEE = '100'; // Stroops\n\n/**\n * @constant\n * @see {@link TransactionBuilder#setTimeout}\n * @see [Timeout](https://developers.stellar.org/api/resources/transactions/post/)\n */\nvar TimeoutInfinite = exports.TimeoutInfinite = 0;\n\n/**\n * <p>Transaction builder helps constructs a new `{@link Transaction}` using the\n * given {@link Account} as the transaction's \"source account\". The transaction\n * will use the current sequence number of the given account as its sequence\n * number and increment the given account's sequence number by one. The given\n * source account must include a private key for signing the transaction or an\n * error will be thrown.</p>\n *\n * <p>Operations can be added to the transaction via their corresponding builder\n * methods, and each returns the TransactionBuilder object so they can be\n * chained together. After adding the desired operations, call the `build()`\n * method on the `TransactionBuilder` to return a fully constructed `{@link\n * Transaction}` that can be signed. The returned transaction will contain the\n * sequence number of the source account and include the signature from the\n * source account.</p>\n *\n * <p><strong>Be careful about unsubmitted transactions!</strong> When you build\n * a transaction, stellar-sdk automatically increments the source account's\n * sequence number. If you end up not submitting this transaction and submitting\n * another one instead, it'll fail due to the sequence number being wrong. So if\n * you decide not to use a built transaction, make sure to update the source\n * account's sequence number with\n * [Server.loadAccount](https://stellar.github.io/js-stellar-sdk/Server.html#loadAccount)\n * before creating another transaction.</p>\n *\n * <p>The following code example creates a new transaction with {@link\n * Operation.createAccount} and {@link Operation.payment} operations. The\n * Transaction's source account first funds `destinationA`, then sends a payment\n * to `destinationB`. The built transaction is then signed by\n * `sourceKeypair`.</p>\n *\n * ```\n * var transaction = new TransactionBuilder(source, { fee, networkPassphrase: Networks.TESTNET })\n * .addOperation(Operation.createAccount({\n *     destination: destinationA,\n *     startingBalance: \"20\"\n * })) // <- funds and creates destinationA\n * .addOperation(Operation.payment({\n *     destination: destinationB,\n *     amount: \"100\",\n *     asset: Asset.native()\n * })) // <- sends 100 XLM to destinationB\n * .setTimeout(30)\n * .build();\n *\n * transaction.sign(sourceKeypair);\n * ```\n *\n * @constructor\n *\n * @param {Account} sourceAccount - source account for this transaction\n * @param {object}  opts          - Options object\n * @param {string}  opts.fee      - max fee you're willing to pay per\n *     operation in this transaction (**in stroops**)\n *\n * @param {object}              [opts.timebounds] - timebounds for the\n *     validity of this transaction\n * @param {number|string|Date}  [opts.timebounds.minTime] - 64-bit UNIX\n *     timestamp or Date object\n * @param {number|string|Date}  [opts.timebounds.maxTime] - 64-bit UNIX\n *     timestamp or Date object\n * @param {object}              [opts.ledgerbounds] - ledger bounds for the\n *     validity of this transaction\n * @param {number}              [opts.ledgerbounds.minLedger] - number of the minimum\n *     ledger sequence\n * @param {number}              [opts.ledgerbounds.maxLedger] - number of the maximum\n *     ledger sequence\n * @param {string}              [opts.minAccountSequence] - number for\n *     the minimum account sequence\n * @param {number}              [opts.minAccountSequenceAge] - number of\n *     seconds for the minimum account sequence age\n * @param {number}              [opts.minAccountSequenceLedgerGap] - number of\n *     ledgers for the minimum account sequence ledger gap\n * @param {string[]}            [opts.extraSigners] - list of the extra signers\n *     required for this transaction\n * @param {Memo}                [opts.memo] - memo for the transaction\n * @param {string}              [opts.networkPassphrase] passphrase of the\n *     target Stellar network (e.g. \"Public Global Stellar Network ; September\n *     2015\" for the pubnet)\n */\n\nvar TransactionBuilder = exports.TransactionBuilder = function () {\n  function TransactionBuilder(sourceAccount) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, TransactionBuilder);\n    if (!sourceAccount) {\n      throw new Error('must specify source account for the transaction');\n    }\n    if ((0, _isUndefined2.default)(opts.fee)) {\n      throw new Error('must specify fee for the transaction (in stroops)');\n    }\n    this.source = sourceAccount;\n    this.operations = [];\n    this.baseFee = opts.fee;\n    this.timebounds = (0, _clone2.default)(opts.timebounds) || null;\n    this.ledgerbounds = (0, _clone2.default)(opts.ledgerbounds) || null;\n    this.minAccountSequence = opts.minAccountSequence || null;\n    this.minAccountSequenceAge = opts.minAccountSequenceAge || null;\n    this.minAccountSequenceLedgerGap = opts.minAccountSequenceLedgerGap || null;\n    this.extraSigners = (0, _clone2.default)(opts.extraSigners) || null;\n    this.memo = opts.memo || _memo.Memo.none();\n    this.networkPassphrase = opts.networkPassphrase || null;\n  }\n\n  /**\n   * Adds an operation to the transaction.\n   *\n   * @param {xdr.Operation} operation   The xdr operation object, use {@link\n   *     Operation} static methods.\n   *\n   * @returns {TransactionBuilder}\n   */\n\n  _createClass(TransactionBuilder, [{\n    key: 'addOperation',\n    value: function addOperation(operation) {\n      this.operations.push(operation);\n      return this;\n    }\n\n    /**\n     * Adds a memo to the transaction.\n     * @param {Memo} memo {@link Memo} object\n     * @returns {TransactionBuilder}\n     */\n  }, {\n    key: 'addMemo',\n    value: function addMemo(memo) {\n      this.memo = memo;\n      return this;\n    }\n\n    /**\n     * Sets a timeout precondition on the transaction.\n     *\n     *  Because of the distributed nature of the Stellar network it is possible\n     *  that the status of your transaction will be determined after a long time\n     *  if the network is highly congested. If you want to be sure to receive the\n     *  status of the transaction within a given period you should set the {@link\n     *  TimeBounds} with `maxTime` on the transaction (this is what `setTimeout`\n     *  does internally; if there's `minTime` set but no `maxTime` it will be\n     *  added).\n     *\n     *  A call to `TransactionBuilder.setTimeout` is **required** if Transaction\n     *  does not have `max_time` set. If you don't want to set timeout, use\n     *  `{@link TimeoutInfinite}`. In general you should set `{@link\n     *  TimeoutInfinite}` only in smart contracts.\n     *\n     *  Please note that Horizon may still return <code>504 Gateway Timeout</code>\n     *  error, even for short timeouts. In such case you need to resubmit the same\n     *  transaction again without making any changes to receive a status. This\n     *  method is using the machine system time (UTC), make sure it is set\n     *  correctly.\n     *\n     * @param {number} timeoutSeconds   Number of seconds the transaction is good.\n     *     Can't be negative. If the value is {@link TimeoutInfinite}, the\n     *     transaction is good indefinitely.\n     *\n     * @returns {TransactionBuilder}\n     *\n     * @see {@link TimeoutInfinite}\n     * @see https://developers.stellar.org/docs/tutorials/handling-errors/\n     */\n  }, {\n    key: 'setTimeout',\n    value: function setTimeout(timeoutSeconds) {\n      if (this.timebounds !== null && this.timebounds.maxTime > 0) {\n        throw new Error('TimeBounds.max_time has been already set - setting timeout would overwrite it.');\n      }\n      if (timeoutSeconds < 0) {\n        throw new Error('timeout cannot be negative');\n      }\n      if (timeoutSeconds > 0) {\n        var timeoutTimestamp = Math.floor(Date.now() / 1000) + timeoutSeconds;\n        if (this.timebounds === null) {\n          this.timebounds = {\n            minTime: 0,\n            maxTime: timeoutTimestamp\n          };\n        } else {\n          this.timebounds = {\n            minTime: this.timebounds.minTime,\n            maxTime: timeoutTimestamp\n          };\n        }\n      } else {\n        this.timebounds = {\n          minTime: 0,\n          maxTime: 0\n        };\n      }\n      return this;\n    }\n\n    /**\n     * If you want to prepare a transaction which will become valid at some point\n     * in the future, or be invalid after some time, you can set a timebounds\n     * precondition. Internally this will set the `minTime`, and `maxTime`\n     * preconditions. Conflicts with `setTimeout`, so use one or the other.\n     *\n     * @param {Date|number} minEpochOrDate  Either a JS Date object, or a number\n     *     of UNIX epoch seconds. The transaction is valid after this timestamp.\n     *     Can't be negative. If the value is `0`, the transaction is valid\n     *     immediately.\n     * @param {Date|number} maxEpochOrDate  Either a JS Date object, or a number\n     *     of UNIX epoch seconds. The transaction is valid until this timestamp.\n     *     Can't be negative. If the value is `0`, the transaction is valid\n     *     indefinitely.\n     *\n     * @returns {TransactionBuilder}\n     */\n  }, {\n    key: 'setTimebounds',\n    value: function setTimebounds(minEpochOrDate, maxEpochOrDate) {\n      // Force it to a date type\n      if (typeof minEpochOrDate === 'number') {\n        minEpochOrDate = new Date(minEpochOrDate * 1000);\n      }\n      if (typeof maxEpochOrDate === 'number') {\n        maxEpochOrDate = new Date(maxEpochOrDate * 1000);\n      }\n      if (this.timebounds !== null) {\n        throw new Error('TimeBounds has been already set - setting timebounds would overwrite it.');\n      }\n\n      // Convert that date to the epoch seconds\n      var minTime = Math.floor(minEpochOrDate.valueOf() / 1000);\n      var maxTime = Math.floor(maxEpochOrDate.valueOf() / 1000);\n      if (minTime < 0) {\n        throw new Error('min_time cannot be negative');\n      }\n      if (maxTime < 0) {\n        throw new Error('max_time cannot be negative');\n      }\n      if (maxTime > 0 && minTime > maxTime) {\n        throw new Error('min_time cannot be greater than max_time');\n      }\n      this.timebounds = {\n        minTime: minTime,\n        maxTime: maxTime\n      };\n      return this;\n    }\n\n    /**\n     * If you want to prepare a transaction which will only be valid within some\n     * range of ledgers, you can set a ledgerbounds precondition.\n     * Internally this will set the `minLedger` and `maxLedger` preconditions.\n     *\n     * @param {number} minLedger  The minimum ledger this transaction is valid at\n     *     or after. Cannot be negative. If the value is `0` (the default), the\n     *     transaction is valid immediately.\n     *\n     * @param {number} maxLedger  The maximum ledger this transaction is valid\n     *     before. Cannot be negative. If the value is `0`, the transaction is\n     *     valid indefinitely.\n     *\n     * @returns {TransactionBuilder}\n     */\n  }, {\n    key: 'setLedgerbounds',\n    value: function setLedgerbounds(minLedger, maxLedger) {\n      if (this.ledgerbounds !== null) {\n        throw new Error('LedgerBounds has been already set - setting ledgerbounds would overwrite it.');\n      }\n      if (minLedger < 0) {\n        throw new Error('min_ledger cannot be negative');\n      }\n      if (maxLedger < 0) {\n        throw new Error('max_ledger cannot be negative');\n      }\n      if (maxLedger > 0 && minLedger > maxLedger) {\n        throw new Error('min_ledger cannot be greater than max_ledger');\n      }\n      this.ledgerbounds = {\n        minLedger: minLedger,\n        maxLedger: maxLedger\n      };\n      return this;\n    }\n\n    /**\n     * If you want to prepare a transaction which will be valid only while the\n     * account sequence number is\n     *\n     *     minAccountSequence <= sourceAccountSequence < tx.seqNum\n     *\n     * Note that after execution the account's sequence number is always raised to\n     * `tx.seqNum`. Internally this will set the `minAccountSequence`\n     * precondition.\n     *\n     * @param {string} minAccountSequence   The minimum source account sequence\n     *     number this transaction is valid for. If the value is `0` (the\n     *     default), the transaction is valid when `sourceAccount's sequence\n     *     number == tx.seqNum- 1`.\n     *\n     * @returns {TransactionBuilder}\n     */\n  }, {\n    key: 'setMinAccountSequence',\n    value: function setMinAccountSequence(minAccountSequence) {\n      if (this.minAccountSequence !== null) {\n        throw new Error('min_account_sequence has been already set - setting min_account_sequence would overwrite it.');\n      }\n      this.minAccountSequence = minAccountSequence;\n      return this;\n    }\n\n    /**\n     * For the transaction to be valid, the current ledger time must be at least\n     * `minAccountSequenceAge` greater than sourceAccount's `sequenceTime`.\n     * Internally this will set the `minAccountSequenceAge` precondition.\n     *\n     * @param {number} durationInSeconds  The minimum amount of time between\n     *     source account sequence time and the ledger time when this transaction\n     *     will become valid. If the value is `0`, the transaction is unrestricted\n     *     by the account sequence age. Cannot be negative.\n     *\n     * @returns {TransactionBuilder}\n     */\n  }, {\n    key: 'setMinAccountSequenceAge',\n    value: function setMinAccountSequenceAge(durationInSeconds) {\n      if (typeof durationInSeconds !== 'number') {\n        throw new Error('min_account_sequence_age must be a number');\n      }\n      if (this.minAccountSequenceAge !== null) {\n        throw new Error('min_account_sequence_age has been already set - setting min_account_sequence_age would overwrite it.');\n      }\n      if (durationInSeconds < 0) {\n        throw new Error('min_account_sequence_age cannot be negative');\n      }\n      this.minAccountSequenceAge = durationInSeconds;\n      return this;\n    }\n\n    /**\n     * For the transaction to be valid, the current ledger number must be at least\n     * `minAccountSequenceLedgerGap` greater than sourceAccount's ledger sequence.\n     * Internally this will set the `minAccountSequenceLedgerGap` precondition.\n     *\n     * @param {number} gap  The minimum number of ledgers between source account\n     *     sequence and the ledger number when this transaction will become valid.\n     *     If the value is `0`, the transaction is unrestricted by the account\n     *     sequence ledger. Cannot be negative.\n     *\n     * @returns {TransactionBuilder}\n     */\n  }, {\n    key: 'setMinAccountSequenceLedgerGap',\n    value: function setMinAccountSequenceLedgerGap(gap) {\n      if (this.minAccountSequenceLedgerGap !== null) {\n        throw new Error('min_account_sequence_ledger_gap has been already set - setting min_account_sequence_ledger_gap would overwrite it.');\n      }\n      if (gap < 0) {\n        throw new Error('min_account_sequence_ledger_gap cannot be negative');\n      }\n      this.minAccountSequenceLedgerGap = gap;\n      return this;\n    }\n\n    /**\n     * For the transaction to be valid, there must be a signature corresponding to\n     * every Signer in this array, even if the signature is not otherwise required\n     * by the sourceAccount or operations. Internally this will set the\n     * `extraSigners` precondition.\n     *\n     * @param {string[]} extraSigners   required extra signers (as {@link StrKey}s)\n     *\n     * @returns {TransactionBuilder}\n     */\n  }, {\n    key: 'setExtraSigners',\n    value: function setExtraSigners(extraSigners) {\n      if (!(0, _isArray2.default)(extraSigners)) {\n        throw new Error('extra_signers must be an array of strings.');\n      }\n      if (this.extraSigners !== null) {\n        throw new Error('extra_signers has been already set - setting extra_signers would overwrite it.');\n      }\n      if (extraSigners.length > 2) {\n        throw new Error('extra_signers cannot be longer than 2 elements.');\n      }\n      this.extraSigners = (0, _clone2.default)(extraSigners);\n      return this;\n    }\n\n    /**\n     * Set network nassphrase for the Transaction that will be built.\n     *\n     * @param {string} networkPassphrase    passphrase of the target Stellar\n     *     network (e.g. \"Public Global Stellar Network ; September 2015\").\n     *\n     * @returns {TransactionBuilder}\n     */\n  }, {\n    key: 'setNetworkPassphrase',\n    value: function setNetworkPassphrase(networkPassphrase) {\n      this.networkPassphrase = networkPassphrase;\n      return this;\n    }\n\n    /**\n     * This will build the transaction.\n     * It will also increment the source account's sequence number by 1.\n     * @returns {Transaction} This method will return the built {@link Transaction}.\n     */\n  }, {\n    key: 'build',\n    value: function build() {\n      var sequenceNumber = new _bignumber2.default(this.source.sequenceNumber()).add(1);\n      var fee = new _bignumber2.default(this.baseFee).mul(this.operations.length).toNumber();\n      var attrs = {\n        fee: fee,\n        seqNum: _xdr2.default.SequenceNumber.fromString(sequenceNumber.toString()),\n        memo: this.memo ? this.memo.toXDRObject() : null\n      };\n      if (this.timebounds === null || typeof this.timebounds.minTime === 'undefined' || typeof this.timebounds.maxTime === 'undefined') {\n        throw new Error('TimeBounds has to be set or you must call setTimeout(TimeoutInfinite).');\n      }\n      if (isValidDate(this.timebounds.minTime)) {\n        this.timebounds.minTime = this.timebounds.minTime.getTime() / 1000;\n      }\n      if (isValidDate(this.timebounds.maxTime)) {\n        this.timebounds.maxTime = this.timebounds.maxTime.getTime() / 1000;\n      }\n      this.timebounds.minTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.minTime.toString());\n      this.timebounds.maxTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.maxTime.toString());\n      var timeBounds = new _xdr2.default.TimeBounds(this.timebounds);\n      if (this.hasV2Preconditions()) {\n        var ledgerBounds = null;\n        if (this.ledgerbounds !== null) {\n          ledgerBounds = new _xdr2.default.LedgerBounds(this.ledgerbounds);\n        }\n        var minSeqNum = this.minAccountSequence || '0';\n        minSeqNum = _xdr2.default.SequenceNumber.fromString(minSeqNum);\n        var minSeqAge = _jsXdr.UnsignedHyper.fromString(this.minAccountSequenceAge !== null ? this.minAccountSequenceAge.toString() : '0');\n        var minSeqLedgerGap = this.minAccountSequenceLedgerGap || 0;\n        var extraSigners = this.extraSigners !== null ? this.extraSigners.map(_signerkey.SignerKey.decodeAddress) : [];\n        attrs.cond = _xdr2.default.Preconditions.precondV2(new _xdr2.default.PreconditionsV2({\n          timeBounds: timeBounds,\n          ledgerBounds: ledgerBounds,\n          minSeqNum: minSeqNum,\n          minSeqAge: minSeqAge,\n          minSeqLedgerGap: minSeqLedgerGap,\n          extraSigners: extraSigners\n        }));\n      } else {\n        attrs.cond = _xdr2.default.Preconditions.precondTime(timeBounds);\n      }\n      attrs.sourceAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(this.source.accountId());\n      attrs.ext = new _xdr2.default.TransactionExt(0);\n      var xtx = new _xdr2.default.Transaction(attrs);\n      xtx.operations(this.operations);\n      var txEnvelope = new _xdr2.default.TransactionEnvelope.envelopeTypeTx(new _xdr2.default.TransactionV1Envelope({\n        tx: xtx\n      }));\n      var tx = new _transaction.Transaction(txEnvelope, this.networkPassphrase);\n      this.source.incrementSequenceNumber();\n      return tx;\n    }\n  }, {\n    key: 'hasV2Preconditions',\n    value: function hasV2Preconditions() {\n      return this.ledgerbounds !== null || this.minAccountSequence !== null || this.minAccountSequenceAge !== null || this.minAccountSequenceLedgerGap !== null || this.extraSigners !== null && this.extraSigners.length > 0;\n    }\n\n    /**\n     * Builds a {@link FeeBumpTransaction}, enabling you to resubmit an existing\n     * transaction with a higher fee.\n     *\n     * @param {Keypair|string}  feeSource - account paying for the transaction,\n     *     in the form of either a Keypair (only the public key is used) or\n     *     an account ID (in G... or M... form, but refer to `withMuxing`)\n     * @param {string}          baseFee   - max fee willing to pay per operation\n     *     in inner transaction (**in stroops**)\n     * @param {Transaction}     innerTx   - {@link Transaction} to be bumped by\n     *     the fee bump transaction\n     * @param {string}          networkPassphrase - passphrase of the target\n     *     Stellar network (e.g. \"Public Global Stellar Network ; September 2015\",\n     *     see {@link Networks})\n     *\n     * @todo Alongside the next major version bump, this type signature can be\n     *       changed to be less awkward: accept a MuxedAccount as the `feeSource`\n     *       rather than a keypair or string.\n     *\n     * @note Your fee-bump amount should be >= 10x the original fee.\n     * @see  https://developers.stellar.org/docs/glossary/fee-bumps/#replace-by-fee\n     *\n     * @returns {FeeBumpTransaction}\n     */\n  }], [{\n    key: 'buildFeeBumpTransaction',\n    value: function buildFeeBumpTransaction(feeSource, baseFee, innerTx, networkPassphrase) {\n      var innerOps = innerTx.operations.length;\n      var innerBaseFeeRate = new _bignumber2.default(innerTx.fee).div(innerOps);\n      var base = new _bignumber2.default(baseFee);\n\n      // The fee rate for fee bump is at least the fee rate of the inner transaction\n      if (base.lessThan(innerBaseFeeRate)) {\n        throw new Error('Invalid baseFee, it should be at least ' + innerBaseFeeRate + ' stroops.');\n      }\n      var minBaseFee = new _bignumber2.default(BASE_FEE);\n\n      // The fee rate is at least the minimum fee\n      if (base.lessThan(minBaseFee)) {\n        throw new Error('Invalid baseFee, it should be at least ' + minBaseFee + ' stroops.');\n      }\n      var innerTxEnvelope = innerTx.toEnvelope();\n      if (innerTxEnvelope.switch() === _xdr2.default.EnvelopeType.envelopeTypeTxV0()) {\n        var v0Tx = innerTxEnvelope.v0().tx();\n        var v1Tx = new _xdr2.default.Transaction({\n          sourceAccount: new _xdr2.default.MuxedAccount.keyTypeEd25519(v0Tx.sourceAccountEd25519()),\n          fee: v0Tx.fee(),\n          seqNum: v0Tx.seqNum(),\n          cond: _xdr2.default.Preconditions.precondTime(v0Tx.timeBounds()),\n          memo: v0Tx.memo(),\n          operations: v0Tx.operations(),\n          ext: new _xdr2.default.TransactionExt(0)\n        });\n        innerTxEnvelope = new _xdr2.default.TransactionEnvelope.envelopeTypeTx(new _xdr2.default.TransactionV1Envelope({\n          tx: v1Tx,\n          signatures: innerTxEnvelope.v0().signatures()\n        }));\n      }\n      var feeSourceAccount = void 0;\n      if ((0, _isString2.default)(feeSource)) {\n        feeSourceAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(feeSource);\n      } else {\n        feeSourceAccount = feeSource.xdrMuxedAccount();\n      }\n      var tx = new _xdr2.default.FeeBumpTransaction({\n        feeSource: feeSourceAccount,\n        fee: _xdr2.default.Int64.fromString(base.mul(innerOps + 1).toString()),\n        innerTx: _xdr2.default.FeeBumpTransactionInnerTx.envelopeTypeTx(innerTxEnvelope.v1()),\n        ext: new _xdr2.default.FeeBumpTransactionExt(0)\n      });\n      var feeBumpTxEnvelope = new _xdr2.default.FeeBumpTransactionEnvelope({\n        tx: tx,\n        signatures: []\n      });\n      var envelope = new _xdr2.default.TransactionEnvelope.envelopeTypeTxFeeBump(feeBumpTxEnvelope);\n      return new _fee_bump_transaction.FeeBumpTransaction(envelope, networkPassphrase);\n    }\n\n    /**\n     * Build a {@link Transaction} or {@link FeeBumpTransaction} from an\n     * xdr.TransactionEnvelope.\n     *\n     * @param {string|xdr.TransactionEnvelope} envelope - The transaction envelope\n     *     object or base64 encoded string.\n     * @param {string} networkPassphrase - The network passphrase of the target\n     *     Stellar network (e.g. \"Public Global Stellar Network ; September\n     *     2015\"), see {@link Networks}.\n     *\n     * @returns {Transaction|FeeBumpTransaction}\n     */\n  }, {\n    key: 'fromXDR',\n    value: function fromXDR(envelope, networkPassphrase) {\n      if (typeof envelope === 'string') {\n        envelope = _xdr2.default.TransactionEnvelope.fromXDR(envelope, 'base64');\n      }\n      if (envelope.switch() === _xdr2.default.EnvelopeType.envelopeTypeTxFeeBump()) {\n        return new _fee_bump_transaction.FeeBumpTransaction(envelope, networkPassphrase);\n      }\n      return new _transaction.Transaction(envelope, networkPassphrase);\n    }\n  }]);\n  return TransactionBuilder;\n}();\n\n/**\n * Checks whether a provided object is a valid Date.\n * @argument {Date} d date object\n * @returns {boolean}\n */\n\nfunction isValidDate(d) {\n  // isnan is okay here because it correctly checks for invalid date objects\n  // eslint-disable-next-line no-restricted-globals\n  return d instanceof Date && !isNaN(d);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","TransactionBuilder","TimeoutInfinite","BASE_FEE","undefined","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","Constructor","protoProps","staticProps","prototype","isValidDate","_jsXdr","require","_bignumber","_bignumber2","_interopRequireDefault","_clone","_clone2","_isUndefined","_isUndefined2","_isString","_isString2","_isArray","_isArray2","_xdr","_xdr2","_transaction","_fee_bump_transaction","_signerkey","_memo","_decode_encode_muxed_account","obj","__esModule","default","_classCallCheck","instance","TypeError","sourceAccount","opts","arguments","Error","fee","source","operations","baseFee","timebounds","ledgerbounds","minAccountSequence","minAccountSequenceAge","minAccountSequenceLedgerGap","extraSigners","memo","Memo","none","networkPassphrase","addOperation","operation","push","addMemo","setTimeout","timeoutSeconds","maxTime","timeoutTimestamp","Math","floor","Date","now","minTime","setTimebounds","minEpochOrDate","maxEpochOrDate","valueOf","setLedgerbounds","minLedger","maxLedger","setMinAccountSequence","setMinAccountSequenceAge","durationInSeconds","setMinAccountSequenceLedgerGap","gap","setExtraSigners","setNetworkPassphrase","build","sequenceNumber","add","mul","toNumber","attrs","seqNum","SequenceNumber","fromString","toString","toXDRObject","getTime","UnsignedHyper","timeBounds","TimeBounds","hasV2Preconditions","ledgerBounds","LedgerBounds","minSeqNum","minSeqAge","minSeqLedgerGap","map","SignerKey","decodeAddress","cond","Preconditions","precondV2","PreconditionsV2","precondTime","decodeAddressToMuxedAccount","accountId","ext","TransactionExt","xtx","Transaction","txEnvelope","TransactionEnvelope","envelopeTypeTx","TransactionV1Envelope","tx","incrementSequenceNumber","buildFeeBumpTransaction","feeSource","innerTx","innerOps","innerBaseFeeRate","div","base","lessThan","minBaseFee","innerTxEnvelope","toEnvelope","switch","EnvelopeType","envelopeTypeTxV0","v0Tx","v0","v1Tx","MuxedAccount","keyTypeEd25519","sourceAccountEd25519","signatures","feeSourceAccount","xdrMuxedAccount","FeeBumpTransaction","Int64","FeeBumpTransactionInnerTx","v1","FeeBumpTransactionExt","feeBumpTxEnvelope","FeeBumpTransactionEnvelope","envelope","envelopeTypeTxFeeBump","fromXDR","d","isNaN"],"sources":["/workspace/Planq-Dapps/vesting-portal/node_modules/stellar-base/lib/transaction_builder.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionBuilder = exports.TimeoutInfinite = exports.BASE_FEE = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.isValidDate = isValidDate;\n\nvar _jsXdr = require('js-xdr');\n\nvar _bignumber = require('bignumber.js');\n\nvar _bignumber2 = _interopRequireDefault(_bignumber);\n\nvar _clone = require('lodash/clone');\n\nvar _clone2 = _interopRequireDefault(_clone);\n\nvar _isUndefined = require('lodash/isUndefined');\n\nvar _isUndefined2 = _interopRequireDefault(_isUndefined);\n\nvar _isString = require('lodash/isString');\n\nvar _isString2 = _interopRequireDefault(_isString);\n\nvar _isArray = require('lodash/isArray');\n\nvar _isArray2 = _interopRequireDefault(_isArray);\n\nvar _xdr = require('./xdr');\n\nvar _xdr2 = _interopRequireDefault(_xdr);\n\nvar _transaction = require('./transaction');\n\nvar _fee_bump_transaction = require('./fee_bump_transaction');\n\nvar _signerkey = require('./signerkey');\n\nvar _memo = require('./memo');\n\nvar _decode_encode_muxed_account = require('./util/decode_encode_muxed_account');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Minimum base fee for transactions. If this fee is below the network\n * minimum, the transaction will fail. The more operations in the\n * transaction, the greater the required fee. Use {@link\n * Server#fetchBaseFee} to get an accurate value of minimum transaction\n * fee on the network.\n *\n * @constant\n * @see [Fees](https://developers.stellar.org/docs/glossary/fees/)\n */\nvar BASE_FEE = exports.BASE_FEE = '100'; // Stroops\n\n/**\n * @constant\n * @see {@link TransactionBuilder#setTimeout}\n * @see [Timeout](https://developers.stellar.org/api/resources/transactions/post/)\n */\nvar TimeoutInfinite = exports.TimeoutInfinite = 0;\n\n/**\n * <p>Transaction builder helps constructs a new `{@link Transaction}` using the\n * given {@link Account} as the transaction's \"source account\". The transaction\n * will use the current sequence number of the given account as its sequence\n * number and increment the given account's sequence number by one. The given\n * source account must include a private key for signing the transaction or an\n * error will be thrown.</p>\n *\n * <p>Operations can be added to the transaction via their corresponding builder\n * methods, and each returns the TransactionBuilder object so they can be\n * chained together. After adding the desired operations, call the `build()`\n * method on the `TransactionBuilder` to return a fully constructed `{@link\n * Transaction}` that can be signed. The returned transaction will contain the\n * sequence number of the source account and include the signature from the\n * source account.</p>\n *\n * <p><strong>Be careful about unsubmitted transactions!</strong> When you build\n * a transaction, stellar-sdk automatically increments the source account's\n * sequence number. If you end up not submitting this transaction and submitting\n * another one instead, it'll fail due to the sequence number being wrong. So if\n * you decide not to use a built transaction, make sure to update the source\n * account's sequence number with\n * [Server.loadAccount](https://stellar.github.io/js-stellar-sdk/Server.html#loadAccount)\n * before creating another transaction.</p>\n *\n * <p>The following code example creates a new transaction with {@link\n * Operation.createAccount} and {@link Operation.payment} operations. The\n * Transaction's source account first funds `destinationA`, then sends a payment\n * to `destinationB`. The built transaction is then signed by\n * `sourceKeypair`.</p>\n *\n * ```\n * var transaction = new TransactionBuilder(source, { fee, networkPassphrase: Networks.TESTNET })\n * .addOperation(Operation.createAccount({\n *     destination: destinationA,\n *     startingBalance: \"20\"\n * })) // <- funds and creates destinationA\n * .addOperation(Operation.payment({\n *     destination: destinationB,\n *     amount: \"100\",\n *     asset: Asset.native()\n * })) // <- sends 100 XLM to destinationB\n * .setTimeout(30)\n * .build();\n *\n * transaction.sign(sourceKeypair);\n * ```\n *\n * @constructor\n *\n * @param {Account} sourceAccount - source account for this transaction\n * @param {object}  opts          - Options object\n * @param {string}  opts.fee      - max fee you're willing to pay per\n *     operation in this transaction (**in stroops**)\n *\n * @param {object}              [opts.timebounds] - timebounds for the\n *     validity of this transaction\n * @param {number|string|Date}  [opts.timebounds.minTime] - 64-bit UNIX\n *     timestamp or Date object\n * @param {number|string|Date}  [opts.timebounds.maxTime] - 64-bit UNIX\n *     timestamp or Date object\n * @param {object}              [opts.ledgerbounds] - ledger bounds for the\n *     validity of this transaction\n * @param {number}              [opts.ledgerbounds.minLedger] - number of the minimum\n *     ledger sequence\n * @param {number}              [opts.ledgerbounds.maxLedger] - number of the maximum\n *     ledger sequence\n * @param {string}              [opts.minAccountSequence] - number for\n *     the minimum account sequence\n * @param {number}              [opts.minAccountSequenceAge] - number of\n *     seconds for the minimum account sequence age\n * @param {number}              [opts.minAccountSequenceLedgerGap] - number of\n *     ledgers for the minimum account sequence ledger gap\n * @param {string[]}            [opts.extraSigners] - list of the extra signers\n *     required for this transaction\n * @param {Memo}                [opts.memo] - memo for the transaction\n * @param {string}              [opts.networkPassphrase] passphrase of the\n *     target Stellar network (e.g. \"Public Global Stellar Network ; September\n *     2015\" for the pubnet)\n */\n\nvar TransactionBuilder = exports.TransactionBuilder = function () {\n  function TransactionBuilder(sourceAccount) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, TransactionBuilder);\n\n    if (!sourceAccount) {\n      throw new Error('must specify source account for the transaction');\n    }\n\n    if ((0, _isUndefined2.default)(opts.fee)) {\n      throw new Error('must specify fee for the transaction (in stroops)');\n    }\n\n    this.source = sourceAccount;\n    this.operations = [];\n\n    this.baseFee = opts.fee;\n    this.timebounds = (0, _clone2.default)(opts.timebounds) || null;\n    this.ledgerbounds = (0, _clone2.default)(opts.ledgerbounds) || null;\n    this.minAccountSequence = opts.minAccountSequence || null;\n    this.minAccountSequenceAge = opts.minAccountSequenceAge || null;\n    this.minAccountSequenceLedgerGap = opts.minAccountSequenceLedgerGap || null;\n    this.extraSigners = (0, _clone2.default)(opts.extraSigners) || null;\n    this.memo = opts.memo || _memo.Memo.none();\n    this.networkPassphrase = opts.networkPassphrase || null;\n  }\n\n  /**\n   * Adds an operation to the transaction.\n   *\n   * @param {xdr.Operation} operation   The xdr operation object, use {@link\n   *     Operation} static methods.\n   *\n   * @returns {TransactionBuilder}\n   */\n\n\n  _createClass(TransactionBuilder, [{\n    key: 'addOperation',\n    value: function addOperation(operation) {\n      this.operations.push(operation);\n      return this;\n    }\n\n    /**\n     * Adds a memo to the transaction.\n     * @param {Memo} memo {@link Memo} object\n     * @returns {TransactionBuilder}\n     */\n\n  }, {\n    key: 'addMemo',\n    value: function addMemo(memo) {\n      this.memo = memo;\n      return this;\n    }\n\n    /**\n     * Sets a timeout precondition on the transaction.\n     *\n     *  Because of the distributed nature of the Stellar network it is possible\n     *  that the status of your transaction will be determined after a long time\n     *  if the network is highly congested. If you want to be sure to receive the\n     *  status of the transaction within a given period you should set the {@link\n     *  TimeBounds} with `maxTime` on the transaction (this is what `setTimeout`\n     *  does internally; if there's `minTime` set but no `maxTime` it will be\n     *  added).\n     *\n     *  A call to `TransactionBuilder.setTimeout` is **required** if Transaction\n     *  does not have `max_time` set. If you don't want to set timeout, use\n     *  `{@link TimeoutInfinite}`. In general you should set `{@link\n     *  TimeoutInfinite}` only in smart contracts.\n     *\n     *  Please note that Horizon may still return <code>504 Gateway Timeout</code>\n     *  error, even for short timeouts. In such case you need to resubmit the same\n     *  transaction again without making any changes to receive a status. This\n     *  method is using the machine system time (UTC), make sure it is set\n     *  correctly.\n     *\n     * @param {number} timeoutSeconds   Number of seconds the transaction is good.\n     *     Can't be negative. If the value is {@link TimeoutInfinite}, the\n     *     transaction is good indefinitely.\n     *\n     * @returns {TransactionBuilder}\n     *\n     * @see {@link TimeoutInfinite}\n     * @see https://developers.stellar.org/docs/tutorials/handling-errors/\n     */\n\n  }, {\n    key: 'setTimeout',\n    value: function setTimeout(timeoutSeconds) {\n      if (this.timebounds !== null && this.timebounds.maxTime > 0) {\n        throw new Error('TimeBounds.max_time has been already set - setting timeout would overwrite it.');\n      }\n\n      if (timeoutSeconds < 0) {\n        throw new Error('timeout cannot be negative');\n      }\n\n      if (timeoutSeconds > 0) {\n        var timeoutTimestamp = Math.floor(Date.now() / 1000) + timeoutSeconds;\n        if (this.timebounds === null) {\n          this.timebounds = { minTime: 0, maxTime: timeoutTimestamp };\n        } else {\n          this.timebounds = {\n            minTime: this.timebounds.minTime,\n            maxTime: timeoutTimestamp\n          };\n        }\n      } else {\n        this.timebounds = {\n          minTime: 0,\n          maxTime: 0\n        };\n      }\n\n      return this;\n    }\n\n    /**\n     * If you want to prepare a transaction which will become valid at some point\n     * in the future, or be invalid after some time, you can set a timebounds\n     * precondition. Internally this will set the `minTime`, and `maxTime`\n     * preconditions. Conflicts with `setTimeout`, so use one or the other.\n     *\n     * @param {Date|number} minEpochOrDate  Either a JS Date object, or a number\n     *     of UNIX epoch seconds. The transaction is valid after this timestamp.\n     *     Can't be negative. If the value is `0`, the transaction is valid\n     *     immediately.\n     * @param {Date|number} maxEpochOrDate  Either a JS Date object, or a number\n     *     of UNIX epoch seconds. The transaction is valid until this timestamp.\n     *     Can't be negative. If the value is `0`, the transaction is valid\n     *     indefinitely.\n     *\n     * @returns {TransactionBuilder}\n     */\n\n  }, {\n    key: 'setTimebounds',\n    value: function setTimebounds(minEpochOrDate, maxEpochOrDate) {\n      // Force it to a date type\n      if (typeof minEpochOrDate === 'number') {\n        minEpochOrDate = new Date(minEpochOrDate * 1000);\n      }\n      if (typeof maxEpochOrDate === 'number') {\n        maxEpochOrDate = new Date(maxEpochOrDate * 1000);\n      }\n\n      if (this.timebounds !== null) {\n        throw new Error('TimeBounds has been already set - setting timebounds would overwrite it.');\n      }\n\n      // Convert that date to the epoch seconds\n      var minTime = Math.floor(minEpochOrDate.valueOf() / 1000);\n      var maxTime = Math.floor(maxEpochOrDate.valueOf() / 1000);\n      if (minTime < 0) {\n        throw new Error('min_time cannot be negative');\n      }\n      if (maxTime < 0) {\n        throw new Error('max_time cannot be negative');\n      }\n      if (maxTime > 0 && minTime > maxTime) {\n        throw new Error('min_time cannot be greater than max_time');\n      }\n\n      this.timebounds = { minTime: minTime, maxTime: maxTime };\n\n      return this;\n    }\n\n    /**\n     * If you want to prepare a transaction which will only be valid within some\n     * range of ledgers, you can set a ledgerbounds precondition.\n     * Internally this will set the `minLedger` and `maxLedger` preconditions.\n     *\n     * @param {number} minLedger  The minimum ledger this transaction is valid at\n     *     or after. Cannot be negative. If the value is `0` (the default), the\n     *     transaction is valid immediately.\n     *\n     * @param {number} maxLedger  The maximum ledger this transaction is valid\n     *     before. Cannot be negative. If the value is `0`, the transaction is\n     *     valid indefinitely.\n     *\n     * @returns {TransactionBuilder}\n     */\n\n  }, {\n    key: 'setLedgerbounds',\n    value: function setLedgerbounds(minLedger, maxLedger) {\n      if (this.ledgerbounds !== null) {\n        throw new Error('LedgerBounds has been already set - setting ledgerbounds would overwrite it.');\n      }\n\n      if (minLedger < 0) {\n        throw new Error('min_ledger cannot be negative');\n      }\n      if (maxLedger < 0) {\n        throw new Error('max_ledger cannot be negative');\n      }\n      if (maxLedger > 0 && minLedger > maxLedger) {\n        throw new Error('min_ledger cannot be greater than max_ledger');\n      }\n\n      this.ledgerbounds = { minLedger: minLedger, maxLedger: maxLedger };\n\n      return this;\n    }\n\n    /**\n     * If you want to prepare a transaction which will be valid only while the\n     * account sequence number is\n     *\n     *     minAccountSequence <= sourceAccountSequence < tx.seqNum\n     *\n     * Note that after execution the account's sequence number is always raised to\n     * `tx.seqNum`. Internally this will set the `minAccountSequence`\n     * precondition.\n     *\n     * @param {string} minAccountSequence   The minimum source account sequence\n     *     number this transaction is valid for. If the value is `0` (the\n     *     default), the transaction is valid when `sourceAccount's sequence\n     *     number == tx.seqNum- 1`.\n     *\n     * @returns {TransactionBuilder}\n     */\n\n  }, {\n    key: 'setMinAccountSequence',\n    value: function setMinAccountSequence(minAccountSequence) {\n      if (this.minAccountSequence !== null) {\n        throw new Error('min_account_sequence has been already set - setting min_account_sequence would overwrite it.');\n      }\n\n      this.minAccountSequence = minAccountSequence;\n\n      return this;\n    }\n\n    /**\n     * For the transaction to be valid, the current ledger time must be at least\n     * `minAccountSequenceAge` greater than sourceAccount's `sequenceTime`.\n     * Internally this will set the `minAccountSequenceAge` precondition.\n     *\n     * @param {number} durationInSeconds  The minimum amount of time between\n     *     source account sequence time and the ledger time when this transaction\n     *     will become valid. If the value is `0`, the transaction is unrestricted\n     *     by the account sequence age. Cannot be negative.\n     *\n     * @returns {TransactionBuilder}\n     */\n\n  }, {\n    key: 'setMinAccountSequenceAge',\n    value: function setMinAccountSequenceAge(durationInSeconds) {\n      if (typeof durationInSeconds !== 'number') {\n        throw new Error('min_account_sequence_age must be a number');\n      }\n      if (this.minAccountSequenceAge !== null) {\n        throw new Error('min_account_sequence_age has been already set - setting min_account_sequence_age would overwrite it.');\n      }\n\n      if (durationInSeconds < 0) {\n        throw new Error('min_account_sequence_age cannot be negative');\n      }\n\n      this.minAccountSequenceAge = durationInSeconds;\n\n      return this;\n    }\n\n    /**\n     * For the transaction to be valid, the current ledger number must be at least\n     * `minAccountSequenceLedgerGap` greater than sourceAccount's ledger sequence.\n     * Internally this will set the `minAccountSequenceLedgerGap` precondition.\n     *\n     * @param {number} gap  The minimum number of ledgers between source account\n     *     sequence and the ledger number when this transaction will become valid.\n     *     If the value is `0`, the transaction is unrestricted by the account\n     *     sequence ledger. Cannot be negative.\n     *\n     * @returns {TransactionBuilder}\n     */\n\n  }, {\n    key: 'setMinAccountSequenceLedgerGap',\n    value: function setMinAccountSequenceLedgerGap(gap) {\n      if (this.minAccountSequenceLedgerGap !== null) {\n        throw new Error('min_account_sequence_ledger_gap has been already set - setting min_account_sequence_ledger_gap would overwrite it.');\n      }\n\n      if (gap < 0) {\n        throw new Error('min_account_sequence_ledger_gap cannot be negative');\n      }\n\n      this.minAccountSequenceLedgerGap = gap;\n\n      return this;\n    }\n\n    /**\n     * For the transaction to be valid, there must be a signature corresponding to\n     * every Signer in this array, even if the signature is not otherwise required\n     * by the sourceAccount or operations. Internally this will set the\n     * `extraSigners` precondition.\n     *\n     * @param {string[]} extraSigners   required extra signers (as {@link StrKey}s)\n     *\n     * @returns {TransactionBuilder}\n     */\n\n  }, {\n    key: 'setExtraSigners',\n    value: function setExtraSigners(extraSigners) {\n      if (!(0, _isArray2.default)(extraSigners)) {\n        throw new Error('extra_signers must be an array of strings.');\n      }\n\n      if (this.extraSigners !== null) {\n        throw new Error('extra_signers has been already set - setting extra_signers would overwrite it.');\n      }\n\n      if (extraSigners.length > 2) {\n        throw new Error('extra_signers cannot be longer than 2 elements.');\n      }\n\n      this.extraSigners = (0, _clone2.default)(extraSigners);\n\n      return this;\n    }\n\n    /**\n     * Set network nassphrase for the Transaction that will be built.\n     *\n     * @param {string} networkPassphrase    passphrase of the target Stellar\n     *     network (e.g. \"Public Global Stellar Network ; September 2015\").\n     *\n     * @returns {TransactionBuilder}\n     */\n\n  }, {\n    key: 'setNetworkPassphrase',\n    value: function setNetworkPassphrase(networkPassphrase) {\n      this.networkPassphrase = networkPassphrase;\n      return this;\n    }\n\n    /**\n     * This will build the transaction.\n     * It will also increment the source account's sequence number by 1.\n     * @returns {Transaction} This method will return the built {@link Transaction}.\n     */\n\n  }, {\n    key: 'build',\n    value: function build() {\n      var sequenceNumber = new _bignumber2.default(this.source.sequenceNumber()).add(1);\n      var fee = new _bignumber2.default(this.baseFee).mul(this.operations.length).toNumber();\n      var attrs = {\n        fee: fee,\n        seqNum: _xdr2.default.SequenceNumber.fromString(sequenceNumber.toString()),\n        memo: this.memo ? this.memo.toXDRObject() : null\n      };\n\n      if (this.timebounds === null || typeof this.timebounds.minTime === 'undefined' || typeof this.timebounds.maxTime === 'undefined') {\n        throw new Error('TimeBounds has to be set or you must call setTimeout(TimeoutInfinite).');\n      }\n\n      if (isValidDate(this.timebounds.minTime)) {\n        this.timebounds.minTime = this.timebounds.minTime.getTime() / 1000;\n      }\n      if (isValidDate(this.timebounds.maxTime)) {\n        this.timebounds.maxTime = this.timebounds.maxTime.getTime() / 1000;\n      }\n\n      this.timebounds.minTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.minTime.toString());\n      this.timebounds.maxTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.maxTime.toString());\n\n      var timeBounds = new _xdr2.default.TimeBounds(this.timebounds);\n\n      if (this.hasV2Preconditions()) {\n        var ledgerBounds = null;\n        if (this.ledgerbounds !== null) {\n          ledgerBounds = new _xdr2.default.LedgerBounds(this.ledgerbounds);\n        }\n\n        var minSeqNum = this.minAccountSequence || '0';\n        minSeqNum = _xdr2.default.SequenceNumber.fromString(minSeqNum);\n\n        var minSeqAge = _jsXdr.UnsignedHyper.fromString(this.minAccountSequenceAge !== null ? this.minAccountSequenceAge.toString() : '0');\n\n        var minSeqLedgerGap = this.minAccountSequenceLedgerGap || 0;\n\n        var extraSigners = this.extraSigners !== null ? this.extraSigners.map(_signerkey.SignerKey.decodeAddress) : [];\n\n        attrs.cond = _xdr2.default.Preconditions.precondV2(new _xdr2.default.PreconditionsV2({\n          timeBounds: timeBounds,\n          ledgerBounds: ledgerBounds,\n          minSeqNum: minSeqNum,\n          minSeqAge: minSeqAge,\n          minSeqLedgerGap: minSeqLedgerGap,\n          extraSigners: extraSigners\n        }));\n      } else {\n        attrs.cond = _xdr2.default.Preconditions.precondTime(timeBounds);\n      }\n\n      attrs.sourceAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(this.source.accountId());\n      attrs.ext = new _xdr2.default.TransactionExt(0);\n\n      var xtx = new _xdr2.default.Transaction(attrs);\n      xtx.operations(this.operations);\n      var txEnvelope = new _xdr2.default.TransactionEnvelope.envelopeTypeTx(new _xdr2.default.TransactionV1Envelope({ tx: xtx }));\n\n      var tx = new _transaction.Transaction(txEnvelope, this.networkPassphrase);\n\n      this.source.incrementSequenceNumber();\n\n      return tx;\n    }\n  }, {\n    key: 'hasV2Preconditions',\n    value: function hasV2Preconditions() {\n      return this.ledgerbounds !== null || this.minAccountSequence !== null || this.minAccountSequenceAge !== null || this.minAccountSequenceLedgerGap !== null || this.extraSigners !== null && this.extraSigners.length > 0;\n    }\n\n    /**\n     * Builds a {@link FeeBumpTransaction}, enabling you to resubmit an existing\n     * transaction with a higher fee.\n     *\n     * @param {Keypair|string}  feeSource - account paying for the transaction,\n     *     in the form of either a Keypair (only the public key is used) or\n     *     an account ID (in G... or M... form, but refer to `withMuxing`)\n     * @param {string}          baseFee   - max fee willing to pay per operation\n     *     in inner transaction (**in stroops**)\n     * @param {Transaction}     innerTx   - {@link Transaction} to be bumped by\n     *     the fee bump transaction\n     * @param {string}          networkPassphrase - passphrase of the target\n     *     Stellar network (e.g. \"Public Global Stellar Network ; September 2015\",\n     *     see {@link Networks})\n     *\n     * @todo Alongside the next major version bump, this type signature can be\n     *       changed to be less awkward: accept a MuxedAccount as the `feeSource`\n     *       rather than a keypair or string.\n     *\n     * @note Your fee-bump amount should be >= 10x the original fee.\n     * @see  https://developers.stellar.org/docs/glossary/fee-bumps/#replace-by-fee\n     *\n     * @returns {FeeBumpTransaction}\n     */\n\n  }], [{\n    key: 'buildFeeBumpTransaction',\n    value: function buildFeeBumpTransaction(feeSource, baseFee, innerTx, networkPassphrase) {\n      var innerOps = innerTx.operations.length;\n      var innerBaseFeeRate = new _bignumber2.default(innerTx.fee).div(innerOps);\n      var base = new _bignumber2.default(baseFee);\n\n      // The fee rate for fee bump is at least the fee rate of the inner transaction\n      if (base.lessThan(innerBaseFeeRate)) {\n        throw new Error('Invalid baseFee, it should be at least ' + innerBaseFeeRate + ' stroops.');\n      }\n\n      var minBaseFee = new _bignumber2.default(BASE_FEE);\n\n      // The fee rate is at least the minimum fee\n      if (base.lessThan(minBaseFee)) {\n        throw new Error('Invalid baseFee, it should be at least ' + minBaseFee + ' stroops.');\n      }\n\n      var innerTxEnvelope = innerTx.toEnvelope();\n      if (innerTxEnvelope.switch() === _xdr2.default.EnvelopeType.envelopeTypeTxV0()) {\n        var v0Tx = innerTxEnvelope.v0().tx();\n        var v1Tx = new _xdr2.default.Transaction({\n          sourceAccount: new _xdr2.default.MuxedAccount.keyTypeEd25519(v0Tx.sourceAccountEd25519()),\n          fee: v0Tx.fee(),\n          seqNum: v0Tx.seqNum(),\n          cond: _xdr2.default.Preconditions.precondTime(v0Tx.timeBounds()),\n          memo: v0Tx.memo(),\n          operations: v0Tx.operations(),\n          ext: new _xdr2.default.TransactionExt(0)\n        });\n        innerTxEnvelope = new _xdr2.default.TransactionEnvelope.envelopeTypeTx(new _xdr2.default.TransactionV1Envelope({\n          tx: v1Tx,\n          signatures: innerTxEnvelope.v0().signatures()\n        }));\n      }\n\n      var feeSourceAccount = void 0;\n      if ((0, _isString2.default)(feeSource)) {\n        feeSourceAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(feeSource);\n      } else {\n        feeSourceAccount = feeSource.xdrMuxedAccount();\n      }\n\n      var tx = new _xdr2.default.FeeBumpTransaction({\n        feeSource: feeSourceAccount,\n        fee: _xdr2.default.Int64.fromString(base.mul(innerOps + 1).toString()),\n        innerTx: _xdr2.default.FeeBumpTransactionInnerTx.envelopeTypeTx(innerTxEnvelope.v1()),\n        ext: new _xdr2.default.FeeBumpTransactionExt(0)\n      });\n      var feeBumpTxEnvelope = new _xdr2.default.FeeBumpTransactionEnvelope({\n        tx: tx,\n        signatures: []\n      });\n      var envelope = new _xdr2.default.TransactionEnvelope.envelopeTypeTxFeeBump(feeBumpTxEnvelope);\n\n      return new _fee_bump_transaction.FeeBumpTransaction(envelope, networkPassphrase);\n    }\n\n    /**\n     * Build a {@link Transaction} or {@link FeeBumpTransaction} from an\n     * xdr.TransactionEnvelope.\n     *\n     * @param {string|xdr.TransactionEnvelope} envelope - The transaction envelope\n     *     object or base64 encoded string.\n     * @param {string} networkPassphrase - The network passphrase of the target\n     *     Stellar network (e.g. \"Public Global Stellar Network ; September\n     *     2015\"), see {@link Networks}.\n     *\n     * @returns {Transaction|FeeBumpTransaction}\n     */\n\n  }, {\n    key: 'fromXDR',\n    value: function fromXDR(envelope, networkPassphrase) {\n      if (typeof envelope === 'string') {\n        envelope = _xdr2.default.TransactionEnvelope.fromXDR(envelope, 'base64');\n      }\n\n      if (envelope.switch() === _xdr2.default.EnvelopeType.envelopeTypeTxFeeBump()) {\n        return new _fee_bump_transaction.FeeBumpTransaction(envelope, networkPassphrase);\n      }\n\n      return new _transaction.Transaction(envelope, networkPassphrase);\n    }\n  }]);\n\n  return TransactionBuilder;\n}();\n\n/**\n * Checks whether a provided object is a valid Date.\n * @argument {Date} d date object\n * @returns {boolean}\n */\n\n\nfunction isValidDate(d) {\n  // isnan is okay here because it correctly checks for invalid date objects\n  // eslint-disable-next-line no-restricted-globals\n  return d instanceof Date && !isNaN(d);\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}