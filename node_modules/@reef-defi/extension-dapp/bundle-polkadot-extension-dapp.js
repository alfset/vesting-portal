var polkadotExtensionDapp = (function (exports, util, utilCrypto) {
  'use strict';

  const global = window;

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  // Copyright 2019-2021 @polkadot/extension-inject authors & contributors
  // SPDX-License-Identifier: Apache-2.0
  const REEF_EXTENSION_IDENT = 'reef';
  const REEF_INJECTED_EVENT = 'reef-injected'; // It is recommended to always use the function below to shield the extension and dapp from
  function isInjected(name) {
    const windowInject = window;
    return !!(windowInject !== null && windowInject !== void 0 && windowInject.injectedWeb3) && !!(windowInject !== null && windowInject !== void 0 && windowInject.injectedWeb3[name]);
  }
  function isInjectionStarted(name) {
    const windowInject = window;
    return !!windowInject._reefInjectionStart && !!windowInject._reefInjectionStart[name];
  }

  // Copyright 2019-2021 @polkadot/extension-dapp authors & contributors
  // SPDX-License-Identifier: Apache-2.0
  function documentReadyPromise(creator) {
    return new Promise(resolve => {
      if (document.readyState === 'complete') {
        resolve(creator());
      } else {
        window.addEventListener('load', () => resolve(creator()));
      }
    });
  }

  // Copyright 2019-2021 @polkadot/extension authors & contributors
  const unwrapBytes = util.u8aUnwrapBytes;
  const wrapBytes = util.u8aWrapBytes;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  // TODO window might be undefined if used server-side

  const win = typeof window !== 'undefined' ? window : null; // window as Window & InjectedWindow;

  if (win) {
    // don't clobber the existing object, but ensure non-undefined
    win.injectedWeb3 = (win === null || win === void 0 ? void 0 : win.injectedWeb3) || {};
  } // true when anything has been injected and is available


  function web3IsInjected() {
    return win ? Object.keys(win.injectedWeb3).length !== 0 : false;
  } // helper to throw a consistent error when not enabled


  function throwError(method) {
    throw new Error(`${method}: web3Enable(originName) needs to be called before ${method}`);
  } // internal helper to map from Array<InjectedAccount> -> Array<InjectedAccountWithMeta>


  function mapAccounts(source, list, ss58Format) {
    return list.map(({
      address,
      genesisHash,
      name,
      type
    }) => {
      const encodedAddress = address.length === 42 ? address : utilCrypto.encodeAddress(utilCrypto.decodeAddress(address), ss58Format);
      return {
        address: encodedAddress,
        meta: {
          genesisHash,
          name,
          source
        },
        type
      };
    });
  } // have we found a properly constructed window.injectedWeb3


  exports.isWeb3Injected = web3IsInjected(); // we keep the last promise created around (for queries)

  exports.web3EnablePromise = null;

  function getWindowExtensions(originName) {
    if (!win) {
      return Promise.resolve([]);
    }

    return Promise.all(Object.entries(win.injectedWeb3).map(([name, {
      enable,
      version
    }]) => Promise.all([Promise.resolve({
      name,
      version
    }), enable(originName).catch(error => {
      console.error(`Error initializing ${name}: ${error.message}`);
    })])));
  }

  const onReefInjectedPromise = () => new Promise(resolve => {
    const listener = () => resolve(true);

    document.addEventListener(REEF_INJECTED_EVENT, listener, false);

    if (isInjected(REEF_EXTENSION_IDENT)) {
      document.removeEventListener(REEF_INJECTED_EVENT, listener);
      resolve(true);
    }
  }); // enables all the providers found on the injected window interface


  function web3Enable(originName, compatInits = []) {
    if (!originName) {
      throw new Error('You must pass a name for your app to the web3Enable function');
    }

    if (isInjectionStarted(REEF_EXTENSION_IDENT) && !isInjected(REEF_EXTENSION_IDENT)) {
      compatInits.push(onReefInjectedPromise);
    }

    const initCompat = compatInits.length ? Promise.all(compatInits.map(c => c().catch(() => false))) : Promise.resolve([true]);
    exports.web3EnablePromise = documentReadyPromise(() => initCompat.then(() => getWindowExtensions(originName).then(values => {
      console.log('web3Enable EXTENSIONS=', values);
      return values.filter(value => !!value[1]).map(([info, ext]) => {
        // if we don't have an accounts subscriber, add a single-shot version
        if (!ext.accounts.subscribe) {
          ext.accounts.subscribe = cb => {
            ext.accounts.get().then(cb).catch(console.error);
            return () => {// no ubsubscribe needed, this is a single-shot
            };
          };
        }

        return _objectSpread(_objectSpread({}, info), ext);
      });
    }).catch(() => []).then(values => {
      const names = values.map(({
        name,
        version
      }) => `${name}/${version}`);
      exports.isWeb3Injected = web3IsInjected();
      console.log(`web3Enable: Enabled ${values.length} extension${values.length !== 1 ? 's' : ''}: ${names.join(', ')}`);
      return values;
    })));
    return exports.web3EnablePromise;
  } // retrieve all the accounts across all providers

  async function web3Accounts({
    accountType,
    ss58Format
  } = {}) {
    if (!exports.web3EnablePromise) {
      return throwError('web3Accounts');
    }

    const accounts = [];
    const injected = await exports.web3EnablePromise;
    const retrieved = await Promise.all(injected.map(async ({
      accounts,
      name: source
    }) => {
      try {
        const list = await accounts.get();
        return mapAccounts(source, list.filter(({
          type
        }) => type && accountType ? accountType.includes(type) : true), ss58Format);
      } catch (error) {
        // cannot handle this one
        return [];
      }
    }));
    retrieved.forEach(result => {
      accounts.push(...result);
    });
    return accounts;
  }
  async function web3AccountsSubscribe(cb, {
    ss58Format
  } = {}) {
    if (!exports.web3EnablePromise) {
      return throwError('web3AccountsSubscribe');
    }

    const accounts = {};

    const triggerUpdate = () => cb(Object.entries(accounts).reduce((result, [source, list]) => {
      result.push(...mapAccounts(source, list, ss58Format));
      return result;
    }, []));

    const unsubs = (await exports.web3EnablePromise).map(({
      accounts: {
        subscribe
      },
      name: source
    }) => subscribe(result => {
      accounts[source] = result; // eslint-disable-next-line @typescript-eslint/no-floating-promises

      triggerUpdate();
    }));
    return () => {
      unsubs.forEach(unsub => {
        unsub();
      });
    };
  } // find a specific provider based on the name

  async function web3FromSource(source) {
    if (!exports.web3EnablePromise) {
      return throwError('web3FromSource');
    }

    const sources = await exports.web3EnablePromise;
    const found = source && sources.find(({
      name
    }) => name === source);

    if (!found) {
      throw new Error(`web3FromSource: Unable to find an injected ${source}`);
    }

    return found;
  } // find a specific provider based on an address

  async function web3FromAddress(address) {
    if (!exports.web3EnablePromise) {
      return throwError('web3FromAddress');
    }

    const accounts = await web3Accounts();
    let found;

    if (address) {
      const accountU8a = utilCrypto.decodeAddress(address);
      found = accounts.find(account => util.u8aEq(utilCrypto.decodeAddress(account.address), accountU8a));
    }

    if (!found) {
      throw new Error(`web3FromAddress: Unable to find injected ${address}`);
    }

    return web3FromSource(found.meta.source);
  } // retrieve all providers exposed by one source

  async function web3ListRpcProviders(source) {
    const {
      provider
    } = await web3FromSource(source);

    if (!provider) {
      console.warn(`Extension ${source} does not expose any provider`);
      return null;
    }

    return provider.listProviders();
  } // retrieve all providers exposed by one source

  async function web3UseRpcProvider(source, key) {
    const {
      provider
    } = await web3FromSource(source);

    if (!provider) {
      throw new Error(`Extension ${source} does not expose any provider`);
    }

    const meta = await provider.startProvider(key);
    return {
      meta,
      provider
    };
  }

  exports.unwrapBytes = unwrapBytes;
  exports.web3Accounts = web3Accounts;
  exports.web3AccountsSubscribe = web3AccountsSubscribe;
  exports.web3Enable = web3Enable;
  exports.web3FromAddress = web3FromAddress;
  exports.web3FromSource = web3FromSource;
  exports.web3ListRpcProviders = web3ListRpcProviders;
  exports.web3UseRpcProvider = web3UseRpcProvider;
  exports.wrapBytes = wrapBytes;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({}, polkadotUtil, polkadotUtilCrypto);
