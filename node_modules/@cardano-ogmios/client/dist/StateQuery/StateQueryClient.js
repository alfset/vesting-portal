"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createStateQueryClient = void 0;
const nanoid_1 = require("nanoid");
const Request_1 = require("../Request");
const errors_1 = require("../errors");
const queries_1 = require("./queries");
const util_1 = require("../util");
const createStateQueryClient = async (context, options) => {
    const { socket } = context;
    return new Promise((resolve, reject) => {
        const createClient = () => resolve({
            context,
            async acquire(point) {
                const client = await (0, exports.createStateQueryClient)(context, { point });
                return Object.assign(this, client);
            },
            async release() {
                (0, util_1.ensureSocketIsOpen)(socket);
                const requestId = (0, nanoid_1.nanoid)(5);
                return new Promise((resolve, reject) => {
                    socket.once('message', (message) => {
                        const response = util_1.safeJSON.parse(message);
                        if (response.reflection.requestId !== requestId) {
                            return;
                        }
                        if (response.result === 'Released') {
                            resolve();
                        }
                        else {
                            reject(new errors_1.UnknownResultError(message));
                        }
                    });
                    socket.send(util_1.safeJSON.stringify({
                        ...Request_1.baseRequest,
                        methodname: 'Release',
                        args: {},
                        mirror: { requestId }
                    }));
                });
            },
            shutdown: () => {
                (0, util_1.ensureSocketIsOpen)(socket);
                return new Promise((resolve, reject) => {
                    socket.once('close', () => resolve());
                    socket.once('error', e => reject(new errors_1.UnknownResultError(e)));
                    socket.close();
                });
            },
            blockHeight: () => {
                (0, util_1.ensureSocketIsOpen)(socket);
                return (0, queries_1.blockHeight)(context);
            },
            chainTip: () => {
                (0, util_1.ensureSocketIsOpen)(socket);
                return (0, queries_1.chainTip)(context);
            },
            currentEpoch: () => {
                (0, util_1.ensureSocketIsOpen)(socket);
                return (0, queries_1.currentEpoch)(context);
            },
            currentProtocolParameters: () => {
                (0, util_1.ensureSocketIsOpen)(socket);
                return (0, queries_1.currentProtocolParameters)(context);
            },
            delegationsAndRewards: (stakeKeyHashes) => {
                (0, util_1.ensureSocketIsOpen)(socket);
                return (0, queries_1.delegationsAndRewards)(context, stakeKeyHashes);
            },
            eraStart: () => {
                (0, util_1.ensureSocketIsOpen)(socket);
                return (0, queries_1.eraStart)(context);
            },
            eraSummaries: () => {
                (0, util_1.ensureSocketIsOpen)(socket);
                return (0, queries_1.eraSummaries)(context);
            },
            genesisConfig: () => {
                (0, util_1.ensureSocketIsOpen)(socket);
                return (0, queries_1.genesisConfig)(context);
            },
            ledgerTip: () => {
                (0, util_1.ensureSocketIsOpen)(socket);
                return (0, queries_1.ledgerTip)(context);
            },
            nonMyopicMemberRewards: (input) => {
                (0, util_1.ensureSocketIsOpen)(socket);
                return (0, queries_1.nonMyopicMemberRewards)(context, input);
            },
            poolIds: () => {
                (0, util_1.ensureSocketIsOpen)(socket);
                return (0, queries_1.poolIds)(context);
            },
            poolParameters: (pools) => {
                (0, util_1.ensureSocketIsOpen)(socket);
                return (0, queries_1.poolParameters)(context, pools);
            },
            poolsRanking: () => {
                (0, util_1.ensureSocketIsOpen)(socket);
                return (0, queries_1.poolsRanking)(context);
            },
            proposedProtocolParameters: () => {
                (0, util_1.ensureSocketIsOpen)(socket);
                return (0, queries_1.proposedProtocolParameters)(context);
            },
            rewardsProvenance: () => {
                (0, util_1.ensureSocketIsOpen)(socket);
                return (0, queries_1.rewardsProvenance)(context);
            },
            rewardsProvenanceNew: () => {
                (0, util_1.ensureSocketIsOpen)(socket);
                return (0, queries_1.rewardsProvenanceNew)(context);
            },
            stakeDistribution: () => {
                (0, util_1.ensureSocketIsOpen)(socket);
                return (0, queries_1.stakeDistribution)(context);
            },
            systemStart: () => {
                (0, util_1.ensureSocketIsOpen)(socket);
                return (0, queries_1.systemStart)(context);
            },
            utxo: (filters) => {
                (0, util_1.ensureSocketIsOpen)(socket);
                return (0, queries_1.utxo)(context, filters);
            }
        });
        if (options?.point !== undefined) {
            const point = options?.point;
            const requestId = (0, nanoid_1.nanoid)(5);
            (0, util_1.ensureSocketIsOpen)(socket);
            socket.once('error', e => reject(new errors_1.UnknownResultError(e)));
            socket.once('message', (message) => {
                const response = util_1.safeJSON.parse(message);
                if (response.reflection.requestId !== requestId) {
                    return;
                }
                if ('AcquireSuccess' in response.result) {
                    createClient();
                }
                else {
                    socket.once('close', () => {
                        if ('AcquireFailure' in response.result) {
                            const { failure } = response.result.AcquireFailure;
                            switch (failure) {
                                case 'pointTooOld': {
                                    return reject(new errors_1.AcquirePointTooOldError());
                                }
                                case 'pointNotOnChain': {
                                    return reject(new errors_1.AcquirePointNotOnChainError());
                                }
                                default: {
                                    return reject(new Error(`Unknown AcquirePointFailure ${failure}`));
                                }
                            }
                        }
                        else {
                            reject(new errors_1.UnknownResultError(response.result));
                        }
                    });
                    socket.close();
                }
            });
            socket.send(util_1.safeJSON.stringify({
                ...Request_1.baseRequest,
                methodname: 'Acquire',
                args: { point },
                mirror: { requestId }
            }));
        }
        else {
            createClient();
        }
    });
};
exports.createStateQueryClient = createStateQueryClient;
//# sourceMappingURL=StateQueryClient.js.map