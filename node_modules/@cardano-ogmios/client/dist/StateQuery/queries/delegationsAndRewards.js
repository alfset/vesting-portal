"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.delegationsAndRewards = void 0;
const errors_1 = require("../../errors");
const Query_1 = require("../Query");
const isEraMismatch = (result) => result.eraMismatch !== undefined;
const isDelegationsAndRewardsByAccounts = (result) => {
    if (typeof result === 'object' && result != null) {
        if (Object.entries(result).length > 0) {
            const sample = Object.entries(result)[0];
            return typeof sample[0] === 'string' && (sample[1].delegate !== undefined || sample[1].rewards !== undefined);
        }
        else {
            return true;
        }
    }
};
const delegationsAndRewards = (context, stakeKeyHashes) => (0, Query_1.Query)({
    methodName: 'Query',
    args: {
        query: { delegationsAndRewards: stakeKeyHashes }
    }
}, {
    handler: (response, resolve, reject) => {
        if (response.result === 'QueryUnavailableInCurrentEra') {
            return reject(new errors_1.QueryUnavailableInCurrentEraError('delegationsAndRewards'));
        }
        else if (isEraMismatch(response.result)) {
            const { eraMismatch } = response.result;
            const { ledgerEra, queryEra } = eraMismatch;
            return reject(new errors_1.EraMismatchError(queryEra, ledgerEra));
        }
        else if (isDelegationsAndRewardsByAccounts(response.result)) {
            return resolve(response.result);
        }
        else {
            return reject(new errors_1.UnknownResultError(response.result));
        }
    }
}, context);
exports.delegationsAndRewards = delegationsAndRewards;
//# sourceMappingURL=delegationsAndRewards.js.map