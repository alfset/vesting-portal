"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isBabbageProtocolParameters = exports.isAlonzoProtocolParameters = exports.isShelleyProtocolParameters = exports.isEmptyObject = exports.isShelleyBlock = exports.isMaryBlock = exports.isByronEpochBoundaryBlock = exports.isByronStandardBlock = exports.isByronBlock = exports.isBabbageBlock = exports.isAlonzoBlock = exports.isAllegraBlock = exports.unsafeMetadatumAsJSON = exports.eventEmitterToGenerator = exports.ensureSocketIsOpen = exports.createPointFromCurrentTip = exports.safeJSON = void 0;
const ChainSync_1 = require("./ChainSync");
const errors_1 = require("./errors");
const JSONBig = require('@cardanosolutions/json-bigint');
exports.safeJSON = {
    $: JSONBig({ useNativeBigInt: true }),
    sanitize(json, parentKey) {
        if (typeof json === 'object' && json !== null) {
            const len = Object.getOwnPropertyNames(json).length;
            if (json.coins !== undefined) {
                const coins = json.coins;
                json.coins = typeof coins === 'number' ? BigInt(coins) : coins;
                if (json.assets !== undefined) {
                    return this.sanitizeAdditionalFields(json.assets);
                }
                return json;
            }
            if (parentKey === 'body' && json.fee !== undefined) {
                return this.sanitizeFields(json, ['fee', 'totalCollateral']);
            }
            if (parentKey === 'withdrawals') {
                return this.sanitizeAdditionalFields(json);
            }
            if (len === 1 && json.int !== undefined) {
                return this.sanitizeFields(json, ['int']);
            }
            if (json.poolInfluence !== undefined && json.pools !== undefined) {
                return this.sanitizeFields(json, ['totalRewards', 'activeStake']);
            }
            if (json.stake !== undefined && json.approximatePerformance !== undefined) {
                return this.sanitizeFields(json, ['stake', 'ownerStake']);
            }
            if (parentKey === 'poolParameters' || (json.vrf !== undefined && json.pledge !== undefined)) {
                return this.sanitizeFields(json, ['cost', 'pledge']);
            }
            if (parentKey === 'moveInstantaneousRewards') {
                this.sanitizeAdditionalFields(json.rewards);
                return this.sanitizeFields(json, ['value']);
            }
            if (json.rewards !== undefined) {
                return this.sanitizeFields(json, ['rewards']);
            }
            for (const k in json) {
                this.sanitize(json[k], k);
            }
            return json;
        }
    },
    sanitizeFields(json, fields) {
        for (const k in json) {
            const v = json[k];
            if (fields.includes(k)) {
                json[k] = typeof v === 'number' ? BigInt(v) : v;
            }
            else {
                this.sanitize(v, k);
            }
        }
        return json;
    },
    sanitizeAdditionalFields(json) {
        for (const k in json) {
            const v = json[k];
            json[k] = typeof v === 'number' ? BigInt(v) : v;
        }
        return json;
    },
    parse(raw) {
        return this.sanitize(this.$.parse(raw));
    },
    stringify(...args) {
        return this.$.stringify(...args);
    }
};
const createPointFromCurrentTip = async (context) => {
    const { tip } = await (0, ChainSync_1.findIntersect)(context, ['origin']);
    if (tip === 'origin') {
        throw new errors_1.TipIsOriginError();
    }
    return {
        hash: tip.hash,
        slot: tip.slot
    };
};
exports.createPointFromCurrentTip = createPointFromCurrentTip;
const ensureSocketIsOpen = (socket) => {
    if (socket.readyState !== socket.OPEN) {
        throw new errors_1.WebSocketClosed();
    }
};
exports.ensureSocketIsOpen = ensureSocketIsOpen;
function eventEmitterToGenerator(eventEmitter, eventName, match) {
    const events = [];
    const listeners = [];
    eventEmitter.on(eventName, async (e) => {
        const matched = match(e);
        if (matched !== null) {
            if (listeners.length > 0) {
                listeners.shift()(matched);
            }
            else {
                events.push(matched);
            }
        }
    });
    return async function* generator() {
        while (true) {
            yield new Promise((resolve) => {
                if (events.length > 0) {
                    resolve(events.shift());
                }
                else {
                    listeners.push(resolve);
                }
            });
        }
    };
}
exports.eventEmitterToGenerator = eventEmitterToGenerator;
function unsafeMetadatumAsJSON(metadatum) {
    function fromMetadatum(o) {
        if (Object.keys(o).length > 1) {
            throw new Error('Malformed metadatum object. A JSON object that describes CBOR encoded datum is expected.');
        }
        if ('int' in o) {
            return o.int;
        }
        else if ('string' in o) {
            return o.string;
        }
        else if ('bytes' in o) {
            return Buffer.from(o.bytes, 'hex');
        }
        else if ('list' in o) {
            return o.list.map(fromMetadatum);
        }
        else if ('map' in o) {
            return o.map.reduce(fromMetadatumMap, {});
        }
        else {
            const type = Object.keys(o)[0];
            const msg = `Unexpected metadatum type '${type}'.`;
            let hint = '';
            if (Number.isInteger(Number.parseInt(type, 10))) {
                hint = ' Hint: this function expects metadatum objects without metadatum label.';
            }
            throw new Error(`${msg}${hint}`);
        }
    }
    function fromMetadatumMap(acc, { k, v }) {
        const kStr = fromMetadatum(k);
        if (typeof kStr !== 'string') {
            throw new Error(`Invalid non-string key: ${k}.`);
        }
        acc[kStr] = fromMetadatum(v);
        return acc;
    }
    return fromMetadatum(metadatum);
}
exports.unsafeMetadatumAsJSON = unsafeMetadatumAsJSON;
const isAllegraBlock = (block) => block.allegra !== undefined;
exports.isAllegraBlock = isAllegraBlock;
const isAlonzoBlock = (block) => block.alonzo !== undefined;
exports.isAlonzoBlock = isAlonzoBlock;
const isBabbageBlock = (block) => block.babbage !== undefined;
exports.isBabbageBlock = isBabbageBlock;
const isByronBlock = (block) => block.byron !== undefined;
exports.isByronBlock = isByronBlock;
const isByronStandardBlock = (block) => (0, exports.isByronBlock)(block) && block.byron.body !== undefined;
exports.isByronStandardBlock = isByronStandardBlock;
const isByronEpochBoundaryBlock = (block) => (0, exports.isByronBlock)(block) && block.byron.body === undefined;
exports.isByronEpochBoundaryBlock = isByronEpochBoundaryBlock;
const isMaryBlock = (block) => block.mary !== undefined;
exports.isMaryBlock = isMaryBlock;
const isShelleyBlock = (block) => block.shelley !== undefined;
exports.isShelleyBlock = isShelleyBlock;
const isEmptyObject = (obj) => obj !== undefined && Object.keys(obj).length === 0 && (obj.constructor === Object || obj.constructor === undefined);
exports.isEmptyObject = isEmptyObject;
const isShelleyProtocolParameters = (params) => params.minUtxoValue !== undefined;
exports.isShelleyProtocolParameters = isShelleyProtocolParameters;
const isAlonzoProtocolParameters = (params) => params.coinsPerUtxoWord !== undefined;
exports.isAlonzoProtocolParameters = isAlonzoProtocolParameters;
const isBabbageProtocolParameters = (params) => params.coinsPerUtxoByte !== undefined;
exports.isBabbageProtocolParameters = isBabbageProtocolParameters;
//# sourceMappingURL=util.js.map