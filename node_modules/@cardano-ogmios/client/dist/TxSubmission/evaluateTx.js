"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleEvaluateTxResponse = exports.evaluateTx = exports.isEvaluationResult = void 0;
const errors_1 = require("../errors");
const evaluationErrors_1 = require("./evaluationErrors");
const StateQuery_1 = require("../StateQuery");
const isEvaluationResult = (result) => (typeof result === 'object' && Object.keys(result).every(x => /^(spend|mint|certificate|withdrawal):\d+$/.test(x)));
exports.isEvaluationResult = isEvaluationResult;
const evaluateTx = (context, bytes, additionalUtxoSet) => (0, StateQuery_1.Query)({
    methodName: 'EvaluateTx',
    args: {
        ...(additionalUtxoSet !== undefined ? { additionalUtxoSet } : {}),
        evaluate: bytes
    }
}, {
    handler: (response, resolve, reject) => {
        const result = (0, exports.handleEvaluateTxResponse)(response);
        if ((0, exports.isEvaluationResult)(result)) {
            return resolve(result);
        }
        else {
            return reject(result);
        }
    }
}, context);
exports.evaluateTx = evaluateTx;
const handleEvaluateTxResponse = (response) => {
    try {
        const { result } = response;
        if ('EvaluationResult' in result) {
            return result.EvaluationResult;
        }
        else if ('EvaluationFailure' in result) {
            const { EvaluationFailure } = result;
            if ('ScriptFailures' in EvaluationFailure) {
                const { ScriptFailures } = EvaluationFailure;
                return Object.keys(ScriptFailures).map(k => {
                    const failure = Object.values(ScriptFailures[k])[0];
                    if (evaluationErrors_1.errors.ExtraRedeemers.assert(failure)) {
                        return new evaluationErrors_1.errors.ExtraRedeemers.Error(failure);
                    }
                    else if (evaluationErrors_1.errors.IllFormedExecutionBudget.assert(failure)) {
                        return new evaluationErrors_1.errors.IllFormedExecutionBudget.Error(failure);
                    }
                    else if (evaluationErrors_1.errors.MissingRequiredDatums.assert(failure)) {
                        return new evaluationErrors_1.errors.MissingRequiredDatums.Error(failure);
                    }
                    else if (evaluationErrors_1.errors.MissingRequiredScripts.assert(failure)) {
                        return new evaluationErrors_1.errors.MissingRequiredScripts.Error(failure);
                    }
                    else if (evaluationErrors_1.errors.NoCostModelForLanguage.assert(failure)) {
                        return new evaluationErrors_1.errors.NoCostModelForLanguage.Error(failure);
                    }
                    else if (evaluationErrors_1.errors.NonScriptInputReferencedByRedeemer.assert(failure)) {
                        return new evaluationErrors_1.errors.NonScriptInputReferencedByRedeemer.Error(failure);
                    }
                    else if (evaluationErrors_1.errors.UnknownInputReferencedByRedeemer.assert(failure)) {
                        return new evaluationErrors_1.errors.UnknownInputReferencedByRedeemer.Error(failure);
                    }
                    else if (evaluationErrors_1.errors.ValidatorFailed.assert(failure)) {
                        return new evaluationErrors_1.errors.ValidatorFailed.Error(failure);
                    }
                    else {
                        return new errors_1.UnknownResultError(failure);
                    }
                });
            }
            else if (evaluationErrors_1.errors.IncompatibleEra.assert(EvaluationFailure)) {
                return [new evaluationErrors_1.errors.IncompatibleEra.Error(EvaluationFailure)];
            }
            else if (evaluationErrors_1.errors.AdditionalUtxoOverlap.assert(EvaluationFailure)) {
                return [new evaluationErrors_1.errors.AdditionalUtxoOverlap.Error(EvaluationFailure)];
            }
            else if (evaluationErrors_1.errors.NotEnoughSynced.assert(EvaluationFailure)) {
                return [new evaluationErrors_1.errors.NotEnoughSynced.Error(EvaluationFailure)];
            }
            else if (evaluationErrors_1.errors.CannotCreateEvaluationContext.assert(EvaluationFailure)) {
                return [new evaluationErrors_1.errors.CannotCreateEvaluationContext.Error(EvaluationFailure)];
            }
        }
        else {
            return [new errors_1.UnknownResultError(response)];
        }
    }
    catch (e) {
        return [new errors_1.UnknownResultError(response)];
    }
};
exports.handleEvaluateTxResponse = handleEvaluateTxResponse;
//# sourceMappingURL=evaluateTx.js.map