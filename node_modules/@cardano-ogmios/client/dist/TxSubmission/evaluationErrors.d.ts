import { EvaluationFailureAdditionalUtxoOverlap, EvaluationFailureCannotCreateEvaluationContext, EvaluationFailureIncompatibleEra, EvaluationFailureNotEnoughSynced, ExtraRedeemers, IllFormedExecutionBudget, MissingRequiredDatums, MissingRequiredScripts, NoCostModelForLanguage, NonScriptInputReferencedByRedeemer, UnknownInputReferencedByRedeemer, ValidatorFailed } from '@cardano-ogmios/schema';
export declare type AdditionalUtxoOverlap = EvaluationFailureAdditionalUtxoOverlap;
export declare type IncompatibleEra = EvaluationFailureIncompatibleEra;
export declare type NotEnoughSynced = EvaluationFailureNotEnoughSynced;
export declare type CannotCreateEvaluationContext = EvaluationFailureCannotCreateEvaluationContext;
export declare type EvaluateTxError = AdditionalUtxoOverlap | CannotCreateEvaluationContext | ExtraRedeemers | IllFormedExecutionBudget | IncompatibleEra | MissingRequiredDatums | MissingRequiredScripts | NoCostModelForLanguage | NonScriptInputReferencedByRedeemer | NotEnoughSynced | UnknownInputReferencedByRedeemer | ValidatorFailed;
export declare const errors: {
    AdditionalUtxoOverlap: {
        assert: (item: EvaluateTxError) => item is EvaluationFailureAdditionalUtxoOverlap;
        Error: {
            new (rawError: AdditionalUtxoOverlap): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    ExtraRedeemers: {
        assert: (item: EvaluateTxError) => item is ExtraRedeemers;
        Error: {
            new (rawError: ExtraRedeemers): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    IllFormedExecutionBudget: {
        assert: (item: EvaluateTxError) => item is IllFormedExecutionBudget;
        Error: {
            new (rawError: IllFormedExecutionBudget): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    IncompatibleEra: {
        assert: (item: EvaluateTxError) => item is EvaluationFailureIncompatibleEra;
        Error: {
            new (rawError: IncompatibleEra): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    MissingRequiredDatums: {
        assert: (item: EvaluateTxError) => item is MissingRequiredDatums;
        Error: {
            new (rawError: MissingRequiredDatums): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    MissingRequiredScripts: {
        assert: (item: EvaluateTxError) => item is MissingRequiredScripts;
        Error: {
            new (rawError: MissingRequiredScripts): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    NoCostModelForLanguage: {
        assert: (item: EvaluateTxError) => item is NoCostModelForLanguage;
        Error: {
            new (rawError: NoCostModelForLanguage): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    NonScriptInputReferencedByRedeemer: {
        assert: (item: EvaluateTxError) => item is NonScriptInputReferencedByRedeemer;
        Error: {
            new (rawError: NonScriptInputReferencedByRedeemer): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    UnknownInputReferencedByRedeemer: {
        assert: (item: EvaluateTxError) => item is UnknownInputReferencedByRedeemer;
        Error: {
            new (rawError: UnknownInputReferencedByRedeemer): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    ValidatorFailed: {
        assert: (item: EvaluateTxError) => item is ValidatorFailed;
        Error: {
            new (rawError: ValidatorFailed): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    NotEnoughSynced: {
        assert: (item: EvaluateTxError) => item is EvaluationFailureNotEnoughSynced;
        Error: {
            new (rawError: NotEnoughSynced): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    CannotCreateEvaluationContext: {
        assert: (item: EvaluateTxError) => item is EvaluationFailureCannotCreateEvaluationContext;
        Error: {
            new (rawError: CannotCreateEvaluationContext): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
};
//# sourceMappingURL=evaluationErrors.d.ts.map