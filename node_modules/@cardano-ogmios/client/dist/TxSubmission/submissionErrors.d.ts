import { AddressAttributesTooLarge, AlreadyDelegating, BadInputs, CollateralHasNonAdaAssets, CollateralIsScript, CollateralTooSmall, CollectErrors, DelegateNotRegistered, DuplicateGenesisVrf, EraMismatch, ExecutionUnitsTooLarge, ExpiredUtxo, ExtraDataMismatch, ExtraRedeemers, ExtraScriptWitnesses, FeeTooSmall, InsufficientFundsForMir, InsufficientGenesisSignatures, InvalidMetadata, InvalidWitnesses, MalformedReferenceScripts, MalformedScriptWitnesses, MirNegativeTransfer, MirNegativeTransferNotCurrentlyAllowed, MirProducesNegativeUpdate, MirTransferNotCurrentlyAllowed, MissingAtLeastOneInputUtxo, MissingCollateralInputs, MissingDatumHashesForInputs, MissingRequiredDatums, MissingRequiredRedeemers, MissingRequiredSignatures, MissingScriptWitnesses, MissingTxMetadata, MissingTxMetadataHash, MissingVkWitnesses, NetworkMismatch, NonGenesisVoters, OutputTooSmall, OutsideForecast, OutsideOfValidityInterval, PoolCostTooSmall, PoolMetadataHashTooBig, ProtocolVersionCannotFollow, RewardAccountNotEmpty, RewardAccountNotExisting, ScriptWitnessNotValidating, StakeKeyAlreadyRegistered, StakeKeyNotRegistered, StakePoolNotRegistered, TooLateForMir, TooManyAssetsInOutput, TooManyCollateralInputs, TotalCollateralMismatch, TriesToForgeAda, TxMetadataHashMismatch, TxTooLarge, UnknownGenesisKey, UnknownOrIncompleteWithdrawals, UnspendableDatums, UnspendableScriptInputs, UpdateWrongEpoch, ValidationTagMismatch, ValueNotConserved, WrongCertificateType, WrongPoolCertificate, WrongRetirementEpoch } from '@cardano-ogmios/schema';
export declare type SubmitTxErrorShelley = AddressAttributesTooLarge | AlreadyDelegating | BadInputs | CollateralHasNonAdaAssets | CollateralIsScript | CollateralTooSmall | CollectErrors | DelegateNotRegistered | DuplicateGenesisVrf | EraMismatch | ExecutionUnitsTooLarge | ExpiredUtxo | ExtraDataMismatch | ExtraRedeemers | ExtraScriptWitnesses | FeeTooSmall | InsufficientFundsForMir | InsufficientGenesisSignatures | InvalidMetadata | InvalidWitnesses | MalformedReferenceScripts | MalformedScriptWitnesses | MirNegativeTransfer | MirNegativeTransferNotCurrentlyAllowed | MirProducesNegativeUpdate | MirTransferNotCurrentlyAllowed | MissingAtLeastOneInputUtxo | MissingCollateralInputs | MissingDatumHashesForInputs | MissingRequiredDatums | MissingRequiredRedeemers | MissingRequiredSignatures | MissingScriptWitnesses | MissingTxMetadata | MissingTxMetadataHash | MissingVkWitnesses | NetworkMismatch | NonGenesisVoters | OutputTooSmall | OutsideForecast | OutsideOfValidityInterval | PoolCostTooSmall | PoolMetadataHashTooBig | ProtocolVersionCannotFollow | RewardAccountNotEmpty | RewardAccountNotExisting | ScriptWitnessNotValidating | StakeKeyAlreadyRegistered | StakeKeyNotRegistered | StakePoolNotRegistered | TooLateForMir | TooManyAssetsInOutput | TooManyCollateralInputs | TotalCollateralMismatch | TriesToForgeAda | TxMetadataHashMismatch | TxTooLarge | UnknownGenesisKey | UnknownOrIncompleteWithdrawals | UnspendableDatums | UnspendableScriptInputs | UpdateWrongEpoch | ValidationTagMismatch | ValueNotConserved | WrongCertificateType | WrongPoolCertificate | WrongRetirementEpoch;
export declare const errors: {
    EraMismatch: {
        assert: (item: SubmitTxErrorShelley) => item is EraMismatch;
        Error: {
            new (rawError: EraMismatch): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    InvalidWitnesses: {
        assert: (item: SubmitTxErrorShelley) => item is InvalidWitnesses;
        Error: {
            new (rawError: InvalidWitnesses): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    MissingVkWitnesses: {
        assert: (item: SubmitTxErrorShelley) => item is MissingVkWitnesses;
        Error: {
            new (rawError: MissingVkWitnesses): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    MissingScriptWitnesses: {
        assert: (item: SubmitTxErrorShelley) => item is MissingScriptWitnesses;
        Error: {
            new (rawError: MissingScriptWitnesses): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    ScriptWitnessNotValidating: {
        assert: (item: SubmitTxErrorShelley) => item is ScriptWitnessNotValidating;
        Error: {
            new (rawError: ScriptWitnessNotValidating): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    InsufficientGenesisSignatures: {
        assert: (item: SubmitTxErrorShelley) => item is InsufficientGenesisSignatures;
        Error: {
            new (rawError: InsufficientGenesisSignatures): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    MissingTxMetadata: {
        assert: (item: SubmitTxErrorShelley) => item is MissingTxMetadata;
        Error: {
            new (rawError: MissingTxMetadata): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    MissingTxMetadataHash: {
        assert: (item: SubmitTxErrorShelley) => item is MissingTxMetadataHash;
        Error: {
            new (rawError: MissingTxMetadataHash): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    TxMetadataHashMismatch: {
        assert: (item: SubmitTxErrorShelley) => item is TxMetadataHashMismatch;
        Error: {
            new (rawError: TxMetadataHashMismatch): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    BadInputs: {
        assert: (item: SubmitTxErrorShelley) => item is BadInputs;
        Error: {
            new (rawError: BadInputs): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    ExpiredUtxo: {
        assert: (item: SubmitTxErrorShelley) => item is ExpiredUtxo;
        Error: {
            new (rawError: ExpiredUtxo): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    TxTooLarge: {
        assert: (item: SubmitTxErrorShelley) => item is TxTooLarge;
        Error: {
            new (rawError: TxTooLarge): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    MissingAtLeastOneInputUtxo: {
        assert: (item: SubmitTxErrorShelley) => item is MissingAtLeastOneInputUtxo;
        Error: {
            new (rawError: MissingAtLeastOneInputUtxo): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    InvalidMetadata: {
        assert: (item: SubmitTxErrorShelley) => item is InvalidMetadata;
        Error: {
            new (rawError: InvalidMetadata): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    FeeTooSmall: {
        assert: (item: SubmitTxErrorShelley) => item is FeeTooSmall;
        Error: {
            new (rawError: FeeTooSmall): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    ValueNotConserved: {
        assert: (item: SubmitTxErrorShelley) => item is ValueNotConserved;
        Error: {
            new (rawError: ValueNotConserved): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    NetworkMismatch: {
        assert: (item: SubmitTxErrorShelley) => item is NetworkMismatch;
        Error: {
            new (rawError: NetworkMismatch): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    OutputTooSmall: {
        assert: (item: SubmitTxErrorShelley) => item is OutputTooSmall;
        Error: {
            new (rawError: OutputTooSmall): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    AddressAttributesTooLarge: {
        assert: (item: SubmitTxErrorShelley) => item is AddressAttributesTooLarge;
        Error: {
            new (rawError: AddressAttributesTooLarge): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    DelegateNotRegistered: {
        assert: (item: SubmitTxErrorShelley) => item is DelegateNotRegistered;
        Error: {
            new (rawError: DelegateNotRegistered): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    UnknownOrIncompleteWithdrawals: {
        assert: (item: SubmitTxErrorShelley) => item is UnknownOrIncompleteWithdrawals;
        Error: {
            new (rawError: UnknownOrIncompleteWithdrawals): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    StakePoolNotRegistered: {
        assert: (item: SubmitTxErrorShelley) => item is StakePoolNotRegistered;
        Error: {
            new (rawError: StakePoolNotRegistered): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    WrongRetirementEpoch: {
        assert: (item: SubmitTxErrorShelley) => item is WrongRetirementEpoch;
        Error: {
            new (rawError: WrongRetirementEpoch): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    WrongPoolCertificate: {
        assert: (item: SubmitTxErrorShelley) => item is WrongPoolCertificate;
        Error: {
            new (rawError: WrongPoolCertificate): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    StakeKeyAlreadyRegistered: {
        assert: (item: SubmitTxErrorShelley) => item is StakeKeyAlreadyRegistered;
        Error: {
            new (rawError: StakeKeyAlreadyRegistered): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    PoolCostTooSmall: {
        assert: (item: SubmitTxErrorShelley) => item is PoolCostTooSmall;
        Error: {
            new (rawError: PoolCostTooSmall): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    StakeKeyNotRegistered: {
        assert: (item: SubmitTxErrorShelley) => item is StakeKeyNotRegistered;
        Error: {
            new (rawError: StakeKeyNotRegistered): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    RewardAccountNotExisting: {
        assert: (item: SubmitTxErrorShelley) => item is RewardAccountNotExisting;
        Error: {
            new (rawError: RewardAccountNotExisting): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    RewardAccountNotEmpty: {
        assert: (item: SubmitTxErrorShelley) => item is RewardAccountNotEmpty;
        Error: {
            new (rawError: RewardAccountNotEmpty): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    WrongCertificateType: {
        assert: (item: SubmitTxErrorShelley) => item is WrongCertificateType;
        Error: {
            new (rawError: WrongCertificateType): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    UnknownGenesisKey: {
        assert: (item: SubmitTxErrorShelley) => item is UnknownGenesisKey;
        Error: {
            new (rawError: UnknownGenesisKey): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    AlreadyDelegating: {
        assert: (item: SubmitTxErrorShelley) => item is AlreadyDelegating;
        Error: {
            new (rawError: AlreadyDelegating): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    InsufficientFundsForMir: {
        assert: (item: SubmitTxErrorShelley) => item is InsufficientFundsForMir;
        Error: {
            new (rawError: InsufficientFundsForMir): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    TooLateForMir: {
        assert: (item: SubmitTxErrorShelley) => item is TooLateForMir;
        Error: {
            new (rawError: TooLateForMir): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    MirTransferNotCurrentlyAllowed: {
        assert: (item: SubmitTxErrorShelley) => item is MirTransferNotCurrentlyAllowed;
        Error: {
            new (rawError: MirTransferNotCurrentlyAllowed): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    MirNegativeTransferNotCurrentlyAllowed: {
        assert: (item: SubmitTxErrorShelley) => item is MirNegativeTransferNotCurrentlyAllowed;
        Error: {
            new (rawError: MirNegativeTransferNotCurrentlyAllowed): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    MirProducesNegativeUpdate: {
        assert: (item: SubmitTxErrorShelley) => item is MirProducesNegativeUpdate;
        Error: {
            new (rawError: MirProducesNegativeUpdate): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    DuplicateGenesisVrf: {
        assert: (item: SubmitTxErrorShelley) => item is DuplicateGenesisVrf;
        Error: {
            new (rawError: DuplicateGenesisVrf): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    NonGenesisVoters: {
        assert: (item: SubmitTxErrorShelley) => item is NonGenesisVoters;
        Error: {
            new (rawError: NonGenesisVoters): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    UpdateWrongEpoch: {
        assert: (item: SubmitTxErrorShelley) => item is UpdateWrongEpoch;
        Error: {
            new (rawError: UpdateWrongEpoch): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    ProtocolVersionCannotFollow: {
        assert: (item: SubmitTxErrorShelley) => item is ProtocolVersionCannotFollow;
        Error: {
            new (rawError: ProtocolVersionCannotFollow): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    OutsideOfValidityInterval: {
        assert: (item: SubmitTxErrorShelley) => item is OutsideOfValidityInterval;
        Error: {
            new (rawError: OutsideOfValidityInterval): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    TriesToForgeAda: {
        assert: (item: SubmitTxErrorShelley) => item is TriesToForgeAda;
        Error: {
            new (rawError: TriesToForgeAda): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    TooManyAssetsInOutput: {
        assert: (item: SubmitTxErrorShelley) => item is TooManyAssetsInOutput;
        Error: {
            new (rawError: TooManyAssetsInOutput): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    MissingRequiredRedeemers: {
        assert: (item: SubmitTxErrorShelley) => item is MissingRequiredRedeemers;
        Error: {
            new (rawError: MissingRequiredRedeemers): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    ExtraDataMismatch: {
        assert: (item: SubmitTxErrorShelley) => item is ExtraDataMismatch;
        Error: {
            new (rawError: ExtraDataMismatch): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    MissingRequiredSignatures: {
        assert: (item: SubmitTxErrorShelley) => item is MissingRequiredSignatures;
        Error: {
            new (rawError: MissingRequiredSignatures): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    MissingDatumHashesForInputs: {
        assert: (item: SubmitTxErrorShelley) => item is MissingDatumHashesForInputs;
        Error: {
            new (rawError: MissingDatumHashesForInputs): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    MissingCollateralInputs: {
        assert: (item: SubmitTxErrorShelley) => item is MissingCollateralInputs;
        Error: {
            new (rawError: MissingCollateralInputs): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    CollateralTooSmall: {
        assert: (item: SubmitTxErrorShelley) => item is CollateralTooSmall;
        Error: {
            new (rawError: CollateralTooSmall): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    CollateralIsScript: {
        assert: (item: SubmitTxErrorShelley) => item is CollateralIsScript;
        Error: {
            new (rawError: CollateralIsScript): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    CollateralHasNonAdaAssets: {
        assert: (item: SubmitTxErrorShelley) => item is CollateralHasNonAdaAssets;
        Error: {
            new (rawError: CollateralHasNonAdaAssets): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    TooManyCollateralInputs: {
        assert: (item: SubmitTxErrorShelley) => item is TooManyCollateralInputs;
        Error: {
            new (rawError: TooManyCollateralInputs): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    ExecutionUnitsTooLarge: {
        assert: (item: SubmitTxErrorShelley) => item is ExecutionUnitsTooLarge;
        Error: {
            new (rawError: ExecutionUnitsTooLarge): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    OutsideForecast: {
        assert: (item: SubmitTxErrorShelley) => item is OutsideForecast;
        Error: {
            new (rawError: OutsideForecast): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    ValidationTagMismatch: {
        assert: (item: SubmitTxErrorShelley) => item is ValidationTagMismatch;
        Error: {
            new (rawError: ValidationTagMismatch): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    CollectErrors: {
        assert: (item: SubmitTxErrorShelley) => item is CollectErrors;
        Error: {
            new (rawError: CollectErrors): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    PoolMetadataHashTooBig: {
        assert: (item: SubmitTxErrorShelley) => item is PoolMetadataHashTooBig;
        Error: {
            new (rawError: PoolMetadataHashTooBig): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    MissingRequiredDatums: {
        assert: (item: SubmitTxErrorShelley) => item is MissingRequiredDatums;
        Error: {
            new (rawError: MissingRequiredDatums): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    UnspendableDatums: {
        assert: (item: SubmitTxErrorShelley) => item is UnspendableDatums;
        Error: {
            new (rawError: UnspendableDatums): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    UnspendableScriptInputs: {
        assert: (item: SubmitTxErrorShelley) => item is UnspendableScriptInputs;
        Error: {
            new (rawError: UnspendableScriptInputs): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    ExtraRedeemers: {
        assert: (item: SubmitTxErrorShelley) => item is ExtraRedeemers;
        Error: {
            new (rawError: ExtraRedeemers): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    ExtraScriptWitnesses: {
        assert: (item: SubmitTxErrorShelley) => item is ExtraScriptWitnesses;
        Error: {
            new (rawError: ExtraScriptWitnesses): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    MirNegativeTransfer: {
        assert: (item: SubmitTxErrorShelley) => item is MirNegativeTransfer;
        Error: {
            new (rawError: MirNegativeTransfer): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    TotalCollateralMismatch: {
        assert: (item: SubmitTxErrorShelley) => item is TotalCollateralMismatch;
        Error: {
            new (rawError: TotalCollateralMismatch): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    MalformedReferenceScripts: {
        assert: (item: SubmitTxErrorShelley) => item is MalformedReferenceScripts;
        Error: {
            new (rawError: MalformedReferenceScripts): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
    MalformedScriptWitnesses: {
        assert: (item: SubmitTxErrorShelley) => item is MalformedScriptWitnesses;
        Error: {
            new (rawError: MalformedScriptWitnesses): {
                name: string;
                message: string;
                stack?: string;
            };
            captureStackTrace(targetObject: object, constructorOpt?: Function): void;
            prepareStackTrace?: (err: Error, stackTraces: NodeJS.CallSite[]) => any;
            stackTraceLimit: number;
        };
    };
};
//# sourceMappingURL=submissionErrors.d.ts.map