"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createChainSyncClient = void 0;
const errors_1 = require("../errors");
const fastq_1 = __importDefault(require("fastq"));
const util_1 = require("../util");
const findIntersect_1 = require("./findIntersect");
const requestNext_1 = require("./requestNext");
const createChainSyncClient = async (context, messageHandlers, options) => {
    const { socket } = context;
    return new Promise((resolve) => {
        const messageHandler = async (response) => {
            if ('RollBackward' in response.result) {
                await messageHandlers.rollBackward({
                    point: response.result.RollBackward.point,
                    tip: response.result.RollBackward.tip
                }, () => (0, requestNext_1.requestNext)(socket));
            }
            else if ('RollForward' in response.result) {
                await messageHandlers.rollForward({
                    block: response.result.RollForward.block,
                    tip: response.result.RollForward.tip
                }, () => {
                    (0, requestNext_1.requestNext)(socket);
                });
            }
            else {
                throw new errors_1.UnknownResultError(response.result);
            }
        };
        const responseHandler = options?.sequential !== false
            ? fastq_1.default.promise(messageHandler, 1).push
            : messageHandler;
        socket.on('message', async (message) => {
            const response = util_1.safeJSON.parse(message);
            if (response.methodname === 'RequestNext') {
                try {
                    await responseHandler(response);
                }
                catch (error) {
                    console.error(error);
                }
            }
        });
        return resolve({
            context,
            shutdown: () => new Promise(resolve => {
                (0, util_1.ensureSocketIsOpen)(socket);
                socket.once('close', resolve);
                socket.close();
            }),
            startSync: async (points, inFlight) => {
                const intersection = await (0, findIntersect_1.findIntersect)(context, points || [await (0, util_1.createPointFromCurrentTip)(context)]);
                (0, util_1.ensureSocketIsOpen)(socket);
                for (let n = 0; n < (inFlight || 100); n += 1) {
                    (0, requestNext_1.requestNext)(socket);
                }
                return intersection;
            }
        });
    });
};
exports.createChainSyncClient = createChainSyncClient;
//# sourceMappingURL=ChainSyncClient.js.map