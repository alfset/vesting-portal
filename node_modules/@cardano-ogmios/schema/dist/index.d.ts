export declare type Block = Babbage | Alonzo | Mary | Allegra | Shelley | Byron;
export declare type DigestBlake2BBlockBody = string;
export declare type TxId = string;
export declare type Address = string;
export declare type Lovelace = bigint;
export declare type AssetQuantity = bigint;
export declare type DigestBlake2BDatum = string;
export declare type Null = null;
export declare type Datum = string;
export declare type Script = Native | PlutusV1 | PlutusV2;
export declare type ScriptNative = DigestBlake2BVerificationKey | Any | All | NOf | ExpiresAt | StartsAt;
export declare type DigestBlake2BVerificationKey = string;
export declare type Slot = number;
export declare type ScriptPlutus = string;
export declare type Certificate = StakeDelegation | StakeKeyRegistration | StakeKeyDeregistration | PoolRegistration | PoolRetirement | GenesisDelegation | MoveInstantaneousRewards;
export declare type DigestBlake2BCredential = string;
export declare type PoolId = string;
export declare type Ratio = string;
export declare type DigestBlake2BVrfVerificationKey = string;
export declare type DigestBlake2BPoolMetadata = string;
export declare type Relay = ByAddress | ByName;
export declare type RewardAccount = string;
export declare type Epoch = number;
export declare type LovelaceDelta = number;
export declare type RewardPot = "reserves" | "treasury";
export declare type UpdateBabbage = Null | UpdateProposalBabbage;
export declare type NullableUInt64 = UInt64 | Null;
export declare type UInt64 = number;
export declare type NullableRatio = Ratio | Null;
export declare type UInt32 = number;
export declare type Int64 = number;
export declare type Network = "mainnet" | "testnet";
export declare type DigestBlake2BScriptIntegrity = string;
export declare type Signature = string;
export declare type ChainCode = string;
export declare type AddressAttributes = string;
export declare type VerificationKey = string;
export declare type RedeemerData = string;
export declare type DigestBlake2BAuxiliaryDataBody = string;
export declare type Metadatum = Int | String | Bytes | List | Map;
export declare type DigestBlake2BBlockHeader = string | "genesis";
export declare type BlockNo = number;
export declare type IssuerVrfVerificationKey = string;
export declare type BlockSize = number;
export declare type KesVerificationKey = string;
export declare type IssuerSignature = string;
export declare type VrfProof = string;
export declare type VrfOutput = string;
export declare type UpdateAlonzo = Null | UpdateProposalAlonzo;
export declare type Nonce = Neutral | DigestBlake2BNonce;
export declare type Neutral = "neutral";
export declare type DigestBlake2BNonce = string;
export declare type UpdateShelley = Null | UpdateProposalShelley;
export declare type BlockByron = StandardBlock | EpochBoundaryBlock;
export declare type GenesisVerificationKey = string;
export declare type DigestBlake2BMerkleRoot = string;
export declare type DigestBlake2BBlockByronBodyTxPayloadWitness = string;
export declare type DigestBlake2BBlockByronBodyDlgPayload = string;
export declare type DigestBlake2BBlockByronBodyUpdatePayload = string;
export declare type ProtocolMagicId = number;
export declare type TxWitness = WitnessVk | RedeemWitness;
export declare type TipOrOrigin = Tip | Origin;
export declare type Origin = "origin";
export declare type PointOrOrigin = Point | Origin;
export declare type Era = "Byron" | "Shelley" | "Allegra" | "Mary" | "Alonzo" | "Babbage";
export declare type DigestBlake2BScript = string;
export declare type InvalidEntity = {
    type: "address";
    entity: Address;
} | {
    type: "poolRegistration";
    entity: PoolId;
} | {
    type: "rewardAccount";
    entity: RewardAccount;
};
export declare type UInt8 = number;
export declare type VotingPeriod = "voteForThisEpoch" | "voteForNextEpoch";
export declare type ScriptPurpose = Spend | Mint | Certificate1 | Withdrawal;
export declare type Utxo = [TxIn, TxOut][];
export declare type Language = "plutus:v1" | "plutus:v2";
export declare type SubmitTxError = (EraMismatch | InvalidWitnesses | MissingVkWitnesses | MissingScriptWitnesses | ScriptWitnessNotValidating | InsufficientGenesisSignatures | MissingTxMetadata | MissingTxMetadataHash | TxMetadataHashMismatch | BadInputs | ExpiredUtxo | OutsideOfValidityInterval | TxTooLarge | MissingAtLeastOneInputUtxo | InvalidMetadata | FeeTooSmall | ValueNotConserved | NetworkMismatch | OutputTooSmall | TooManyAssetsInOutput | AddressAttributesTooLarge | TriesToForgeAda | DelegateNotRegistered | UnknownOrIncompleteWithdrawals | StakePoolNotRegistered | WrongRetirementEpoch | WrongPoolCertificate | StakeKeyAlreadyRegistered | PoolCostTooSmall | PoolMetadataHashTooBig | StakeKeyNotRegistered | RewardAccountNotExisting | RewardAccountNotEmpty | WrongCertificateType | UnknownGenesisKey | AlreadyDelegating | InsufficientFundsForMir | TooLateForMir | MirTransferNotCurrentlyAllowed | MirNegativeTransferNotCurrentlyAllowed | MirProducesNegativeUpdate | DuplicateGenesisVrf | NonGenesisVoters | UpdateWrongEpoch | ProtocolVersionCannotFollow | MissingRequiredRedeemers | MissingRequiredDatums | UnspendableDatums | ExtraDataMismatch | MissingRequiredSignatures | UnspendableScriptInputs | ExtraRedeemers | MissingDatumHashesForInputs | MissingCollateralInputs | CollateralTooSmall | CollateralIsScript | CollateralHasNonAdaAssets | TooManyCollateralInputs | ExecutionUnitsTooLarge | OutsideForecast | ValidationTagMismatch | CollectErrors | ExtraScriptWitnesses | MirNegativeTransfer | TotalCollateralMismatch | MalformedReferenceScripts | MalformedScriptWitnesses)[];
export declare type RedeemerPointer = string;
export declare type ScriptFailure = (ExtraRedeemers | MissingRequiredDatums | MissingRequiredScripts | ValidatorFailed | UnknownInputReferencedByRedeemer | NonScriptInputReferencedByRedeemer | IllFormedExecutionBudget | NoCostModelForLanguage)[];
export declare type AcquireFailureDetails = "pointTooOld" | "pointNotOnChain";
export declare type GetEraStart = "eraStart";
export declare type GetEraSummaries = "eraSummaries";
export declare type GetLedgerTip = "ledgerTip";
export declare type GetCurrentEpoch = "currentEpoch";
export declare type StakeCredential = Base16 | Bech32 | StakeAddress;
export declare type Base16 = string;
export declare type Bech32 = string;
export declare type StakeAddress = string;
export declare type GetCurrentProtocolParameters = "currentProtocolParameters";
export declare type GetProposedProtocolParameters = "proposedProtocolParameters";
export declare type GetStakeDistribution = "stakeDistribution";
export declare type GetUtxo = "utxo";
export declare type GetGenesisConfig = "genesisConfig";
export declare type GetRewardsProvenanceDeprecated = "rewardsProvenance";
export declare type GetRewardsProvenance = "rewardsProvenance'";
export declare type GetPoolsRanking = "poolsRanking";
export declare type GetPoolIds = "poolIds";
export declare type GetChainTip = "chainTip";
export declare type GetBlockHeight = "blockHeight";
export declare type GetSystemStart = "systemStart";
export declare type RelativeTime = number;
export declare type QueryUnavailableInCurrentEra = "QueryUnavailableInCurrentEra";
export declare type SlotLength = number;
export declare type SafeZone = number;
export declare type UtcTime = string;
export declare type NetworkMagic = number;
export declare type BlockNoOrOrigin = BlockNo | Origin;
export interface Ogmios {
    RequestNext: {
        type: "jsonwsp/request";
        version: "1.0";
        servicename: "ogmios";
        methodname: "RequestNext";
        args?: {};
        mirror?: {
            [k: string]: unknown;
        };
    };
    RequestNextResponse: {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "RequestNext";
        result: RollForward | RollBackward;
        reflection?: {
            [k: string]: unknown;
        };
    };
    FindIntersect: {
        type: "jsonwsp/request";
        version: "1.0";
        servicename: "ogmios";
        methodname: "FindIntersect";
        args?: {
            points?: PointOrOrigin[];
        };
        mirror?: {
            [k: string]: unknown;
        };
    };
    FindIntersectResponse: {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "FindIntersect";
        result: IntersectionFound | IntersectionNotFound;
        reflection?: {
            [k: string]: unknown;
        };
    };
    SubmitTx: {
        type: "jsonwsp/request";
        version: "1.0";
        servicename: "ogmios";
        methodname: "SubmitTx";
        args?: {
            submit: string;
        };
        mirror?: {
            [k: string]: unknown;
        };
    };
    SubmitTxResponse: {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "SubmitTx";
        result: SubmitSuccess | SubmitFail;
        reflection?: {
            [k: string]: unknown;
        };
    };
    EvaluateTx: {
        type: "jsonwsp/request";
        version: "1.0";
        servicename: "ogmios";
        methodname: "EvaluateTx";
        args?: {
            evaluate: string;
            additionalUtxoSet?: Utxo;
        };
        mirror?: {
            [k: string]: unknown;
        };
    };
    EvaluateTxResponse: {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "EvaluateTx";
        result: EvaluationResult | EvaluationFailure;
        reflection?: {
            [k: string]: unknown;
        };
    };
    Acquire: {
        type: "jsonwsp/request";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Acquire";
        args?: {
            point: PointOrOrigin;
        };
        mirror?: {
            [k: string]: unknown;
        };
    };
    AcquireResponse: {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Acquire";
        result: AcquireSuccess | AcquireFailure;
        reflection?: {
            [k: string]: unknown;
        };
    };
    Release: {
        type: "jsonwsp/request";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Release";
        args?: {};
        mirror?: {
            [k: string]: unknown;
        };
    };
    ReleaseResponse: {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Release";
        result: "Released";
        reflection?: {
            [k: string]: unknown;
        };
    };
    AwaitAcquire: {
        type: "jsonwsp/request";
        version: "1.0";
        servicename: "ogmios";
        methodname: "AwaitAcquire";
        args?: {};
        mirror?: {
            [k: string]: unknown;
        };
    };
    AwaitAcquireResponse: {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "AwaitAcquire";
        result: AwaitAcquired;
        reflection?: {
            [k: string]: unknown;
        };
    };
    NextTx: {
        type: "jsonwsp/request";
        version: "1.0";
        servicename: "ogmios";
        methodname: "NextTx";
        args?: {
            fields?: "all";
        };
        mirror?: {
            [k: string]: unknown;
        };
    };
    NextTxResponse: {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "NextTx";
        result: TxId | TxAlonzo | TxBabbage | Null;
        reflection?: {
            [k: string]: unknown;
        };
    };
    HasTx: {
        type: "jsonwsp/request";
        version: "1.0";
        servicename: "ogmios";
        methodname: "HasTx";
        args?: {
            id: TxId;
        };
        mirror?: {
            [k: string]: unknown;
        };
    };
    HasTxResponse: {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "HasTx";
        result: boolean;
        reflection?: {
            [k: string]: unknown;
        };
    };
    SizeAndCapacity: {
        type: "jsonwsp/request";
        version: "1.0";
        servicename: "ogmios";
        methodname: "SizeAndCapacity";
        args?: {};
        mirror?: {
            [k: string]: unknown;
        };
    };
    SizeAndCapacityResponse: {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "SizeAndCapacity";
        result: MempoolSizeAndCapacity;
        reflection?: {
            [k: string]: unknown;
        };
    };
    ReleaseMempool?: {
        type: "jsonwsp/request";
        version: "1.0";
        servicename: "ogmios";
        methodname: "ReleaseMempool";
        args?: {};
        mirror?: {
            [k: string]: unknown;
        };
    };
    ReleaseMempoolResponse?: {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "ReleaseMempool";
        result: "Released";
        reflection?: {
            [k: string]: unknown;
        };
    };
    Query: {
        type: "jsonwsp/request";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Query";
        args?: {
            query: GetEraStart | GetEraSummaries | GetLedgerTip | GetCurrentEpoch | GetNonMyopicMemberRewards | GetDelegationsAndRewards | GetCurrentProtocolParameters | GetProposedProtocolParameters | GetStakeDistribution | GetUtxo | GetUtxoByAddress | GetUtxoByTxIn | GetGenesisConfig | GetRewardsProvenanceDeprecated | GetRewardsProvenance | GetPoolsRanking | GetPoolIds | GetPoolParameters | GetChainTip | GetBlockHeight | GetSystemStart;
        };
        mirror?: {
            [k: string]: unknown;
        };
    };
    "QueryResponse[eraStart]": {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Query";
        result: Bound | QueryUnavailableInCurrentEra;
        reflection?: {
            [k: string]: unknown;
        };
    };
    "QueryResponse[eraSummaries]": {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Query";
        result: QueryUnavailableInCurrentEra | EraSummary[];
        reflection?: {
            [k: string]: unknown;
        };
    };
    "QueryResponse[ledgerTip]": {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Query";
        result: PointOrOrigin | EraMismatch | QueryUnavailableInCurrentEra;
        reflection?: {
            [k: string]: unknown;
        };
    };
    "QueryResponse[currentEpoch]": {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Query";
        result: Epoch | EraMismatch | QueryUnavailableInCurrentEra;
        reflection?: {
            [k: string]: unknown;
        };
    };
    "QueryResponse[nonMyopicMemberRewards]": {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Query";
        result: NonMyopicMemberRewards | EraMismatch | QueryUnavailableInCurrentEra;
        reflection?: {
            [k: string]: unknown;
        };
    };
    "QueryResponse[delegationsAndRewards]": {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Query";
        result: DelegationsAndRewardsByAccounts | EraMismatch | QueryUnavailableInCurrentEra;
        reflection?: {
            [k: string]: unknown;
        };
    };
    "QueryResponse[currentProtocolParameters]": {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Query";
        result: ProtocolParametersShelley | ProtocolParametersAlonzo | ProtocolParametersBabbage | EraMismatch | QueryUnavailableInCurrentEra;
        reflection?: {
            [k: string]: unknown;
        };
    };
    "QueryResponse[proposedProtocolParameters]": {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Query";
        result: ProposedProtocolParametersShelley | ProposedProtocolParametersAlonzo | ProposedProtocolParametersBabbage | EraMismatch | QueryUnavailableInCurrentEra;
        reflection?: {
            [k: string]: unknown;
        };
    };
    "QueryResponse[stakeDistribution]": {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Query";
        result: PoolDistribution | EraMismatch | QueryUnavailableInCurrentEra;
        reflection?: {
            [k: string]: unknown;
        };
    };
    "QueryResponse[utxo]": {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Query";
        result: Utxo | EraMismatch | QueryUnavailableInCurrentEra;
        reflection?: {
            [k: string]: unknown;
        };
    };
    "QueryResponse[genesisConfig]": {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Query";
        result: CompactGenesis | EraMismatch | QueryUnavailableInCurrentEra;
        reflection?: {
            [k: string]: unknown;
        };
    };
    "QueryResponse[rewardsProvenance]": {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Query";
        result: RewardsProvenance | EraMismatch | QueryUnavailableInCurrentEra;
        reflection?: {
            [k: string]: unknown;
        };
    };
    "QueryResponse[rewardsProvenance']": {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Query";
        result: RewardsProvenance1 | EraMismatch | QueryUnavailableInCurrentEra;
        reflection?: {
            [k: string]: unknown;
        };
    };
    "QueryResponse[poolIds]": {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Query";
        result: PoolId[] | EraMismatch | QueryUnavailableInCurrentEra;
        reflection?: {
            [k: string]: unknown;
        };
    };
    "QueryResponse[poolParameters]": {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Query";
        result: {
            [k: string]: PoolParameters;
        } | EraMismatch | QueryUnavailableInCurrentEra;
        reflection?: {
            [k: string]: unknown;
        };
    };
    "QueryResponse[poolsRanking]": {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Query";
        result: PoolsRanking | EraMismatch | QueryUnavailableInCurrentEra;
        reflection?: {
            [k: string]: unknown;
        };
    };
    "QueryResponse[blockHeight]": {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Query";
        result: BlockNoOrOrigin | QueryUnavailableInCurrentEra;
        reflection?: {
            [k: string]: unknown;
        };
    };
    "QueryResponse[chainTip]": {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Query";
        result: PointOrOrigin | QueryUnavailableInCurrentEra;
        reflection?: {
            [k: string]: unknown;
        };
    };
    "QueryResponse[systemStart]": {
        type: "jsonwsp/response";
        version: "1.0";
        servicename: "ogmios";
        methodname: "Query";
        result: UtcTime | QueryUnavailableInCurrentEra;
        reflection?: {
            [k: string]: unknown;
        };
    };
    Fault: {
        type: "jsonwsp/fault";
        version: "1.0";
        servicename: "ogmios";
        fault: {
            code: "incompatible" | "server" | "client";
            string: string;
        };
    };
    [k: string]: unknown;
}
export interface RollForward {
    RollForward: {
        block: Block;
        tip: TipOrOrigin;
    };
}
export interface Babbage {
    babbage: BlockBabbage;
}
export interface BlockBabbage {
    body: TxBabbage[];
    headerHash: DigestBlake2BBlockHeader;
    header: {
        blockHeight: BlockNo;
        slot: Slot;
        prevHash: DigestBlake2BBlockHeader;
        issuerVk: VerificationKey;
        issuerVrf: IssuerVrfVerificationKey;
        blockSize: BlockSize;
        blockHash: DigestBlake2BBlockBody;
        opCert: OpCert;
        protocolVersion: ProtocolVersion;
        signature: IssuerSignature;
        vrfInput: CertifiedVrf;
    };
}
export interface TxBabbage {
    id: DigestBlake2BBlockBody;
    inputSource: "inputs" | "collaterals";
    body: {
        inputs: TxIn[];
        references: TxIn[];
        collaterals: TxIn[];
        collateralReturn: TxOut | Null;
        totalCollateral: Lovelace | Null;
        outputs: TxOut[];
        certificates: Certificate[];
        withdrawals: Withdrawals;
        fee: Lovelace;
        validityInterval: ValidityInterval;
        update: UpdateBabbage;
        mint: Value;
        network: Network | Null;
        scriptIntegrityHash: DigestBlake2BScriptIntegrity | Null;
        requiredExtraSignatures: DigestBlake2BVerificationKey[];
    };
    witness: {
        signatures: {
            [k: string]: Signature;
        };
        scripts: {
            [k: string]: Script;
        };
        bootstrap: BootstrapWitness[];
        datums: {
            [k: string]: Datum;
        };
        redeemers: {
            [k: string]: Redeemer;
        };
    };
    metadata: AuxiliaryData | Null;
    raw: string;
}
export interface TxIn {
    txId: TxId;
    index: number;
}
export interface TxOut {
    address: Address;
    value: Value;
    datumHash?: DigestBlake2BDatum | Null;
    datum?: {
        [k: string]: unknown;
    } | Datum | Null;
    script?: Script | Null;
}
export interface Value {
    coins: Lovelace;
    assets?: {
        [k: string]: AssetQuantity;
    };
}
export interface Native {
    native: ScriptNative;
}
export interface Any {
    any: ScriptNative[];
}
export interface All {
    all: ScriptNative[];
}
export interface NOf {
    [k: string]: ScriptNative[];
}
export interface ExpiresAt {
    expiresAt: Slot;
}
export interface StartsAt {
    startsAt: Slot;
}
export interface PlutusV1 {
    "plutus:v1": ScriptPlutus;
}
export interface PlutusV2 {
    "plutus:v2": ScriptPlutus;
}
export interface StakeDelegation {
    stakeDelegation: {
        delegator: DigestBlake2BCredential;
        delegatee: PoolId;
    };
}
export interface StakeKeyRegistration {
    stakeKeyRegistration: DigestBlake2BCredential;
}
export interface StakeKeyDeregistration {
    stakeKeyDeregistration: DigestBlake2BCredential;
}
export interface PoolRegistration {
    poolRegistration: PoolParameters;
}
export interface PoolParameters {
    owners: DigestBlake2BVerificationKey[];
    cost: Lovelace;
    margin: Ratio;
    pledge: Lovelace;
    vrf: DigestBlake2BVrfVerificationKey;
    metadata: Null | PoolMetadata;
    id: PoolId;
    relays: Relay[];
    rewardAccount: RewardAccount;
}
export interface PoolMetadata {
    hash: DigestBlake2BPoolMetadata;
    url: string;
}
export interface ByAddress {
    ipv4: string | Null;
    ipv6: string | Null;
    port: number | Null;
}
export interface ByName {
    hostname: string;
    port: number | Null;
}
export interface PoolRetirement {
    poolRetirement: {
        retirementEpoch: Epoch;
        poolId: PoolId;
    };
}
export interface GenesisDelegation {
    genesisDelegation: {
        delegateKeyHash: DigestBlake2BVerificationKey;
        verificationKeyHash: DigestBlake2BVerificationKey;
        vrfVerificationKeyHash: DigestBlake2BVrfVerificationKey;
    };
}
export interface MoveInstantaneousRewards {
    moveInstantaneousRewards: {
        rewards?: Rewards;
        value?: Lovelace;
        pot: RewardPot;
    };
}
export interface Rewards {
    [k: string]: LovelaceDelta;
}
export interface Withdrawals {
    [k: string]: Lovelace;
}
export interface ValidityInterval {
    invalidBefore: Slot | Null;
    invalidHereafter: Slot | Null;
}
export interface UpdateProposalBabbage {
    epoch: Epoch;
    proposal: {
        [k: string]: ProtocolParametersBabbage;
    };
}
export interface ProtocolParametersBabbage {
    minFeeCoefficient: NullableUInt64;
    minFeeConstant: NullableUInt64;
    maxBlockBodySize: NullableUInt64;
    maxBlockHeaderSize: NullableUInt64;
    maxTxSize: NullableUInt64;
    stakeKeyDeposit: NullableUInt64;
    poolDeposit: NullableUInt64;
    poolRetirementEpochBound: NullableUInt64;
    desiredNumberOfPools: NullableUInt64;
    poolInfluence: NullableRatio;
    monetaryExpansion: NullableRatio;
    treasuryExpansion: NullableRatio;
    minPoolCost: NullableUInt64;
    coinsPerUtxoByte: NullableUInt64;
    maxValueSize: NullableUInt64;
    collateralPercentage: NullableUInt64;
    maxCollateralInputs: NullableUInt64;
    protocolVersion: ProtocolVersion | Null;
    costModels: CostModels | Null;
    prices: Prices | Null;
    maxExecutionUnitsPerTransaction: ExUnits | Null;
    maxExecutionUnitsPerBlock: ExUnits | Null;
}
export interface ProtocolVersion {
    major: UInt32;
    minor: UInt32;
    patch?: UInt32;
}
export interface CostModels {
    [k: string]: CostModel;
}
export interface CostModel {
    [k: string]: Int64;
}
export interface Prices {
    memory: Ratio;
    steps: Ratio;
}
export interface ExUnits {
    memory: UInt64;
    steps: UInt64;
}
export interface BootstrapWitness {
    signature: Signature;
    chainCode: ChainCode | Null;
    addressAttributes: AddressAttributes | Null;
    key: VerificationKey;
}
export interface Redeemer {
    redeemer: RedeemerData;
    executionUnits: ExUnits;
}
export interface AuxiliaryData {
    hash: DigestBlake2BAuxiliaryDataBody;
    body: AuxiliaryDataBody;
}
export interface AuxiliaryDataBody {
    blob?: Metadata;
    scripts?: Script[];
}
export interface Metadata {
    [k: string]: Metadatum;
}
export interface Int {
    int: bigint;
}
export interface String {
    string: string;
}
export interface Bytes {
    bytes: string;
}
export interface List {
    list: Metadatum[];
}
export interface Map {
    map: MetadatumMap[];
}
export interface MetadatumMap {
    k: Metadatum;
    v: Metadatum;
}
export interface OpCert {
    count?: UInt64;
    sigma?: Signature;
    kesPeriod?: UInt64;
    hotVk?: KesVerificationKey;
}
export interface CertifiedVrf {
    proof?: VrfProof;
    output?: VrfOutput;
}
export interface Alonzo {
    alonzo: BlockAlonzo;
}
export interface BlockAlonzo {
    body: TxAlonzo[];
    headerHash: DigestBlake2BBlockHeader;
    header: {
        blockHeight: BlockNo;
        slot: Slot;
        prevHash: DigestBlake2BBlockHeader;
        issuerVk: VerificationKey;
        issuerVrf: IssuerVrfVerificationKey;
        nonce?: CertifiedVrf;
        leaderValue: CertifiedVrf;
        blockSize: BlockSize;
        blockHash: DigestBlake2BBlockBody;
        opCert: OpCert;
        protocolVersion: ProtocolVersion;
        signature: IssuerSignature;
    };
}
export interface TxAlonzo {
    id: DigestBlake2BBlockBody;
    inputSource: "inputs" | "collaterals";
    body: {
        inputs: TxIn[];
        collaterals: TxIn[];
        outputs: TxOut[];
        certificates: Certificate[];
        withdrawals: Withdrawals;
        fee: Lovelace;
        validityInterval: ValidityInterval;
        update: UpdateAlonzo;
        mint: Value;
        network: Network | Null;
        scriptIntegrityHash: DigestBlake2BScriptIntegrity | Null;
        requiredExtraSignatures: DigestBlake2BVerificationKey[];
    };
    witness: {
        signatures: {
            [k: string]: Signature;
        };
        scripts: {
            [k: string]: Script;
        };
        bootstrap: BootstrapWitness[];
        datums: {
            [k: string]: Datum;
        };
        redeemers: {
            [k: string]: Redeemer;
        };
    };
    metadata: AuxiliaryData | Null;
    raw: string;
}
export interface UpdateProposalAlonzo {
    epoch: Epoch;
    proposal: {
        [k: string]: ProtocolParametersAlonzo;
    };
}
export interface ProtocolParametersAlonzo {
    minFeeCoefficient: NullableUInt64;
    minFeeConstant: NullableUInt64;
    maxBlockBodySize: NullableUInt64;
    maxBlockHeaderSize: NullableUInt64;
    maxTxSize: NullableUInt64;
    stakeKeyDeposit: NullableUInt64;
    poolDeposit: NullableUInt64;
    poolRetirementEpochBound: NullableUInt64;
    desiredNumberOfPools: NullableUInt64;
    poolInfluence: NullableRatio;
    monetaryExpansion: NullableRatio;
    treasuryExpansion: NullableRatio;
    decentralizationParameter: NullableRatio;
    minPoolCost: NullableUInt64;
    coinsPerUtxoWord: NullableUInt64;
    maxValueSize: NullableUInt64;
    collateralPercentage: NullableUInt64;
    maxCollateralInputs: NullableUInt64;
    extraEntropy: Nonce | Null;
    protocolVersion: ProtocolVersion | Null;
    costModels: CostModels | Null;
    prices: Prices | Null;
    maxExecutionUnitsPerTransaction: ExUnits | Null;
    maxExecutionUnitsPerBlock: ExUnits | Null;
}
export interface Mary {
    mary: BlockMary;
}
export interface BlockMary {
    body: TxMary[];
    headerHash: DigestBlake2BBlockHeader;
    header: {
        blockHeight: BlockNo;
        slot: Slot;
        prevHash: DigestBlake2BBlockHeader;
        issuerVk: VerificationKey;
        issuerVrf: IssuerVrfVerificationKey;
        nonce?: CertifiedVrf;
        leaderValue: CertifiedVrf;
        blockSize: BlockSize;
        blockHash: DigestBlake2BBlockBody;
        opCert: OpCert;
        protocolVersion: ProtocolVersion;
        signature: IssuerSignature;
    };
}
export interface TxMary {
    id: DigestBlake2BBlockBody;
    body: {
        inputs: TxIn[];
        outputs: TxOut[];
        certificates: Certificate[];
        withdrawals: Withdrawals;
        fee: Lovelace;
        validityInterval: ValidityInterval;
        update: UpdateShelley;
        mint: Value;
    };
    witness: {
        signatures: {
            [k: string]: Signature;
        };
        scripts: {
            [k: string]: Script;
        };
        bootstrap: BootstrapWitness[];
    };
    metadata: AuxiliaryData | Null;
    raw: string;
}
export interface UpdateProposalShelley {
    epoch: Epoch;
    proposal: {
        [k: string]: ProtocolParametersShelley;
    };
}
export interface ProtocolParametersShelley {
    minFeeCoefficient: NullableUInt64;
    minFeeConstant: NullableUInt64;
    maxBlockBodySize: NullableUInt64;
    maxBlockHeaderSize: NullableUInt64;
    maxTxSize: NullableUInt64;
    stakeKeyDeposit: NullableUInt64;
    poolDeposit: NullableUInt64;
    poolRetirementEpochBound: NullableUInt64;
    desiredNumberOfPools: NullableUInt64;
    poolInfluence: NullableRatio;
    monetaryExpansion: NullableRatio;
    treasuryExpansion: NullableRatio;
    decentralizationParameter: NullableRatio;
    minUtxoValue: NullableUInt64;
    minPoolCost: NullableUInt64;
    extraEntropy: Nonce | Null;
    protocolVersion: ProtocolVersion | Null;
}
export interface Allegra {
    allegra: BlockAllegra;
}
export interface BlockAllegra {
    body: TxAllegra[];
    headerHash: DigestBlake2BBlockHeader;
    header: {
        blockHeight: BlockNo;
        slot: Slot;
        prevHash: DigestBlake2BBlockHeader;
        issuerVk: VerificationKey;
        issuerVrf: IssuerVrfVerificationKey;
        nonce?: CertifiedVrf;
        leaderValue: CertifiedVrf;
        blockSize: BlockSize;
        blockHash: DigestBlake2BBlockBody;
        opCert: OpCert;
        protocolVersion: ProtocolVersion;
        signature: IssuerSignature;
    };
}
export interface TxAllegra {
    id: DigestBlake2BBlockBody;
    body: {
        inputs: TxIn[];
        outputs: TxOut[];
        certificates: Certificate[];
        withdrawals: Withdrawals;
        fee: Lovelace;
        validityInterval: ValidityInterval;
        update: UpdateShelley;
    };
    witness: {
        signatures: {
            [k: string]: Signature;
        };
        scripts: {
            [k: string]: Script;
        };
        bootstrap: BootstrapWitness[];
    };
    metadata: AuxiliaryData | Null;
    raw: string;
}
export interface Shelley {
    shelley: BlockShelley;
}
export interface BlockShelley {
    body: TxShelley[];
    headerHash: DigestBlake2BBlockHeader;
    header: {
        blockHeight: BlockNo;
        slot: Slot;
        prevHash: DigestBlake2BBlockHeader;
        issuerVk: VerificationKey;
        issuerVrf: IssuerVrfVerificationKey;
        nonce?: CertifiedVrf;
        leaderValue: CertifiedVrf;
        blockSize: BlockSize;
        blockHash: DigestBlake2BBlockBody;
        opCert: OpCert;
        protocolVersion: ProtocolVersion;
        signature: IssuerSignature;
    };
}
export interface TxShelley {
    id: DigestBlake2BBlockBody;
    body: {
        inputs: TxIn[];
        outputs: TxOut[];
        certificates: Certificate[];
        withdrawals: Withdrawals;
        fee: Lovelace;
        timeToLive: Slot;
        update: UpdateShelley;
    };
    witness: {
        signatures: {
            [k: string]: Signature;
        };
        scripts: {
            [k: string]: Script;
        };
        bootstrap: BootstrapWitness[];
    };
    metadata: AuxiliaryData | Null;
    raw: string;
}
export interface Byron {
    byron: BlockByron;
}
export interface StandardBlock {
    hash: DigestBlake2BBlockHeader;
    header: {
        blockHeight: BlockNo;
        genesisKey: GenesisVerificationKey;
        prevHash: DigestBlake2BBlockHeader;
        proof: BlockProof;
        protocolMagicId: ProtocolMagicId;
        protocolVersion: ProtocolVersion;
        signature: BlockSignature;
        slot: Slot;
        softwareVersion: SoftwareVersion;
    };
    body: {
        txPayload: TxByron[];
        dlgPayload: DlgCertificate[];
        updatePayload: {
            proposal: Null | UpdateProposalByron;
            votes: Vote[];
        };
    };
}
export interface BlockProof {
    utxo: {
        number: UInt32;
        root: DigestBlake2BMerkleRoot;
        witnessesHash: DigestBlake2BBlockByronBodyTxPayloadWitness;
    };
    delegation: DigestBlake2BBlockByronBodyDlgPayload;
    update: DigestBlake2BBlockByronBodyUpdatePayload;
}
export interface BlockSignature {
    dlgCertificate: DlgCertificate;
    signature: IssuerSignature;
}
export interface DlgCertificate {
    epoch: Epoch;
    issuerVk: GenesisVerificationKey;
    delegateVk: GenesisVerificationKey;
    signature: IssuerSignature;
}
export interface SoftwareVersion {
    appName: string;
    number: UInt32;
}
export interface TxByron {
    id: TxId;
    body: {
        inputs: TxIn[];
        outputs: TxOut[];
    };
    witness: TxWitness[];
    raw: string;
}
export interface WitnessVk {
    witnessVk: {
        key: DigestBlake2BVerificationKey;
        signature: Signature;
    };
}
export interface RedeemWitness {
    redeemWitness: {
        key: VerificationKey;
        signature: Signature;
    };
}
export interface UpdateProposalByron {
    body: {
        protocolVersion: ProtocolVersion;
        softwareVersion: SoftwareVersion;
        metadata: {
            [k: string]: string;
        };
        parametersUpdate: ProtocolParametersByron;
    };
    issuer: IssuerVrfVerificationKey;
    signature: IssuerSignature;
}
export interface ProtocolParametersByron {
    heavyDlgThreshold: NullableRatio;
    maxBlockSize: NullableUInt64;
    maxHeaderSize: NullableUInt64;
    maxProposalSize: NullableUInt64;
    maxTxSize: NullableUInt64;
    mpcThreshold: NullableRatio;
    scriptVersion: NullableUInt64;
    slotDuration: NullableUInt64;
    unlockStakeEpoch: NullableUInt64;
    updateProposalThreshold: NullableRatio;
    updateProposalTimeToLive: NullableUInt64;
    updateVoteThreshold: NullableRatio;
    txFeePolicy: TxFeePolicy | Null;
    softforkRule: SoftForkRule | Null;
}
export interface TxFeePolicy {
    coefficient: Ratio;
    constant: number;
}
export interface SoftForkRule {
    initThreshold: NullableRatio;
    minThreshold: NullableRatio;
    decrementThreshold: NullableRatio;
}
export interface Vote {
    voterVk: VerificationKey;
    proposalId: DigestBlake2BVerificationKey;
    signature: Signature;
}
export interface EpochBoundaryBlock {
    hash: DigestBlake2BBlockHeader;
    header: {
        blockHeight: BlockNo;
        epoch: Epoch;
        prevHash: DigestBlake2BBlockHeader;
    };
}
export interface Tip {
    slot: Slot;
    hash: DigestBlake2BBlockHeader;
    blockNo: BlockNo;
}
export interface RollBackward {
    RollBackward: {
        point: PointOrOrigin;
        tip: TipOrOrigin;
    };
}
export interface Point {
    slot: Slot;
    hash: DigestBlake2BBlockHeader;
}
export interface IntersectionFound {
    IntersectionFound: {
        point: PointOrOrigin;
        tip: TipOrOrigin;
    };
}
export interface IntersectionNotFound {
    IntersectionNotFound: {
        tip: TipOrOrigin;
    };
}
export interface SubmitSuccess {
    SubmitSuccess: {
        txId: TxId;
    };
}
export interface SubmitFail {
    SubmitFail: SubmitTxError;
}
export interface EraMismatch {
    eraMismatch: {
        queryEra: Era;
        ledgerEra: Era;
    };
}
export interface InvalidWitnesses {
    invalidWitnesses: VerificationKey[];
}
export interface MissingVkWitnesses {
    missingVkWitnesses: DigestBlake2BVerificationKey[];
}
export interface MissingScriptWitnesses {
    missingScriptWitnesses: DigestBlake2BScript[];
}
export interface ScriptWitnessNotValidating {
    scriptWitnessNotValidating: DigestBlake2BScript[];
}
export interface InsufficientGenesisSignatures {
    insufficientGenesisSignatures: DigestBlake2BVerificationKey[];
}
export interface MissingTxMetadata {
    missingTxMetadata: DigestBlake2BAuxiliaryDataBody;
}
export interface MissingTxMetadataHash {
    missingTxMetadataHash: DigestBlake2BAuxiliaryDataBody;
}
export interface TxMetadataHashMismatch {
    txMetadataHashMismatch: {
        includedHash: DigestBlake2BAuxiliaryDataBody;
        expectedHash: DigestBlake2BAuxiliaryDataBody;
    };
}
export interface BadInputs {
    badInputs: TxIn[];
}
export interface ExpiredUtxo {
    expiredUtxo: {
        currentSlot: Slot;
        transactionTimeToLive: Slot;
    };
}
export interface OutsideOfValidityInterval {
    outsideOfValidityInterval: {
        currentSlot: Slot;
        interval: ValidityInterval;
    };
}
export interface TxTooLarge {
    txTooLarge: {
        maximumSize: Int64;
        actualSize: Int64;
    };
}
export interface MissingAtLeastOneInputUtxo {
    missingAtLeastOneInputUtxo: null;
}
export interface InvalidMetadata {
    invalidMetadata: null;
}
export interface FeeTooSmall {
    feeTooSmall: {
        requiredFee: Lovelace;
        actualFee: Lovelace;
    };
}
export interface ValueNotConserved {
    valueNotConserved: {
        consumed: LovelaceDelta | Value;
        produced: LovelaceDelta | Value;
    };
}
export interface NetworkMismatch {
    networkMismatch: {
        expectedNetwork: Network;
        invalidEntities: InvalidEntity[];
    };
}
export interface OutputTooSmall {
    outputTooSmall: (TxOut | {
        output: TxOut;
        minimumRequiredValue: Lovelace;
    })[];
}
export interface TooManyAssetsInOutput {
    tooManyAssetsInOutput: TxOut[];
}
export interface AddressAttributesTooLarge {
    addressAttributesTooLarge: Address[];
}
export interface TriesToForgeAda {
    triesToForgeAda: null;
}
export interface DelegateNotRegistered {
    delegateNotRegistered: PoolId;
}
export interface UnknownOrIncompleteWithdrawals {
    unknownOrIncompleteWithdrawals: Withdrawals;
}
export interface StakePoolNotRegistered {
    stakePoolNotRegistered: PoolId;
}
export interface WrongRetirementEpoch {
    wrongRetirementEpoch: {
        currentEpoch: Epoch;
        requestedEpoch: Epoch;
        firstUnreachableEpoch: Epoch;
    };
}
export interface WrongPoolCertificate {
    wrongPoolCertificate: UInt8;
}
export interface StakeKeyAlreadyRegistered {
    stakeKeyAlreadyRegistered: DigestBlake2BVerificationKey;
}
export interface PoolCostTooSmall {
    poolCostTooSmall: {
        minimumCost: Lovelace;
    };
}
export interface PoolMetadataHashTooBig {
    poolMetadataHashTooBig: {
        poolId: PoolId;
        measuredSize: Int64;
    };
}
export interface StakeKeyNotRegistered {
    stakeKeyNotRegistered: DigestBlake2BVerificationKey;
}
export interface RewardAccountNotExisting {
    rewardAccountNotExisting: null;
}
export interface RewardAccountNotEmpty {
    rewardAccountNotEmpty: {
        balance: Lovelace;
    };
}
export interface WrongCertificateType {
    wrongCertificateType: null;
}
export interface UnknownGenesisKey {
    unknownGenesisKey: DigestBlake2BVerificationKey;
}
export interface AlreadyDelegating {
    alreadyDelegating: DigestBlake2BVerificationKey;
}
export interface InsufficientFundsForMir {
    insufficientFundsForMir: {
        rewardSource: RewardPot;
        sourceSize: Lovelace;
        requestedAmount: Lovelace;
    };
}
export interface TooLateForMir {
    tooLateForMir: {
        currentSlot: Slot;
        lastAllowedSlot: Slot;
    };
}
export interface MirTransferNotCurrentlyAllowed {
    mirTransferNotCurrentlyAllowed: null;
}
export interface MirNegativeTransferNotCurrentlyAllowed {
    mirNegativeTransferNotCurrentlyAllowed: null;
}
export interface MirProducesNegativeUpdate {
    mirProducesNegativeUpdate: null;
}
export interface DuplicateGenesisVrf {
    duplicateGenesisVrf: DigestBlake2BVrfVerificationKey;
}
export interface NonGenesisVoters {
    nonGenesisVoters: {
        currentlyVoting: DigestBlake2BVerificationKey[];
        shouldBeVoting: DigestBlake2BVerificationKey[];
    };
}
export interface UpdateWrongEpoch {
    updateWrongEpoch: {
        currentEpoch: Epoch;
        requestedEpoch: Epoch;
        votingPeriod: VotingPeriod;
    };
}
export interface ProtocolVersionCannotFollow {
    protocolVersionCannotFollow: ProtocolVersion;
}
export interface MissingRequiredRedeemers {
    missingRequiredRedeemers: {
        missing: {
            [k: string]: ScriptPurpose;
        }[];
    };
}
export interface Spend {
    spend: TxIn;
}
export interface Mint {
    mint: DigestBlake2BScript;
}
export interface Certificate1 {
    certificate: Certificate;
}
export interface Withdrawal {
    withdrawal: RewardAccount;
}
export interface MissingRequiredDatums {
    missingRequiredDatums: {
        provided?: DigestBlake2BDatum[];
        missing: DigestBlake2BDatum[];
    };
}
export interface UnspendableDatums {
    unspendableDatums: {
        nonSpendable: DigestBlake2BDatum[];
        acceptable: DigestBlake2BDatum[];
    };
}
export interface ExtraDataMismatch {
    extraDataMismatch: {
        provided: DigestBlake2BScriptIntegrity | Null;
        inferredFromParameters: DigestBlake2BScriptIntegrity | Null;
    };
}
export interface MissingRequiredSignatures {
    missingRequiredSignatures: DigestBlake2BVerificationKey[];
}
export interface UnspendableScriptInputs {
    unspendableScriptInputs: TxIn[];
}
export interface ExtraRedeemers {
    extraRedeemers: string[];
}
export interface MissingDatumHashesForInputs {
    missingDatumHashesForInputs: TxIn[];
}
export interface MissingCollateralInputs {
    missingCollateralInputs: null;
}
export interface CollateralTooSmall {
    collateralTooSmall: {
        requiredCollateral: Lovelace;
        actualCollateral: Lovelace;
    };
}
export interface CollateralIsScript {
    collateralIsScript: Utxo;
}
export interface CollateralHasNonAdaAssets {
    collateralHasNonAdaAssets: Value;
}
export interface TooManyCollateralInputs {
    tooManyCollateralInputs: {
        maximumCollateralInputs: UInt64;
        actualCollateralInputs: UInt64;
    };
}
export interface ExecutionUnitsTooLarge {
    executionUnitsTooLarge: {
        maximumExecutionUnits: ExUnits;
        actualExecutionUnits: ExUnits;
    };
}
export interface OutsideForecast {
    outsideForecast: Slot;
}
export interface ValidationTagMismatch {
    validationTagMismatch: null;
}
export interface CollectErrors {
    collectErrors: (NoRedeemer | NoWitness | NoCostModel | BadTranslation)[];
}
export interface NoRedeemer {
    noRedeemer: ScriptPurpose;
}
export interface NoWitness {
    noWitness: DigestBlake2BScript;
}
export interface NoCostModel {
    noCostModel: Language;
}
export interface BadTranslation {
    badTranslation: string;
}
export interface ExtraScriptWitnesses {
    extraScriptWitnesses: DigestBlake2BScript[];
}
export interface MirNegativeTransfer {
    mirNegativeTransfer: {
        rewardSource: RewardPot;
        attemptedTransfer: Lovelace;
    };
}
export interface TotalCollateralMismatch {
    totalCollateralMismatch: {
        computedFromDelta: Lovelace;
        declaredInField: Lovelace;
    };
}
export interface MalformedReferenceScripts {
    malformedReferenceScripts: DigestBlake2BScript[];
}
export interface MalformedScriptWitnesses {
    malformedScriptWitnesses: DigestBlake2BScript[];
}
export interface EvaluationResult {
    EvaluationResult: {
        [k: string]: ExUnits;
    };
}
export interface EvaluationFailure {
    EvaluationFailure: EvaluationFailureScriptFailures | EvaluationFailureIncompatibleEra | EvaluationFailureAdditionalUtxoOverlap | EvaluationFailureNotEnoughSynced | EvaluationFailureCannotCreateEvaluationContext;
}
export interface EvaluationFailureScriptFailures {
    ScriptFailures: {
        [k: string]: ScriptFailure;
    };
}
export interface MissingRequiredScripts {
    missingRequiredScripts: {
        missing: RedeemerPointer[];
        resolved: {
            [k: string]: DigestBlake2BScript;
        };
    };
}
export interface ValidatorFailed {
    validatorFailed: {
        error: string;
        traces: string[];
    };
}
export interface UnknownInputReferencedByRedeemer {
    unknownInputReferencedByRedeemer: TxIn;
}
export interface NonScriptInputReferencedByRedeemer {
    nonScriptInputReferencedByRedeemer: TxIn;
}
export interface IllFormedExecutionBudget {
    illFormedExecutionBudget: ExUnits | Null;
}
export interface NoCostModelForLanguage {
    noCostModelForLanguage: Language;
}
export interface EvaluationFailureIncompatibleEra {
    IncompatibleEra: "Byron" | "Shelley" | "Allegra" | "Mary";
}
export interface EvaluationFailureAdditionalUtxoOverlap {
    AdditionalUtxoOverlap: TxIn[];
}
export interface EvaluationFailureNotEnoughSynced {
    NotEnoughSynced: {
        minimumRequiredEra: Era;
        currentNodeEra: Era;
    };
}
export interface EvaluationFailureCannotCreateEvaluationContext {
    CannotCreateEvaluationContext: {
        reason: string;
    };
}
export interface AcquireSuccess {
    AcquireSuccess: {
        point: PointOrOrigin;
    };
}
export interface AcquireFailure {
    AcquireFailure: {
        failure: AcquireFailureDetails;
    };
}
export interface AwaitAcquired {
    AwaitAcquired: {
        slot: Slot;
    };
}
export interface MempoolSizeAndCapacity {
    capacity: UInt32;
    currentSize: UInt32;
    numberOfTxs: UInt32;
}
export interface GetNonMyopicMemberRewards {
    nonMyopicMemberRewards: Lovelace[] | StakeCredential[];
}
export interface GetDelegationsAndRewards {
    delegationsAndRewards: StakeCredential[];
}
export interface GetUtxoByAddress {
    utxo: Address[];
}
export interface GetUtxoByTxIn {
    utxo: TxIn[];
}
export interface GetPoolParameters {
    poolParameters: (PoolId | string)[];
}
export interface Bound {
    time: RelativeTime;
    slot: Slot;
    epoch: Epoch;
}
export interface EraSummary {
    start: Bound;
    end: Bound | null;
    parameters: EraParameters;
}
export interface EraParameters {
    epochLength: Epoch;
    slotLength: SlotLength;
    safeZone: SafeZone | null;
}
export interface NonMyopicMemberRewards {
    [k: string]: {
        [k: string]: number;
    };
}
export interface DelegationsAndRewardsByAccounts {
    [k: string]: DelegationsAndRewards;
}
export interface DelegationsAndRewards {
    delegate?: PoolId;
    rewards?: Lovelace;
}
export interface ProposedProtocolParametersShelley {
    [k: string]: ProtocolParametersShelley;
}
export interface ProposedProtocolParametersAlonzo {
    [k: string]: ProtocolParametersAlonzo;
}
export interface ProposedProtocolParametersBabbage {
    [k: string]: ProtocolParametersBabbage;
}
export interface PoolDistribution {
    [k: string]: {
        stake: Ratio;
        vrf: DigestBlake2BVrfVerificationKey;
    };
}
export interface CompactGenesis {
    systemStart: UtcTime;
    networkMagic: NetworkMagic;
    network: Network;
    activeSlotsCoefficient: Ratio;
    securityParameter: UInt64;
    epochLength: Epoch;
    slotsPerKesPeriod: UInt64;
    maxKesEvolutions: UInt64;
    slotLength: SlotLength;
    updateQuorum: UInt64;
    maxLovelaceSupply: UInt64;
    protocolParameters: ProtocolParametersShelley;
}
export interface RewardsProvenance {
    epochLength: Epoch;
    decentralizationParameter: Ratio;
    maxLovelaceSupply: Lovelace;
    mintedBlocks: {
        [k: string]: UInt64;
    };
    totalMintedBlocks: number;
    totalExpectedBlocks: number;
    incentive: bigint;
    rewardsGap: bigint;
    availableRewards: bigint;
    totalRewards: bigint;
    treasuryTax: bigint;
    activeStake: bigint;
    pools: {
        [k: string]: IndividualPoolRewardsProvenance;
    };
}
export interface IndividualPoolRewardsProvenance {
    totalMintedBlocks: number;
    totalStakeShare: string;
    activeStakeShare: string;
    ownerStake: bigint;
    parameters: PoolParameters;
    pledgeRatio: string;
    maxRewards: bigint;
    apparentPerformance: string;
    totalRewards: bigint;
    leaderRewards: bigint;
}
export interface RewardsProvenance1 {
    desiredNumberOfPools: number;
    poolInfluence: string;
    totalRewards: bigint;
    activeStake: bigint;
    pools: {
        [k: string]: RewardInfoPool;
    };
}
export interface RewardInfoPool {
    stake: Lovelace;
    ownerStake: bigint;
    approximatePerformance: number;
    poolParameters: {
        cost: Lovelace;
        margin: Ratio;
        pledge: Lovelace;
    };
}
export interface PoolsRanking {
    [k: string]: {
        score: number;
        estimatedHitRate: number;
    };
}
//# sourceMappingURL=index.d.ts.map